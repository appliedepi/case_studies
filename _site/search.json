[
  {
    "objectID": "pages/multidisease_surveillance.pt.html",
    "href": "pages/multidisease_surveillance.pt.html",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Ferramenta: R Complexidade técnica: Intermédiaria Complexidade metodológica: Básica\nConhecimentos prévios necessários: Noções básicas de R (Utilizando Rstudio; pacotes R, funções e argumentos, utilização de pipes), bem como as principais funções tidyverse e ggplots)\nFonte: Applied Epi, com apoio técnico fornecido pelo CDC Global Surveillance, Laboratory, and Data Systems Branch em colaboração com a TEPHINET.\nDuração estimada: 4 horas\n\n\n\nPara obter instruções sobre como utilizar os nossos estudos de caso, consulte o nosso guia. Agradecemos comentários e sugestões via contact@appliedepi.org. Também pode discutir o estudo de caso ou conceitos relacionados na Comunidade Applied Epi.\n\n\nVocê é um epidemiologista que trabalha no serviço nacional de vigilância de Feveria, um país tropical muito pequeno. Existem três distritos em Feveria:\n\nFeveria Central:uma área urbana superpovoada, com infraestrutura de água e saneamento às vezes precária.\nLago Minara: uma zona lacustre com boa infra-estrutura mas muitos mosquitos nos meses mais quentes do ano.\nKasara: uma zona mais suburbana do outro lado de Feveria Central.\n\nMapa dos distritos do país Feveria\n\nÉ janeiro de 2025, e sua supervisora gostaria que você transferisse o processamento rotineiro dos dados de doenças de notificação compulsória do Excel para o R e realizasse algumas análises com os dados. Ela quer saber pelo menos:\n\nQuantos casos suspeitos das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi a mais comum?\nQual porcentagem deles acabou sendo confirmada?\nQuantos casos confirmados das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi a mais comum?\nComo é que os casos confirmados foram distribuídos geográfica e temporalmente em Feveria?\n\nEla pede que você escreva código para importar, limpar, relacionar e analisar as seguintes listas de casos (linelists):\n\nDados de vigilância de doenças notificáveis de 2024: Também designados por “dados de notificação”, estes são dados de vigilância de cinco doenças notificáveis comunicadas pelas clínicas do Feveria: dengue, malária, cólera, febre tifoide e febre amarela. Trata-se de casos suspeitos, baseados nos sintomas dos pacientes. Os médicos introduzem cada notificação num sistema em linha todos os dias da semana.\n2024 dados de resultados de testes laboratoriais: Estes dados provêm de resultados de análises laboratoriais de três grandes laboratórios de Feveria. Estes resultados referem-se a amostras colhidas dos casos suspeitos de doenças notificáveis mencionados acima.\n\nVamos lá!\n\n\n\nNeste estudo de caso, você vai:\n\nUsar funções-chave do R para limpar os dados, reorganizar os conjuntos de dados, relacionar fontes de dados e criar novas colunas usando condições lógicas, a fim de preparar os dados para análise.\nRealizar inspecções de dados e verificações da qualidade dos dados em várias fases do projeto e compreender a sua importância para uma análise confiável.\nRealizar análises descritivas básicas para comparar as tendências das doenças entre diferentes fontes de dados, antes e depois do linkage.\nInterpretar as diferenças nos resultados entre as fontes de dados e compreender como elas refletem a estrutura e o desenho do sistema de vigilância como um todo.\n\n\n\n\n\n\nComece por estabelecer um fluxo de trabalho reproduzível e bem organizado. Este facilitará a repetição da sua análise sempre que necessário.\nTarefas:\n\nConfigurar um projeto RStudio\nConfigurar subpastas claras onde o seu código, dados e resultados serão colocados\nCrie um script R, ou um arquivo R Markdown, se preferir. Certifique-se de que que o objetivo do script, a data e o autor estão escritos como comentários no topo.\nExtra: Certifique-se de que a sua linguagem de trabalho no RStudio é apropriada (por exemplo, inglês para este exercício)\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\n\nCrie uma pasta para onde irá todo o trabalho deste estudo de caso. Por exemplo, crie a pasta ‘multidoencas_lab’ no ambiente de trabalho do seu computador. Crie o seu projeto RStudio para ser baseado nesta pasta.\nSugerimos que crie as seguintes subpastas: scripts (para os códigos), data (para os seus dados), e outputs (para os resultados da análise).\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nCrie uma pasta (por exemplo, ‘multidoencas_lab’ no seu ambiente de trabalho) para o seu trabalho. Para criar um projeto Rstudio na sua nova pasta, clique em New Project… no canto superior esquerdo do seu R Studio e, em seguida Existing Directory e, em seguida Browse para selecionar a sua nova pasta. Para mais informações, consulte a secção Projetos R do Manual de R para Epidemiologistas\nInicie um novo script R clicando em New File… no canto superior esquerdo do seu R Studio e, em seguida R Script. Salve-o imediatamente no local apropriado, por exemplo, em uma subpasta ‘scripts’ dentro da pasta que contém seu projeto RStudio.\nNo topo do seu novo script R, escreva algumas informações essenciais como o seu nome, o objetivo do script e a data.\nO locale do R determina o idioma e as definições regionais utilizadas para o coisas como formatos de data e traduções. Se a sua localidade for diferente do idioma que pretende para o seu relatório (por exemplo, uma localidade francesa vs. uma localidade em inglês), pode alterá-la para inglês executando Sys.setlocale(\"LC_ALL\", \"English\"). Inclua isto no seu script se necessário, ou ignore-o se a sua localidade for normalmente apropriada. Isto é explicado em mais detalhes na seção Guia de instruções.\n\n\n\n\n\n\nA seguir, no seu script R, você precisa instalar e carregar os pacotes R necessários. Isto garante que as funções necessárias estarão disponíveis para sua análise.\nSão necessários os seguintes pacotes: {rio} (para importação de dados),{skimr} (para explroar os dados), {janitor} (para limpeza de dados), {lubridate} (para limpeza de datas), {epikit} (para tarefas relacionadas com epidemiologia), {gtsummary} (para estatísticas resumidas/testes e regressão), {apyramid} (para pirâmides etárias), {flextable} (para tabelas prontas para apresentação), {naniar} (para avaliar dados faltantes), e {tidyverse} (para tarefas gerais de manipulação de dados). Também vai precisar do {remotes} para baixar os dados - o que explicaremos na seção de download.\nAo começar, seu colega de confiança te cutuca e sussurra: “Ouvi dizer que uma ótima forma de gerenciar seus pacotes é com o pacote {pacman}”.\nAgora é com você!\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize a função p_load() do pacote pacman para esta tarefa. Você fornece uma lista de pacotes que deseja utilizar. A função executará dois passos por pacote: 1) Verificar se o pacote está instalado no seu computador, e instalá-lo se necessário, depois 2) Carregar o pacote para que ele possa ser usado durante esta sessão do R.\nSe ainda não tem pacman instalado, será necessário instalar ele da “maneira tradicional”, com install.packages().\nNote que a ordem dos pacotes na sua função p_load pode ser importante. Se dois pacotes tiverem os mesmos nomes de função (por exemplo select() no pacote MASS e select() na tidyverse, que fazem diferentes coisas), então o R utilizará a função do pacote mais recentemente carregado. Para dar prioridade às funções do tidyverse, que são normalmente utilizadas para manipulação e visualização de dados, carregue sempre tidyverse por último.\n\n# Garante que o pacote \"pacman\" está instalado\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\")\n}\n\n# Instala (se necessário) a partir do CRAN e carrega os pacotes a serem usados\npacman::p_load(\n  rio,        # importar dados\n  skimr,      # obter visão geral dos dados\n  janitor,    # limpeza de dados e criação de tabelas\n  lubridate,  # trabalhar com datas\n  epikit,     # criar categorias de idade\n  gtsummary,  # estatísticas resumidas, testes e regressões\n  apyramid,   # plotar pirâmides etárias\n  flextable,  # tabelas prontas para apresentação\n  naniar,     # avaliar dados ausentes\n  remotes,    # usado para instalar pacotes para baixar dados\n  tidyverse   # gestão de dados e visualização\n)\n\n\n\n\n\n\n\n\n\n\nO seu escritório fornece-lhe dois arquivos para a sua análise, ambos com dados relativos a 2024 e atualizados a partir de 15 de janeiro de 2025:\n\nUm conjunto de dados no nível de notificação de doenças (“notificacoes_multidoencas.xlsx”) com informações de casos de 5 centros de saúde.\nUm conjunto de dados a nível de exames laboratoriais (“testes_multidoencas.csv”) apresentado por três laboratórios que efetuam exames para os 5 centros de saúde.\n\nPara este estudo de caso, você pode baixar os dados através do repositório de dados muito útil do Applied Epi, que pode ser acessado usando o pacote {appliedepidata}.\nSiga estes passos:\n\nInstale o pacote {appliedepidata} do GitHub usando a função install_github() do pacote {remotes} (que você instalou anteriormente).\n\n\n# Use a função install_github do pacote remotes para instalar o appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSalve os dois conjuntos de dados numa pasta específica utilizando a função save_data() do pacote {appliedepidata}. Execute o código abaixo. O exemplo abaixo salva os dados em uma subpasta data dentro do projeto do RStudio. Observe que, se você não especificar um local no argumento path da função, uma janela será exibida pedindo para selecionar manualmente uma pasta.\n\n\n# Salva os dois arquivos de dados usando a função save_data() do pacote appliedepidata\nappliedepidata::save_data(\"testes_multidoencas\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"notificacoes_multidoencas\",\n                          path = \"data\")\n\n\n\n\nÓtimo! Obrigado ao escritório do país e à Applied Epi! Agora é hora de importar os dados dessa pasta para o RStudio, para que você possa analisá-los.\n\n\nIdealmente, utilizará a mesma função para importar ambos os conjuntos de dados, apesar de uma ser um arquivo .csv e o outro um arquivo .xlsx. Nota: daqui para a frente, diremos simplesmente “ambiente” quando nos referirmos ao painel ambiente (Environment) no R Studio.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nUse a função import do pacote {rio} que consegue reconhecer e importar diferentes tipos de arquivos. Ela substitui funções de importação específicas para cada tipo de arquivo, como read.csv() do {base} para arquivos .csv e read_excel() do {readxl} para importar arquivos .xlsx.\nSe achar que precisa de saber mais sobre funções de importação, leia o capítulo Importar e exportar do Manual de R para Epidemiologistas\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAbaixo usamos a função import para carregar os dois arquivos. Note que estamos atribuindo os dados importados a dois objetos: um chamado dados_notif_bruto e outro chamado dados_lab_bruto. Adicionamos o sufixo ‘bruto’ para diferenciar esses dados das versões limpas que criaremos posteriormente.\n\n# Importar dados\n\n# Dados de notificação\ndados_notif_bruto &lt;- import(\"data/notificacoes_multidoencas.xlsx\")\n\n# Dados laboratoriais\ndados_lab_bruto &lt;- import(\"data/testes_multidoencas.csv\")\n\n\n\n\n\n\n\n\n\nOs dados foram importados e agora é hora de ver que história eles contam. Faça uma análise inicial dos dois data frames brutos para verificar seu conteúdo e qualidade.\n\n\n\n\nUse as funções skim() do pacote {skimr}, names(), ncol() e nrow() para inspecionar seu conjunto de dados.\nA função skim() fornece muitas informações sobre a estrutura e o conteúdo dos dados, enquanto names() mostra os diferentes nomes das colunas. As funções ncol() e nrow() contam, respectivamente, o número de colunas e linhas do conjunto de dados. Você sabe o que colocar dentro dos parênteses?\nO jeito mais fácil, no entanto, é olhar diretamente o ambiente do RStudio.\nLembre-se: o objeto no seu ambiente referente às notificações se chama dados_notif_bruto.\nClique na caixa de solução abaixo das perguntas se precisar de ajuda.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas existem nos dados de notificações?\n\n 10 11 12 13\n\nQuais dessas colunas NÃO estão nos dados?\n\n Data de início dos sintomas Data comunicada pela unidade de saúde/comunidade Data do Resultado Data do teste Data de nascimento\n\nQual é o nome da coluna nos dados de notificação que identifica cada notificação?\n\n ID notificacao ID do teste Codigo da unidade de saude Combinação de ID notificacao e Sexo\n\nQuantas linhas existem nos dados de notificação?\n\n 987 1314 950 778\n\nQue tipo de informação você NÃO consegue ver nos dados de notificação?\n\n Resultados de exames laboratoriais Distrito de residência Data de nascimento e Sexo Unidade de saúde em que o caso foi diagnosticado Desfecho\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUse a função skim() do pacote {skimr} para ver um resumo de todo o data frame, e View() para visualizar diretamente o data frame completo:\n\nskim(dados_notif_bruto)\n\nOu você pode usar names() para exibir apenas os nomes das colunas. Com skim() ou names() você poderá ver os tipos de informação, incluindo: a unidade de saúde do caso, data de nascimento, sexo, um indicador de gravidez, distrito de residência, data de início dos sintomas, data comunicada pela clínica e informações sobre o desfecho.\nTambém existe um ID notificacao, que parece ser um identificador único para cada caso, mas é recomendável verificar duplicatas antes de ter certeza.\nObserve que NÃO há resultados de testes nesses dados, pois essas notificações são de clínicas que diagnosticam doenças de notificação compulsória com base em definições clínicas de caso.\n\nnames(dados_notif_bruto)\n\n [1] \"Nome da unidade organizacional\"                  \n [2] \"Codigo da unidade de saude\"                      \n [3] \"ID notificacao\"                                  \n [4] \"Data de nascimento\"                              \n [5] \"Sexo\"                                            \n [6] \"Gestante\"                                        \n [7] \"Distrito de residencia\"                          \n [8] \"Doenca notificada\"                               \n [9] \"Data de inicio dos sintomas\"                     \n[10] \"Data comunicada pela unidade de saude/comunidade\"\n[11] \"Resultado\"                                       \n[12] \"Data do resultado\"                               \n\n\nUse ncol() e nrow() para exibir o número de colunas e linhas, assim:\n\nncol(dados_notif_bruto)\nnrow(dados_notif_bruto)\n\nIsso exibirá o número de colunas e linhas no console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nDe outro modo, ao olhar para o ambiente, você pode ver que o número de observações (que é o mesmo que o número de linhas) e o número de colunas estão listados ao lado do nome do data frame.\n\n\n\n\n\n\nUse a função skim() do pacote {skimr} ou class() para inspecionar as classes das colunas.\nVocê se lembra de como especificar a coluna de interesse dentro da função class()?\nComo alternativa, você pode simplesmente olhar para o ambiente.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas do data frame de notificações são reconhecidas pelo R como colunas de data?\n\n 0 2 4\n\nQual é a classe da maioria das colunas no data frame bruto de notificações?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVocê pode usar a função class() como no exemplo abaixo. O $ é um operador usado para selecionar uma coluna específica do data frame dados_notif_bruto.\nObserve que os acentos graves (`) são usados em torno de Data de nascimento porque o nome da coluna contém espaços.\n\nclass(dados_notif_bruto$`Data de nascimento`)\n\nPara verificar a classe pelo ambiente, clique na seta azul ao lado do nome do data frame.\nOs nomes das colunas aparecerão, com a classe ao lado (por exemplo, aparece “chr” para indicar que é do tipo character).\nVocê pode ver que nenhuma das colunas que deveriam ser datas é reconhecida como tal.\nEm vez disso, elas são reconhecidas como valores do tipo character.\n\n\n\n\n\n\nUse a função tabyl() para inspecionar os valores dentro de colunas categóricas, especificando o objeto do data frame no primeiro argumento e o nome da coluna no segundo argumento.\nPor exemplo, este código tabula os valores da coluna Sexo. A saída mostra que “masculino” e “feminino” estão escritos de forma inconsistente nos dados. Essa coluna precisará de limpeza adicional antes da análise.\n\ntabyl(dados_notif_bruto, Sexo)\n\n      Sexo   n    percent valid_percent\n         F  47 0.04761905    0.05452436\n  FEMININO 146 0.14792300    0.16937355\n         M  40 0.04052685    0.04640371\n MASCULINO 172 0.17426545    0.19953596\n         f 154 0.15602837    0.17865429\n  feminino  98 0.09929078    0.11368910\n         m 119 0.12056738    0.13805104\n masculino  86 0.08713273    0.09976798\n      &lt;NA&gt; 125 0.12664640            NA\n\n\nPara inspecionar dados ausentes, você pode usar a função miss_var_summary() do pacote {naniar}:\n\nmiss_var_summary(dados_notif_bruto)\n\n# A tibble: 12 × 3\n   variable                                         n_miss pct_miss\n   &lt;chr&gt;                                             &lt;int&gt;    &lt;num&gt;\n 1 Data de inicio dos sintomas                         691     70.0\n 2 Gestante                                            510     51.7\n 3 Resultado                                           197     20.0\n 4 Data do resultado                                   197     20.0\n 5 Data de nascimento                                  168     17.0\n 6 Sexo                                                125     12.7\n 7 Nome da unidade organizacional                        0      0  \n 8 Codigo da unidade de saude                            0      0  \n 9 ID notificacao                                        0      0  \n10 Distrito de residencia                                0      0  \n11 Doenca notificada                                     0      0  \n12 Data comunicada pela unidade de saude/comunidade      0      0  \n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nOs valores na coluna Distrito de residência estão padronizados?\n\n Não - precisam ser limpas Estão padronizadas e prontas para análise\n\nOs valores na coluna Doença notificada estão padronizados?\n\n Não - precisam ser limpas Estão padronizadas e prontas para análise\n\nO que o R reconhece como valor ausente?\n\n Ou nenhum valor, ou apenas um espaço, ou apenas um ponto Nenhum valor em uma célula, representado por NA As palavras Desconhecido e Incerto\n\nCom base na quantidade de valores ausentes, a coluna Data de início dos sintomas é útil?\n\n Sim, o índice de ausentes é baixo, então esta coluna é útil Minimamente, pois o índice de ausentes é muito alto\n\nPor que algumas colunas nos dados de notificação podem ter diferentes grafias e categorias não padronizadas?\n\n Um robô embaralha os dados para que fiquem menos identificáveis Cada clínica pode usar softwares configurados de forma ligeiramente diferente ou permitir entradas em texto livre, gerando variações na escrita O software do sistema de vigilância usado pelas unidades clínicas possui muitos erros\n\nPor que algumas colunas nos dados de notificação podem apresentar grande quantidade de valores ausentes?\n\n O clínico não faz a pergunta ao paciente durante a consulta O paciente pode não saber ou não querer informar a resposta O clínico pode não ter tempo de priorizar o preenchimento desse campo, mesmo sabendo a informação Todas as alternativas acima, e muitos outros motivos\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUse a função tabyl() para tabular os valores da coluna Distrito de residencia.\nNovamente, o primeiro argumento é o nome do objeto do data frame e o segundo argumento é o nome da coluna.\n\ntabyl(dados_notif_bruto, `Distrito de residencia`)\n\n Distrito de residencia   n    percent\n              F Central  32 0.03242148\n              FEVERIA C  23 0.02330294\n        FEVERIA CENTRAL  85 0.08611955\n              Feveria C  24 0.02431611\n        Feveria Central  12 0.01215805\n                 KASARA  64 0.06484296\n                    KSR  17 0.01722391\n                 Kasara 109 0.11043566\n               L MINARA  50 0.05065856\n               L Minara 193 0.19554205\n            LAGO MINARA 185 0.18743668\n            Lago Minara  68 0.06889564\n               Lakeside 125 0.12664640\n\n\nVocê pode ver que cada uma das três localidades (Feveria Central, Lago Minara e Kasara) está escrita de maneiras diferentes e com capitalização diferente. Será necessário corrigir isso se quisermos analisar a distribuição geográfica das doenças de notificação compulsória.\nDe forma semelhante, use a função tabyl() para tabular os valores da coluna Doença notificada.\nVocê pode ver que os nomes estão escritos de forma adequada e consistente, permitindo visualizar a distribuição de linhas por doença sem necessidade de limpeza adicional.\n\ntabyl(dados_notif_bruto, `Doenca notificada`)\n\n Doenca notificada   n    percent\n            colera  46 0.04660588\n            dengue 273 0.27659574\n     febre amarela 100 0.10131712\n     febre tifoide  35 0.03546099\n           malaria 533 0.54002026\n\n\nUma forma diferente de verificar dados ausentes é tabular o resultado da função is.na(). No exemplo abaixo, a função is.na() avalia cada célula da coluna Data de início dos sintomas, retornando TRUE para as ausentes e FALSE para as presentes.\nExecutar tabyl() sobre essa saída TRUE/FALSE fornece rapidamente a contagem e o percentual de valores ausentes e não ausentes nessa coluna. Lembre-se: valores como um espaço ou as palavras “Desconhecido” ou “Ausente” não serão reconhecidos pelo R como ausentes. O R reconhece apenas espaços verdadeiramente em branco como ausentes, representados por NA.\nPara a coluna Data de início dos sintomas, você pode ver que 70% dos casos estão sem essa informação, sugerindo que essa coluna não seria particularmente útil para analisar tendências de doenças ao longo do tempo.\n\ntabyl(is.na(dados_notif_bruto$`Data de inicio dos sintomas`))\n\n is.na(dados_notif_bruto$`Data de inicio dos sintomas`)   n   percent\n                                                  FALSE 296 0.2998987\n                                                   TRUE 691 0.7001013\n\n\nDados ausentes ou não padronizados podem ocorrer por diversos motivos, incluindo o design da ferramenta de coleta de dados (por exemplo, se as perguntas são obrigatórias ou permitem texto livre versus listas suspensas), os processos e padrões estabelecidos (como quais campos a equipe é instruída a priorizar) e fatores contextuais (como se a equipe dispõe de tempo suficiente para coletar a informação) — entre muitos outros.\n\n\n\n\n\n\n\n\n\nDa mesma forma como acontece com os dados de notificação, utilize as funções skim(), ncol(), e nrow() ou verifique o objeto no ambiente para inspecionar os dados laboratoriais.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual data frame tem mais colunas - os dados de notificação ou os dados laboratoriais?\n\n Dados laboratoriais Dados de notificação Eles têm o mesmo número de colunas\n\nQual data frame tem mais linhas?\n\n Dados laboratoriais Dados de notificação Eles têm o mesmo número de linhas\n\nInspecione os dados laboratoriais com View(). Por que pode haver mais registros nos dados laboratoriais?\n\n Pode haver vários testes ou alvos por amostra Existem muitos resultados de testes de ensaio nos dados Nem todas as notificações têm resultados de testes ainda\n\nQual destas colunas NÃO está nos dados laboratoriais?\n\n ID notificação ID da amostra Tipo de teste Data de nascimento Resultado do teste\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nAssim como na seção 3.1, você pode usar a função skim() do pacote {skimr} para visualizar todos os dado laboratoriais com os resultados dos testes. Isso também mostrará os diferentes nomes de colunas nos dados, evidenciando que os dados laboratoriais contém apenas informações sobre o teste e não sobre o paciente. No entanto, ele também contém um ID notificação, assim como os dados das notificações.\n\nskim(dados_lab_bruto)\n\nUtilizar ncol() e nrow() para exibir o número de colunas e linhas, assim:\n\nncol(dados_lab_bruto)\nnrow(dados_lab_bruto)\n\nIsto exibirá os números de colunas e linhas no painel console, mostrando que os dados do laboratório têm mais linhas do que os dados da notificação inspecionados anteriormente.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nFrequentemente há mais registros nos dados laboratoriais do que nos dados de notificação. Se você inspecionar os dados com View(dados_lab_bruto) e, em seguida, clicar na seta no topo da coluna id_notificacao para ordená-la alfabeticamente, verá que várias linhas compartilham o mesmo id_notificacao.\nIsso pode acontecer quando múltiplos alvos são testados a partir da mesma amostra (mesmo ID de amostra) ou quando um caso é retestado (resultando em um ID de amostra diferente).\n\nView(dados_lab_bruto)\n\n\n\nnome_laboratorioid_notificacaoid_amostradata_exameexamealvoresultadoHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nComo acima, utilize as funções class(), skim(), ou tabyl(), ou inspecione o objeto direto no ambiente RStudio, para analisar as suas colunas com mais detalhes.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas dos dados laboratoriais são reconhecidas pelo R como colunas de data?\n\n 0 1 2\n\nQuantas colunas nos dados laboratoriais possuem dados completos?\n\n 1 3 7 (todas elas!)\n\nQual teste detecta múltiplos alvos (e, portanto, possui múltiplas linhas por amostra)?\n\n Malária Dengue Febre Amarela Cólera Febre Tifoide\n\nQuantos valores possíveis de resultado de teste existem na coluna resultado?\n\n 5 3 4\n\nQual NÃO é um resultado possível para o teste de cultura de fezes que detecta a bactéria V. cholerae?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nOs dados laboratoriais têm uma coluna de data, reconhecida pelo R como uma classe “IDate”. Esta é uma classe de data utilizada pela função import() do pacote {rio} ao importar arquivos csv. Da mesma forma como a classe Data do R base, ela permite ordenar pela data e analisar tendências ao longo do tempo.\n\nclass(dados_lab_bruto$data_exame)\n\n[1] \"IDate\" \"Date\" \n\n\nO uso da função miss_var_summary() do pacote {naniar} demonstra que todas as colunas dos dados laboratoriais estão efetivamente completas. Isto talvez se deva ao fato de os sistemas laboratoriais utilizarem processos automatizados, por isso é muito menos provável que haja erro humano.\n(Ponto importante: Nota-se que, na vida real, os dados laboratoriais provavelmente teriam alguns problemas!)\n\nmiss_var_summary(dados_lab_bruto)\n\n# A tibble: 7 × 3\n  variable         n_miss pct_miss\n  &lt;chr&gt;             &lt;int&gt;    &lt;num&gt;\n1 nome_laboratorio      0        0\n2 id_notificacao        0        0\n3 id_amostra            0        0\n4 data_exame            0        0\n5 exame                 0        0\n6 alvo                  0        0\n7 resultado             0        0\n\n\nPara ver quantos alvos são detectados por cada tipo de exame, faça uma tabulação cruzada das colunas exame e alvo com tabyl(). Escreva os nomes das colunas na função como dois argumentos separados. O resultado mostra que cada exame está claramente alinhado com um ou mais alvos, e apenas o teste da dengue detecta mais do que um alvo (IgG, IgM e NS.1).\nDica: Experimente alterar a ordem dos nomes das colunas na função para ver o impacto na tabela.\n\ntabyl(dados_lab_bruto, alvo, exame)\n\n                 alvo Cultura de fezes Dengue NS1/IgG/IgM Hemocultura IgM ELISA\n    Bacteria S. Typhi                0                  0          33         0\n Bacteria V. cholerae               45                  0           0         0\n           Dengue IgG                0                215           0         0\n           Dengue IgM                0                215           0         0\n          Dengue NS.1                0                215           0         0\n    Febre Amarela IgM                0                  0           0        88\n           Plasmodium                0                  0           0         0\n Microscopia de sangue total\n                           0\n                           0\n                           0\n                           0\n                           0\n                           0\n                         503\n\n\nFinalmente, inspecione os diferentes valores dos resultados do teste na coluna resultado usando tabyl(). Pode ver que existem seis resultados possíveis, incluindo N para negativo, P para positivo e I para indeterminado. A cólera, especificamente, não apresenta P, mas pode apresentar P01 e P0139, o que, neste caso, significa ser positivo para os serogrupos O1 ou O139.\n\ntabyl(dados_lab_bruto, exame, resultado)\n\n                       exame  I   N   P PO1 PO139\n            Cultura de fezes  5   2   0  22    16\n          Dengue NS1/IgG/IgM  0 354 291   0     0\n                 Hemocultura  2  24   7   0     0\n                   IgM ELISA 10  45  33   0     0\n Microscopia de sangue total 56 257 190   0     0\n\n\n\n\n\n\n\n\n\n\nAgora já sabemos que os dados de notificação (dados_notif_bruto) contêm informações sobre casos suspeitos, além de variáveis demográficas básicas (idade, sexo, gravidez, distrito de residência), bem como dados sobre a data de início dos sintomas, a dados de notificação pela unidade de saúde e o desfecho. Algumas dessas colunas precisam ser limpas antes da análise, seja por variações na ortografia de valores categóricos, seja porque algumas datas não foram corretamente reconhecidas como tal.\nA partir deste ponto, você começará a escrever trechos mais longos de código para realizar a limpeza, utilizando várias funções do {dplyr} encadeadas com pipes (que se parecem com isso: |&gt;).\nNOTA SOBRE PIPES Os pipes permitem realizar várias operações em sequência, “encadeando” diferentes funções. O resultado de uma função passa a ser a entrada como primeiro argumento da seguinte.\nCaso queira mais detalhes sobre o uso de pipes, veja a seção do Manual de R para Epidemiologistas.\nNeste exercício será utilizado o pipe nativo do R (|&gt;), que é mais rápido e não exige instalação de pacotes adicionais. Se preferir, você também pode usar o pipe do pacote magrittr (%&gt;%).\n\n\n\n\nDevido a questões de qualidade e armazenamento de dados, a sua equipe recomenda que seja criado um data frame limpo, contendo apenas as seguintes variáveis: identificador único, localização do caso, doença e a data em que a notificação foi registrada no sistema de vigilância.\nEscreva um código em R para produzir um novo data frame limpo chamado dados_notif, aplicando as seguintes tarefas de limpeza:\n\nRenomear as colunas para serem mais legíveis pela máquina (remover espaços e capitalização) usando a função clean_names() do pacote {janitor}.\n\nUsar a função rename() do pacote {dplyr} para que a coluna com a data em que o caso foi notificado seja alterada para o nome mais conciso data_notificacao.\nSelecionar colunas relevantes para análise com a função select() do pacote {dplyr}.\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nComece seu código com o nome do novo data frame, a seta do operador de atribuição e o nome do objeto de dados brutos. Isso indica que o resultado do processamento dos dados brutos será atribuído a um novo objeto chamado dados_notif. .\n\ndados_notif &lt;- dados_notif_bruto\n\nEm seguida, desenvolva este código adicionando funções adicionais, encadeadas com um pipe. Isto permite executar várias operações em uma sequência contínua. Primeiro, utilize clean_names() para padronizar todos os nomes das suas colunas. Essa função substitui automaticamente espaços e caracteres especiais por sublinhados e converte tudo para minúsculas, tornando os nomes mais fáceis de trabalhar. Depois, você pode usar rename() para atribuir um novo nome a uma coluna. Lembre-se de que, ao utilizar rename(), a coluna já possui a versão de seu nome gerada pelo clean_names().\n\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(NOVO_NOME = ANTIGO_NOME) |&gt; \n  select(VAR_NOMES)\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código para limpar os nomes das colunas e selecionar as colunas certas para análise:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao)\n\n\n\n\n\n\n\nA partir da inspeção dos dados, já se sabe que os valores para distritonão estão padronizados.\nAdicione um mutate() para limpar a coluna distrito_de_residencia da seguinte maneira:\n\nNormalizar a capitalização dos valores dessa coluna\nSubstituir a coluna existente distrito_de_residencia existente por uma coluna limpa que contenha apenas estes valores de distrito: “Lago Minara”, “Feveria Central” e “Kasara”.\n\nVeja a dica para saber quais funções utilizar.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nTente usar str_to_title() do pacote {stringr} para que a primeira letra de cada palavra seja maiúscula e todas as outras letras sejam minúsculas. Também pode utilizar case_match() para corrigir erros tipográficos específicos.\nUse a funcionalidade de ajuda do RStudio para aprender a utilizar essas funções. Por exemplo, digite ?case_match no console para abrir a página de ajuda e a documentação da função. Nota: case_match() é uma função muito útil para substituir ou corrigir valores, e pode substituir recode().\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nO seu código de limpeza deve agora ter o seguinte aspecto:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = str_to_title(distrito_de_residencia)) |&gt; \n  mutate(distrito_de_residencia = case_match(distrito_de_residencia,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\nTambém pode envolver o str_to_title na função case_match() para um código mais curto, como se segue:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\n\n\n\n\n\n\nA coluna data_notificacao precisa ser transformada para que seja reconhecida como uma data no R. Isso permitirá analisar tendências ao longo do tempo, incluindo semanas e meses.\nReveja os valores da coluna data_notificacao. Em seguida, adicione uma linha ao seu código de limpeza para converter data_notificacao em uma classe de data.\nConhecer a estrutura dos dados permitirá utilizar a função correta para a conversão.\nRecomendamos o uso de funções do pacote {lubridate}, como ymd() (para datas no formato ano-mês-dia), mdy() (para datas no formato mês-dia-ano) ou dmy() (para datas no formato dia-mês-ano). Essas funções reconhecerão qualquer forma de escrever a data, desde que a ordem esteja correta; por exemplo, “21 de agosto de 2025” e “21-08-2024” seriam reconhecidas por dmy().\n\n\n\n\n\n\nPerguntas\n\n\n\n\nComo as datas estão atualmente formatadas?\n\n dia-mês-ano ano-mês-dia mês-dia-ano ano-dia-mês\n\nQual função mutate() deve ser usada para converter a coluna data_notificacao para a classe de data?\n\n mutate(data_notificacao = ymd(data_notificacao)) mutate(data_notificacao = dmy(data_notificacao)) mutate(data_notificacao = mdy(data_notificacao))\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize a função head() para ver as primeiras seis linhas dos dados da coluna data_notificacao. É possível ver que elas são escritas no formato: ano primeiro, depois o mês e depois o dia.\n\nhead(dados_notif$data_notificacao)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nÉ possível utilizar a função ymd() dentro de mutate() para converter a coluna data_notificacao para a classe de data. Você pode verificar se a conversão foi correta executando class() em seguida.\nO seu código de limpeza deve agora ter o seguinte aspecto:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))|&gt; \n  mutate(data_notificacao = ymd(data_notificacao)) \n\nE pode verificar novamente a classe assim:\n\nclass(dados_notif$data_notificacao)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nOs seus colegas dizem-lhe que cada id_notificacao representa um caso suspeito. Agora você pretende criar uma tabela para verificar se id_notificacao está duplicado nas linhas dos seus dados.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nUma linha nos dados de notificação equivale a um caso?\n\n Sim Não\n\nÉ necessário deduplicar seus dados para análise epidemiológica dos casos?\n\n Sim Não\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nHá várias formas de fazer isso, mas tente utilizar a função count() do pacote {dplyr}. Ela cria uma tabela que conta o número de linhas para cada valor único da coluna que você especificar. Em seguida, utilize tabyl() para visualizar a distribuição dessas contagens.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nPrimeiro, passe os dados de notificação para a função count(), usando id_notificacao como único argumento. Isso cria uma contagem do número de linhas para cada valor único de id_notificacao, apresentada em uma nova coluna chamada n. Por exemplo, neste excerto é possível ver que existe apenas uma linha para cada um desses 6 id_notificacao.\n\ndados_notif |&gt; \n  count(id_notificacao) \n\n\n\n  id_notificacao n\n1         00399b 1\n2         005c85 1\n3         006f52 1\n4         00cbbb 1\n5         01830d 1\n6         019045 1\n\n\nEm seguida, tabule a nova coluna n com a função tabyl(), que mostrará que existe apenas uma linha por id_notificacao único. Isso significa que cada linha equivale a um caso e não é necessária nenhuma deduplicação adicional.\n\ndados_notif |&gt; \n  count(id_notificacao) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nVocê pode agora proceder confortavelmente às análises descritivas dos casos, pois os dados estão limpos e cada linha equivale a um caso. Use a função tabyl() para realizar as tarefas seguintes.\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual doença foi mais frequentemente diagnosticada pelas clínicas em Feveria em 2024?\n\n Cólera Malária Dengue Febre Tifoide Febre Amarela\n\nQual doença foi menos frequentemente diagnosticada pelas clínicas em Feveria em 2024?\n\n Cólera Malária Dengue Febre Tifoide Febre Amarela\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUsando a função tabyl() podemos ver que houve 533 casos suspeitos de malária em Feveria em 2024, e apenas 35 casos suspeitos de febre tifoide.\n\ntabyl(dados_notif, doenca_notificada)\n\n doenca_notificada   n    percent\n            colera  46 0.04660588\n            dengue 273 0.27659574\n     febre amarela 100 0.10131712\n     febre tifoide  35 0.03546099\n           malaria 533 0.54002026\n\n\n\n\n\n\n\n\nUtilize tabyl() para fazer uma tabulação cruzada das colunas da doença notificada e do distrito de residência.\nDesenvolva a tabulação adicionando várias funções adorn() do pacote {janitor} para visualizar as distribuições percentuais, como por exemplo adorn_percentages(), adorn_pct_formatting() e adorn_ns().\nDigite o nome da função precedido de ? no console (por exemplo, ?adorn_ns) para acessar as páginas de ajuda relevantes. Você também pode consultar a seção sobre {janitor} no Manual de R para Epidemiologistas para mais explicações sobre as funções adorn_xxx().\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual distrito reportou o maior número de doenças transmitidas por vetores em 2024 (malária, dengue, febre amarela)?\n\n Lago Minara Feveria Central Kasara\n\nQual distrito reportou o maior número de doenças diarreicas em 2024 (cólera, febre tifoide)?\n\n Lago Minara Feveria Central Kasara\n\nQuais fatores contribuem para o aumento de doenças diarreicas neste distrito específico (selecionado na pergunta anterior)?\n\n Infraestrutura de água e saneamento pouco confiável Superlotação de mosquitos Não sabemos\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nAqui está um código para ajudá-lo a começar. Ele cria tabelas cruzadas entre doenca_notificada e distrito_de_residencia usando tabyl() e, em seguida, aplica adorn_percentages() para converter os números em percentagens com muitas casas decimais. Depois, é necessário passar para adorn_pct_formatting() para formatar as percentagens corretamente, e então usar adorn_ns() para adicionar os números originais entre parênteses.\nNote que as funções adorn_xxx() devem ser aplicadas em uma ordem específica!\n\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages()\n\nPara entender os fatores que contribuem para o aumento de casos de diarreia, volte ao início do estudo de caso, quando os distritos foram apresentados pela primeira vez.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUsando a função tabyl() podemos ver que a maioria dos casos suspeitos de dengue, malária e febre amarela ocorreu no Lago Minara, a área do lago com maior densidade de mosquitos e, portanto, maior transmissão de doenças por vetores. Por outro lado, cólera e febre tifoide foram predominantemente registradas em Feveria Central, uma zona urbana superlotada com problemas de infraestrutura de água e saneamento, que aumentam o risco de inundações e contaminação da água potável durante o período chuvoso.\n\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n doenca_notificada Feveria Central      Kasara Lago Minara\n            colera      91.3% (42)  8.7%   (4)  0.0%   (0)\n            dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n     febre amarela      11.0% (11) 21.0%  (21) 68.0%  (68)\n     febre tifoide      68.6% (24) 31.4%  (11)  0.0%   (0)\n           malaria      13.7% (73) 19.9% (106) 66.4% (354)\n\n\n\n\n\n\n\n\n\n\nCom base no seu trabalho anterior, na Etapa 3, você verificou que os dados laboratoriais contêm apenas informações sobre os testes e nenhuma informação sobre o paciente. Os dados já estão bastante limpos, então só precisamos padronizar uma coluna. Também queremos processar o data frame do laboratório para que haja uma linha por notificação, permitindo que ele seja corretamente vinculado ao data frame de notificações.\n\n\n\n\nCriar um novo objeto dados_lab. Isto permitirá uma abordagem e análise mais direta bem como facilitará a interpretação dos resultados.\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize case_match() para transformar os diferentes valores originais em “Positivo”, “Negativo” ou “Indeterminado”:\n\ndados_lab &lt;- dados_lab_bruto |&gt; \n  mutate(resultado = case_match(resultado, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\nVocê pode então verificar novamente se os novos valores estão corretos, tabulando e comparando os valores no data frame original e no data frame limpo. Certifique-se de que utilizou a letra ‘O’ e não o número ‘0’!\n\ntabyl(dados_lab_bruto, resultado)\n\n resultado   n    percent\n         I  73 0.05555556\n         N 682 0.51902588\n         P 521 0.39649924\n       PO1  22 0.01674277\n     PO139  16 0.01217656\n\n\n\ntabyl(dados_lab, resultado)\n\n     resultado   n    percent\n Indeterminado  73 0.05555556\n      Negativo 682 0.51902588\n      Positivo 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nJá sabemos que algumas amostras possuem várias linhas, porque o teste de dengue possui três alvos, gerando uma linha por resultado de alvo.\nAgora, identifique o número de amostras com várias linhas.\nFaça isso da mesma forma que fez com os dados de notificação: use dados_lab para primeiro contar o número de linhas por amostra e, em seguida, crie uma tabela para mostrar a distribuição desses números de linhas. Lembre-se de que cada amostra é identificada por um id_amostra.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas amostras (valores únicos de id_amostra) estão sendo repetidos em três linhas?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nPrimeiro, passe os dados laboratoriais para a função count(), usando id_amostra como único argumento.\nIsso cria uma tabela que conta o número de linhas por valor único de id_amostra, apresentado em uma nova coluna n.\nPor exemplo, pode-se ver que o id_amostra “000e8eee” possui três linhas, enquanto o id_amostra “001e1878” aparece em apenas uma linha.\n\ndados_lab |&gt; \n  count(id_amostra) \n\n\n\n  id_amostra n\n1   000e8eee 3\n2   001e1878 1\n3   005f39af 1\n4   00b30781 3\n5   00b56d18 1\n6   0110abcd 3\n\n\nEm seguida, tabule a nova coluna n com o tabyl().\n\ndados_lab |&gt; \n  count(id_amostra) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nPode até verificar se isto se aplica apenas ao exame de dengue adicionando a exame ao cálculo. Pode ver que é apenas o teste da dengue que tem 3 linhas por amostra.\n\ndados_lab |&gt; \n  count(exame, id_amostra) |&gt; \n  tabyl(exame, n)\n\n                       exame   1   3\n            Cultura de fezes  45   0\n          Dengue NS1/IgG/IgM   0 215\n                 Hemocultura  33   0\n                   IgM ELISA  88   0\n Microscopia de sangue total 503   0\n\n\n\n\n\n\n\n\nComo você viu na Seção 3.2, o teste de dengue fornece resultados para três alvos diferentes: IgG, IgM e NS1. Os resultados para cada um desses alvos podem ser negativos ou positivos. No entanto, para simplificar e consolidar os dados, deseja-se atribuir um único valor, negativo ou positivo, para cada amostra, indicando se a amostra representa uma infecção ativa.\n\n\nalvoNegativoPositivoDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nO seu colega Ben, que trabalha no laboratório, aconselha sobre a limpeza da seguinte forma:\n\nUma amostra pode ser considerada positiva se NS1 ou IgM forem positivos (já que ambos podem indicar uma infecção aguda).\n\nO IgG pode ser ignorado (porque um resultado positivo, na ausência de NS1 ou IgM positivos, indica imunidade de uma infecção passada resolvida).\n\nAgora, você precisa consolidar os resultados dos testes de dengue em uma linha por teste, com um valor de resultado. Utilize filter(), arrange() e slice(), garantindo que qualquer amostra positiva para NS1 ou IgM seja considerada positiva para dengue.\nCrie um novo objeto chamado dados_lab_testes.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nTente aplicar o seguinte para consolidar os resultados de acordo com a recomendação do Ben:\n\nRemover resultados de IgG: filtre as linhas em que o alvo é \"IgG\" usando filter() do {dplyr}.\n\nPriorizar resultados positivos de IgM/NS1: agrupe por id_amostra e organize as linhas com arrange() para que qualquer resultado \"P\" (positivo) apareça primeiro.\n\nFiltrar para o status final: mantenha apenas a primeira linha usando slice(1) para obter o resultado positivo ou negativo da amostra.\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nAqui está o código para filtrar os resultados de IgG da dengue e, em seguida, consolidar o resultado do teste dentro de cada grupo de linhas com o mesmo id_amostra, dando prioridade aos resultados positivos.\nÉ necessário especificar desc dentro de arrange(), pois isso faz com que os resultados sejam ordenados em ordem alfabética inversa, colocando \"P\" no topo.\nAlém disso, adicione ungroup() no final para que os novos dados não permaneçam agrupados, o que poderia interferir em análises posteriores.\n\ndados_lab_testes &lt;- dados_lab |&gt; \n  filter(alvo != \"Dengue IgG\") |&gt; \n  group_by(id_amostra) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nEm seguida, é possível verificar novamente se o novo objeto dados_lab_testes contém apenas uma linha por teste, utilizando a combinação de count() e tabyl() como feito na Tarefa A.\nEsta tabela mostra que todos os IDs de amostra únicos estão presentes em apenas uma linha cada:\n\ndados_lab_testes |&gt; \n  count(id_amostra) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nEm seguida, verifique o número de testes por ID de notificação nos novos dados consolidados.\nPode-se observar que existem 26 linhas com o mesmo id_notificacao que outra linha, mas apenas entre os casos testados com microscopia de sangue total para malária.\n\ndados_lab_testes |&gt; \n  count(exame, id_notificacao) |&gt; \n  tabyl(exame, n)\n\n                       exame   1  2\n            Cultura de fezes  45  0\n          Dengue NS1/IgG/IgM 215  0\n                 Hemocultura  33  0\n                   IgM ELISA  88  0\n Microscopia de sangue total 451 26\n\n\nInvestiga-se mais detalhadamente analisando um caso de exemplo com id_notificacao “043228”.\nIsso mostra que este caso foi testado duas vezes, com duas amostras diferentes, com uma semana de intervalo. O primeiro resultado foi positivo e o segundo resultado foi negativo.\n\ndados_lab_testes |&gt; \n  filter(id_notificacao == \"043228\")\n\n# A tibble: 2 × 7\n  nome_laboratorio    id_notificacao id_amostra data_exame exame alvo  resultado\n  &lt;chr&gt;               &lt;chr&gt;          &lt;chr&gt;      &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    \n1 Hospital Universit… 043228         27c37cd8   2024-06-18 Micr… Plas… Positivo \n2 Hospital Universit… 043228         d2271be0   2024-06-25 Micr… Plas… Negativo \n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual afirmação sobre os dados laboratoriais está correta?\n\n Todos os casos de diferentes doenças são retestados Alguns casos de malária são retestados Todos os casos de malária são retestados\n\nSerá necessário deduplicar os dados laboratoriais para ligar com os dados de notificação?\n\n Sim - precisamos de uma linha representando o resultado do laboratório por notificação Não - os dados já estão suficientemente deduplicados\n\n\n\n\nSe respondeu que precisa deduplicar, está correto!\nDeduplicar os dados para ter uma linha por ID de notificação priorizando os resultados positivos, para que seja possível fazer a vinculação com os dados da notificação.\nPara fazer isso, siga um processo semelhante ao da tarefa B, utilizando a estrutura de dados produzida pela tarefa B:\n\nAgrupar por id_notificacao\nOrdenar pelo valor do resultado do exame, de modo a que os valores que começam por P tenham prioridade na linha superior, seguidos por N (negativo) e depois I (indeterminado).\nEm seguida, mantenha a primeira linha dentro de cada grupo de id_notificacaos, utilizando slice().\nAo fazer isto, crie um novo objeto chamado dados_lab_casos.\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código para deduplicar as linhas dentro de cada grupo de linhas com o mesmo id_notificacao dando prioridade aos resultados positivos. Mais uma vez, você precisa especificar desc dentro de arrange(). Isto funciona perfeitamente porque a ordem de prioridade desejada para os resultados — positivos, depois negativos, depois indeterminados — alinha-se com a ordem alfabética inversa (P vem antes de N, que vem antes de I, quando ordenado de forma descendente).\nSe a sua ordem de prioridades fosse mais complexa ou não correspondesse à ordem alfabética (por exemplo, se “indeterminado” precisasse de vir antes de “negativo”), teria de converter a coluna de resultados num fator e explicitamente definir a ordem desejada dos seus níveis. Não se esqueça de desagrupar novamente no final.\n\ndados_lab_casos &lt;- dados_lab_testes |&gt; \n  group_by(id_notificacao) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nVocê pode então verificar novamente se o novo objeto dados_lab_casos tem apenas uma linha por exame, usando a combinação de count() e tabyl() como fez na Tarefa A. Esta tabela lhe mostra que todos os IDs de amostra únicos estão presentes em apenas uma linha cada:\n\ndados_lab_casos |&gt; \n  count(id_notificacao) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nAgora temos dois objetos que podemos utilizar para a análise de dados laboratoriais: dados_lab_testes e dados_lab_casos.\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue objeto você deve utilizar para analisar os exames?\n\n dados_lab_testes dados_lab_casos nenhum destes\n\nQuantos exames foram conduzidos para examinar para malária (através da microscopia de sangue total)?\n\n 215 503 88 190\n\nQue porcentagem dos exames para cólera (através da cultura de fezes) foi positiva?\n\n 21% 11% 84% 87%\n\nQuais exames tiveram a maior porcentagem de resultados indeterminados?\n\n IgM ELISA (para detecção de febre amarela) Cultura de fezes (para detecção de cólera) Hemocultura (para detecção de febre tifóide)\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilizando tabyl() podemos ver o número de resultados positivos, negativos e indeterminados por exame. Você pode adicionar uma série de funções adorn() para mostrar porcentagens e totais.\n\ntabyl(dados_lab_testes, exame, resultado) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                       exame Indeterminado    Negativo    Positivo        Total\n            Cultura de fezes    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n          Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n                 Hemocultura     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                   IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopia de sangue total    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue data frame de dados laboratoriais você deve usar para contar o número de casos supeitos examinados?\n\n dados_lab_bruto dados_lab_casos dados_lab_testes dados_lab\n\nQuantos casos suspeitos foram examinados nos dados laboratoriais de 2024?\n\n 858 1314 884\n\nExistem mais casos suspeitos nos dados de notificação ou nos dados laboratoriais?\n\n dados de notificação Dados laboratoriais\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nVocê pode simplesmente analisar o número de linhas no data frame dados_lab_casos para ver o número de casos suspeitos que foram examinados.\n\nnrow(dados_lab_casos)\n\n[1] 858\n\n\nEste número é inferior ao número de casos suspeitos que estavam nos dados limpos de vigilância de doenças de notificação compulsória (dados_notif) - o que sugere que nem todos os casos suspeitos em 2024 foram examinados quando estes dados estavam disponíveis.\n\nnrow(dados_notif)\n\n[1] 987\n\n\n\n\n\n\n\n\n\n\nAgora que ambas as listas de casos estão limpas e têm uma linha por caso suspeito, você pode vinculá-las para permitir a análise completa solicitada pelo seu chefe.\n\n\n\n\nCriar um novo objeto chamado dados_vinculados, utilizando uma função xxx_join() do {dplyr}. Pretende-se manter todas as notificações, mas adicionar resultados de exames, quando disponíveis, para cada caso suspeito.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue função traz a abordagem correta se você quiser manter todas as linhas dos seus dados de notificação e trazer os resultados dos dados laboratoriais?\n\n left_join(dados_notif, dados_lab_casos… full_join(dados_notif, dados_lab_casos… right_join(dados_notif, dados_lab_casos…\n\nQue identificador deve ser utilizado para vincular as duas listas de casos?\n\n id_amostra id_notificacao id_amostra e data de notificação id_notificacao e data de notificação\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nLigue os dados utilizando o left_join() com os dados de notificação como data frame principal à esquerda. Isto manterá todas as linhas deste data frame e apenas introduzirá os resultados dos exames nos dados laboratoriais especificados à “direita” da função.\n\ndados_vinculados &lt;- left_join(dados_notif, dados_lab_casos, \n                         by = \"id_notificacao\")\n\nVocê está ligando através da coluna id_notificacao, que está presente, completa e limpa em ambas as listas de casos.\nNota: Você tem sorte de trabalhar com um exemplo de ligação tão simples! Normalmente, seria necessário limpar e verificar a coluna de ID, ou vincular a outras colunas como o nome e a data de nascimento. Em Feveria, os clínicos são fantásticos em atribuir consistentemente IDs de notificação a cada doente, incluindo nos formulários de amostra enviados para o laboratório, e ainda o pessoal do laboratório é igualmente brilhante em registrar o ID de notificação nos seus sistemas de laboratório, para que os resultados possam ser associados ao caso.\n\n\n\n\n\n\nAgora, verifique os seus dados e revise algumas coisas.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas linhas tem o seu novo data frame dados_vinculados?\n\n 987 884 858\n\nComo este resultado se compara aos seus dados de notificação originais?\n\n mais linhas que o original o mesmo número de linhas menos linhas\n\nQue termo melhor descreve a vinculação que você acabou de realizar?\n\n muitos-para-um um-para-um muitos-para-muitos\n\nQuantos resultados de laboratório NÃO foram vinculados? (dica: use anti-join())?\n\n 30 19 0\n\nQuão sortudo você foi por sua vinculação de dados ter sido tão bem-sucedida?\n\n O quê? Nem toda vinculação de dados é simples assim?? Bastante! Normalmente alguns registros não têm correspondência.\n\nQuais são razões típicas para os dados laboratoriais não possuírem correspondência entre os dados de notificação?\n\n Existem erros de digitação nas colunas utilizadas para a vinculação, e por isso elas não são reconhecidas como correspondências Os dados laboratoriais podem conter casos adicionais de outras clínicas ou países Os dados laboratoriais podem incluir amostras de exames Notificações podem ter sido acidentalmente perdidas nos dados de notificação apesar da amostra ter sido examinada em laboratório Todas as opções acima\n\nQuantos casos supeitos não possuem um resultado?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVerifique o número de linhas em cada quadro de dados com o comando nrow() ou olhando as informações do objeto no seu ambiente. É possível ver que esta foi simplesmente uma vinculação de um para um, porque cada linha tinha um único id_notificacao, então uma linha nos dados de notificação se vinculou exatamente a uma linha dos dados laboratoriais.\nNúmero de linhas nos dados de notificação\n\nnrow(dados_notif)\n\n[1] 987\n\n\nNúmero de linhas nos dados vinculados\n\nnrow(dados_vinculados)\n\n[1] 987\n\n\nPara verificar se houve algum resultado de laboratório que não estava ligado aos dados de notificação, é possível usar anti_join(). Desta vez, o objeto dados_lab_casos está à esquerda, pois a função avalia quantas linhas do data frame da esquerda não foram encontradas no data frame da direita, ao realizar a correspondência por id_notificacao. Aqui não é necessário gerar um novo data frame, você pode simplesmente passar, através de um pipe, o resultado para nrow() para contar o número de linhas. A saída é 0, o que mostra que não houve resultados sem vínculo - incrível!\n\nanti_join(dados_lab_casos, dados_notif, \n          by = \"id_notificacao\") |&gt; nrow()\n\n[1] 0\n\n\nFinalmente, para verificar o número de notificações sem um resultado, você pode efetuar um anti_join ao colocar dados_notif primeiro:\n\nanti_join(dados_notif, dados_lab_casos, \n          by = \"id_notificacao\") |&gt; nrow()\n\n[1] 129\n\n\nOu, pode simplesmente tabular o número de valores em falta na coluna resultado em dados_vinculados (já que a coluna resultado provém dos dados laboratoriais).\n\ntabyl(is.na(dados_vinculados$resultado)) \n\n is.na(dados_vinculados$resultado)   n   percent\n                             FALSE 858 0.8693009\n                              TRUE 129 0.1306991\n\n\nAmbas as abordagens mostram que 129 casos suspeitos não têm um resultado de exame laboratorial.\n\n\n\n\n\n\n\n\n\nUtilize mutate() para criar uma nova coluna categoria_caso atualizando o rótulo dos casos suspeitos de acordo com o seu resultado laboratorial. As categorias devem ser as seguintes:\n\nSe o resultado for positivo: Confirmado\nSe o resultado for negativo: Descartado\nSe o resultado for indeterminado ou inexistente: Suspeito\n\nIsto significa que todos os casos nos dados de notificação são inicialmente suspeitos quando notificados, e permanecem suspeitos se não houver um resultado conclusivo no exame.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual é a função mais apropriada para criar essa nova coluna?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVocê deve utilizar o case_when() para criar a nova coluna. Esta função é ideal para aplicar múltiplas condições lógicas para criar múltiplos valores, enquanto que case_match() é melhor para substituir valores específicos, e if_else() é melhor se houver apenas dois valores possíveis.\n\ndados_vinculados &lt;- dados_vinculados |&gt; \n  mutate(categoria_caso = case_when(resultado==\"Positivo\" ~ \"Confirmado\",\n                                   resultado==\"Negativo\" ~ \"Descartado\",\n                                   resultado==\"Indeterminado\" | is.na(resultado) ~ \"Suspeito\"))\n\n\n\n\n\n\n\n\n\n\nUtilizar tabyl() em geral, e também a tabulação cruzada por doença para responder às perguntas abaixo.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantos casos nos dados de notificação vinculados não possuem um resultado positivo ou negativo?\n\n 202 347 250\n\nQue porcentagem dos casos nos dados de notificação POSSUEM um resultado positivo ou negativo?\n\n 60.1% 79.5% 92.2%\n\nPor que existem mais casos suspeitos remanescentes do que notificações sem vinculação?\n\n Casos suspeitos incluem notificações sem um resulado laboratorial e com um resultado indeterminado Existem casos suspeitos adicionais sendo trazidos dos laboratórios Existe algum problema com os dados\n\nQuais doenças possuíram a maior porcentagem de casos que permaneceram suspeitos após a vinculação?\n\n Cólera Malária Dengue Febre amarela\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nMais uma vez, você pode utilizar tabyl() para ver a distribuição das categorias de casos pelas notificações. O número total de casos suspeitos, ou seja, os que não têm qualquer resultado laboratorial ou têm um resultado indeterminado, é de 202. Isto significa que 785 casos, ou seja, 79,5%, tiveram um resultado laboratorial definitivo.\n\ntabyl(dados_vinculados, categoria_caso) \n\n categoria_caso   n   percent\n     Confirmado 438 0.4437690\n     Descartado 347 0.3515704\n       Suspeito 202 0.2046606\n\n\nPode também fazer uma tabela cruzada dos resultados originais (indeterminado/negativo/positivo) na coluna resultado com os novos resultados categoria_caso, primeiro para verificar se a sua lógica funcionou, e para ver como os valores originais se relacionam com os valores da nova coluna. Isto mostra que, além das 129 notificações que não foram vinculadas (com NA na coluna resultado), 73 tiveram resultados indeterminados, e assim foram classificadas como casos suspeitos.\n\ntabyl(dados_vinculados, categoria_caso, resultado) \n\n categoria_caso Indeterminado Negativo Positivo NA_\n     Confirmado             0        0      438   0\n     Descartado             0      347        0   0\n       Suspeito            73        0        0 129\n\n\nFinalmente, você pode também fazer uma tabela cruzada com o nome da doença para ver as categorias de casos por doença. Adicione adorn_xxx() para formatar as porcentagens. A tabela mostra que 22% dos casos de febre amarela permaneceram suspeitos, e que essa porcentagem foi a mais elevada em comparação com as outras doenças.\n\ntabyl(dados_vinculados, doenca_notificada, categoria_caso) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n doenca_notificada  Confirmado  Descartado    Suspeito        Total\n            colera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n            dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n     febre amarela 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n     febre tifoide 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n           malaria 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n             Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilize tabyl() mais uma vez para esta tarefa, analisando os resultados por doença. Pense no denominador correto!\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue porcentagem de casos suspeitos repotados em em 2024 eram casos verdadeiros, de acordo com os resultados dos exames?\n\n 44% 56% 59%\n\nQue porcentagem dos casos suspeitos de malária eram realmente malária?\n\n 86% 41% 23%\n\nQue porcentagem de casos suspeitos de dengue eram realmente dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nDividir o número de casos confirmados (ou seja, aqueles com um resultado positivo) pelo número de casos confirmados e descartados (ou seja, aqueles com um resultado positivo ou negativo). Obtém-se assim uma taxa de positivos, que se aproxima da porcentagem de casos suspeitos que eram efetivamente casos. Os resultados indeterminados são excluídos porque não fornecem um resultado claro e distorceriam a taxa de positivos.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nFiltre os casos suspeitos e, em seguida, faça uma tabela cruzada para ver a porcentagem de casos originalmente suspeitos que foram confirmados ou descartados, entre aqueles com resultados de exame válidos.\nUma vez que existe uma linha de totais, pode ver-se que 56% dos casos suspeitos em geral foram confirmados, entre os que tinham um resultado válido. Também se pode ver que 41% e 87% dos casos de malária e dengue, respetivamente, foram confirmados.\n\ndados_vinculados |&gt; \n  filter(categoria_caso != \"Suspeito\") |&gt; \n  tabyl(doenca_notificada, categoria_caso) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n doenca_notificada  Confirmado  Descartado        Total\n            colera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n            dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n     febre amarela 42.3%  (33) 57.7%  (45) 100.0%  (78)\n     febre tifoide 22.6%   (7) 77.4%  (24) 100.0%  (31)\n           malaria 41.3% (174) 58.7% (247) 100.0% (421)\n             Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTarefa A: Criar uma nova lista de casos chamada dados_vinculados_confirmados.\nEsta é a que você utilizará nos relatórios oficiais de vigilância.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nPor que estamos optando por relatar apenas casos confirmados em nossos dados de vigilância?\n\n Relatar casos confirmados pode ser mais confiável e preciso quando a porcentagem de resultados positivos é baixa e os exames laboratoriais são rotineiros, ajudando assim a evitar a superestimação da carga da doença Relatar casos confirmados é mais lento, o que nos dá mais tempo para ter certeza do que estamos relatando Porque queremos esconder o número real de casos\n\nQual função é importante para criar a nova lista de linhas (linelist)?\n\n filter() arrange() mutate()\n\nQuantas linhas há neste novo data frame?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nA sua unidade de vigilância quer concentrar-se em notificar os casos confirmados. Isto deve-se ao fato de os exames laboratoriais serem rotina em Feveria, tendo em vista que a notificação de casos suspeitos seria desnecessariamente imprecisa, com uma elevada porcentagem de casos suspeitos sendo descartados.\nA decisão de publicar casos suspeitos pode ser diferente em outros contextos. Por exemplo, se a taxa de positivos for elevada (a maioria dos casos são casos confirmados se examinados) e os exames em si não forem comuns, ou se os exames demorarem muito tempo e resultarem numa notificação tardia, isso sugeriria que as tendências de casos suspeitos são suficientemente precisas e também mais oportunas do que esperar pela confirmação laboratorial.\nCriar a nova lista de casos com a função filter():\ndados_vinculados_confirmados &lt;- dados_vinculados |&gt; \n  filter(categoria_caso==\"Confirmado\")\nE verifique o número de linhas consultando as informações no seu ambiente ou com nrow():\nnrow(dados_vinculados_confirmados)\n[1] 438\n\n\n\n\n\n\n\nAgora que você tem sua lista de casos confirmados de doenças de notificação compulsória registrados em Feveria em 2024, você está pronto para conduzir a parte final da sua análise de vigilância! Especificamente, isso significa resumir as cinco doenças de notificação compulsória por área geográfica e tempo.\nDica: Normalmente, a análise de vigilância incluiria também uma análise por pessoa. Você pode expandir este estudo de caso, analisando também por variáveis demográficas.\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual doença de notificação compulsória foi mais comumente relatada em 2024, quando restringimos apenas os casos confirmados?\n\n Dengue Malária Febre Amarela\n\nPor que a doença mais notificada muda quando olhamos os casos confirmados e suspeitos?\n\n A sensibilidade e especificidade do diagnóstico clínico pode variar por doença O desempenho dos exames utilizados nos laboratórios pode variar por doença Pode existir vieses de notificação Todas as opções acima!\n\nQual distrito relatou o maior número de casos confirmados de cólera em 2024?\n\n Lago Minara Feveria Central Kasara\n\nQuantos casos confirmados de cólera relatados em 2024 foram entre moradores de Feveria Central?\n\n 35 42 4\n\nQual distrito relatou mais casos confirmados de malária em 2024?\n\n Lago Minara Feveria Central Kasara\n\nEstes dados confirmam que a dengue é a doença infecciosa mais comum em Feveria?\n\n Não - uma doença diferente pode estar sendo subnotificada e/ou não ser de notificação compulsória Sim - se é a mais notificada então deve ser a mais comum\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que a dengue foi a doença mais frequentemente notificada em Feveria em 2024 quando consideramos apenas os casos confirmados, com 186 casos.\n\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada) \n\n doenca_notificada   n    percent\n            colera  38 0.08675799\n            dengue 186 0.42465753\n     febre amarela  33 0.07534247\n     febre tifoide   7 0.01598174\n           malaria 174 0.39726027\n\n\nNote que isto é diferente dos casos suspeitos, em que a malária foi a doença mais notificada (com 533 casos suspeitos)! Isto foi sugerido anteriormente, quando se viu que a taxa de positivos para casos suspeitos de dengue era mais elevada do que para casos suspeitos de malária. Isto pode dever-se a diferentes razões, por exemplo, o método de diagnóstico clínico utilizado para a malária pode ser menos específico (então muitos dos casos suspeitos são, na realidade, outras doenças), ou o exame utilizado para a dengue pode ser mais sensível.\nPara fazer uma tabela cruzada com o distrito de residência, adicione as funções adorn_xxx() relevantes.\n\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada, distrito_de_residencia) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n doenca_notificada Feveria Central     Kasara Lago Minara        Total\n            colera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n            dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n     febre amarela       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n     febre tifoide      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n           malaria      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n             Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nTal como acontece com os casos suspeitos, podemos ver que a maioria dos casos confirmados de dengue, malária e febre amarela se localizaram em Lago Minara - a zona do lago com maior densidade de mosquitos e, por conseguinte, de doenças transmitidas por vetores. A maioria dos casos confirmados de cólera e febre tifoide registou-se em Feveria Central, onde existem problemas de água e saneamento.\nOs dados sugerem que as doenças transmitidas por vetores (dengue e malária) constituem uma preocupação especial neste país tropical. No entanto, não sabemos ao certo qual é a doença mais comum e quais são os padrões subjacentes - apenas cinco doenças são de notificação compulsória e, normalmente, os casos notificados representam apenas uma fração dos casos reais na comunidade.\n\n\n\n\n\n\n\nVocê irá trabalhar na construção desta curva epidêmica, ao longo das várias tarefas abaixo.\n\n\n\n\n\n\n\n\n\n\n\nCertifique-se de especificar o argumento binwidth=7 para que cada barra no histograma represente o número de casos dentro de um período de 7 dias.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuando foi notificado o primeiro caso de febre tifoide em Feveria em 2024?\n\n Janeiro de 2024 Maio de 2024 Outubro de 2024\n\nDe acordo com este gráfico, qual foi o maior número de casos de dengue notificados em uma única semana em 2024?\n\n 10 20 30 É muito difícil responder isto a partir do gráfico empilhado!\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está um código simples para construir a curva epidêmica. Note que ainda não está controlando as cores, nem especificando em que dia da semana começa cada período de 7 dias.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = doenca_notificada)), binwidth=7)\n\n\n\n\n\n\n\n\nConsulte o capítulo sobre datas do Manual de R para Epidemiologistas caso queira uma formatação de data mais específica, por exemplo, de modo que cada barra represente uma semana de segunda a domingo, ou o eixo x indique o número da semana (semanas 1 - 52).\nImportante - não é simples visualizar as tendências por doença quando os dados estão empilhados dessa forma! Para ver essas tendências temporais, você deve produzir um histograma para cada doença.\n\n\n\n\n\n\nUtilize facet_wrap() para criar facilmente vários mini-plots, um por doença. Para entender isto melhor, você pode consultar a seção seção de facetas do capítulo sobre ggplot2 no Manual de R para Epidemiologistas\n\n\n\n\n\n\nPerguntas\n\n\n\n\nDe acordo com este gráfico facetado, qual foi o maior número de casos de dengue notificados em uma mesma semana em 2024?\n\n 11 15 29 Ainda não consigo responder!\n\nDentre os casos de dengue notificados naquela semana, em que distrito moravam?\n\n Todos os três distritos Feveria Central Kasara Lago Minara Este gráfico não mostra esta informação\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgora você pode ver uma curva epidêmica por doença! E pode ver que, durante uma semana de julho, foram notificados 15 casos de dengue. No entanto, este gráfico ainda não apresenta qualquer informação geográfica.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao)), binwidth=7) + \n  facet_wrap(.~doenca_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nDentre os 15 casos de dengue notificados na mesma semana de julho de 2024, em que distritos moravam?\n\n Todos os três distritos Feveria Central Kasara Lago Minara\n\nEm qual distrito foi notificado o primeiro caso de febre tifoide de 2024?\n\n Kasara Feveria Central Lago Minara Ainda não consigo responder!\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgora você pode ver uma curva epidêmica por doença, com a coloração refletindo o distrito de residência de onde é o caso\nPode-se ver que entre os 15 casos de dengue notificados na mesma semana, estes residiam em três distritos diferentes. Você também pode ver que o primeiro caso de febre tifoide foi notificado em Feveria Central.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) + \n  facet_wrap(.~doenca_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocê pode especificar:\n\nO tema/aparência geral do gráfico (por exemplo, cor de fundo, aparência das linhas de grade)\nO título e os rótulos\nAs cores das barras (com scale_fill_manual())\nA formatação e o espaçamento das datas ao longo do eixo x (com scale_x_date)\nMuitas outras coisas!\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nA cólera e a febre tifoide aparentam ser endêmicas?\n\n Não - os dados sugerem pequenos surtos ocasionais Sim, ambas são endêmicas\n\nHouve alguma época específica do ano em que a malária atingiu o pico em 2024?\n\n Sim - por volta de novembro/dezembro Sim - por volta de julho/agosto (verão) Não, é consistentemente alta\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código totalmente formatado. Observe que algumas outras alterações incluem especificar que queremos apenas duas colunas de mini gráficos dentro do facet_wrap() e que a etiqueta de data ao longo do eixo x deve apenas mostrar o dia e o mês (não o ano, uma vez que todos os casos são em 2024).\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) +\n  facet_wrap(.~doenca_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito de residência\",\n       x = \"Data comunicada pela clínica\",\n       y = \"Contagem\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, malária, febre tifoide e febre amarela por semana em Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nTambém podemos ver na curva epidêmica que a cólera e a febre tifoide parecem estar ocorrendo como surtos isolados, em vez de mostrarem endemicidade. No entanto, a malária e a dengue estiveram presentes em Feveria durante todo o ano, com a malária atingindo um pico mais evidente nos meses de verão.\n\n\n\n\n\n\nDesta vez, utilize group_by() e summarize() para produzir uma tabela por distrito com as datas mais antigas e mais recentes dos relatórios.\nVocê pode modificar a sua tabela com um filter() para criar esta tabela para um distrito de cada vez.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuando foi notificado o primeiro caso de dengue de 2024 em Feveria?\n\n 18 de janeiro de 2024 17 de janeiro de 2024 12 de fevereiro de 2024\n\nQuando foi notificado o último caso de dengue em Feveria Central de 2024?\n\n 22 de agosto de 2024 18 de novembro de 2024 25 de dezembro de 2024\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgrupe os dados por doença e, em seguida, resuma a primeira e a última data para ver a cronologia geral de cada doença em Feveria.\n\ndados_vinculados_confirmados |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  doenca_notificada primeira_notificacao ultima_notificacao\n  &lt;chr&gt;             &lt;date&gt;               &lt;date&gt;            \n1 colera            2024-06-03           2024-09-23        \n2 dengue            2024-01-17           2024-11-18        \n3 febre amarela     2024-03-08           2024-08-23        \n4 febre tifoide     2024-05-02           2024-11-07        \n5 malaria           2024-01-08           2024-12-25        \n\n\nAdicione um filter() ao código para ver as datas da primeira e da última notificações no distrito em que está interessado.\n\ndados_vinculados_confirmados |&gt; \n  filter(distrito_de_residencia == \"Feveria Central\") |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  doenca_notificada primeira_notificacao ultima_notificacao\n  &lt;chr&gt;             &lt;date&gt;               &lt;date&gt;            \n1 colera            2024-06-03           2024-09-23        \n2 dengue            2024-01-29           2024-08-22        \n3 febre tifoide     2024-05-02           2024-11-07        \n4 malaria           2024-01-29           2024-12-17        \n\n\n\n\n\n\n\n\n\n\nUau! De acordo com os objetivos deste estudo de caso, você conseguiu fazer o seguinte:\n\nUtilizar funções-chave do R para limpar, remodelar e vincular data frames, além de criar novas colunas utilizando condições lógicas.\nPara orientar o processamento dos dados, você realizou inspeções e verificações de dados ao longo do caminho\nVocê conduziu uma análise descritiva detalhada para compreender os dados dos exames e notificações, antes e depois da vinculação. Em resposta às quatro perguntas iniciais do seu supervisor, você pode dizer:\n\nQuantos casos suspeitos das diferentes doenças de notificação compulsória foram notificados em 2024, e qual foi o mais comum? A malária foi a doença de notificação compulsória mais comum em Feveria em 2024, notificada através do sistema de vigilância de doenças de notificação compulsória: Foram notificados 533 casos suspeitos de malária, 273 casos suspeitos de dengue, 100 de febre amarela, 46 de cólera e 35 de febre tifoide.\nQual a porcentagem de casos acabaram sendo confirmados? Quase 80% dos casos notificáveis notificados em 2024 tinham um resultado de exame laboratorial no momento em que o conjunto de dados vinculados foi criado, com alguma variação por doença. No total, 56% dos casos notificados acabaram por ser confirmados, mas esta percentagem variou entre 23% para a febre tifoide (7 casos confirmados de 31 casos suspeitos com resultados de exames) e 95% para a cólera (38 casos confirmados de 40 casos suspeitos com resultados de exames). Além disso, a taxa de positivos foi mais elevada para a suspeita de dengue do que para a suspeita de malária (87% contra 41%).\nQuantos casos confirmados das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi o mais comum? Os casos confirmados seguiram uma tendência ligeiramente diferente da dos casos suspeitos: a infecção mais notificada foi a dengue, com 186 casos, seguida da malária (174), da cólera (38), da febre amarela (33) e da febre tifoide (7).\nComo é que os casos confirmados se distribuem geográfica e temporalmente em Feveria? Feveria registrou transmissão de dengue e malária ao longo do ano, com picos no verão, e concentrados no distrito de Lago Minara. Feveria também registrou surtos pequenos e pouco frequentes de doenças diarreicas, por exemplo, cólera e febre tifoide, particularmente na área urbana de Feveria Central, onde pode haver problemas com água e saneamento.\n\nPor último, você refletiu sobre a forma como os processos envolvidos nos sistemas de vigilância de doenças de notificação compulsória e nos exames laboratoriais, por exemplo, a transferência de dados entre clínicas e laboratórios, podem afetar a qualidade e a integridade dos dados e, como consequência, os seus resultados.\n\nHá muito mais potencial pela frente. Você pode explorar padrões de doença por idade ou sexo, calcular taxas de doença com dados populacionais e até analisar atrasos na notificação, examinando as diferentes datas nos seus conjuntos de dados.\nVocê construiu uma base sólida e está bem equipado para levar a sua análise para o nível seguinte. Continue firme - descobertas emocionantes o aguardam!\nPara saber mais, consulte os outros estudos de caso ou mergulhe no Manual de R para Epidemiologistas.\n\n\n\nVeja abaixo um script de todas as etapas de limpeza de dados e análises descritivas. Repare como as análises são combinadas no final ao invés de intercaladas entre os passos de limpeza. Esta é uma forma mais organizada de estruturar o seu script.\nPara simplificar, o código abaixo não inclui todas as inspeções e verificações realizadas ao longo do processo, mas você pode optar por criar uma seção específica para esses verificações.\nO início do seu script também deve trazer informações que ajudem o leitor a entender para que ele serve, além de comentários ao longo do código. Você mesmo vai agradecer por ter incluído esses comentários no futuro!\n\n\n\n\n\n\nCódigo para limpar e analisar dados de notificação e dados laboratoriais de Feveria, 2024\n\n\n\n\n\n\n# Código para limpar e analisar dados de notificação e dados laboratoriais de Feveria, 2024\n# Data:\n# Autor:\n\n# Instalar os pacotes ----------------------------------------------\n# Verificar se o pacote \"pacman\" está instalado\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Instala (se necessário) a partir do CRAN e carrega os pacotes a serem usados\npacman::p_load(\n  rio,        # importação de dados\n  skimr,      # visão geral dos dados\n  janitor,    # limpeza de dados e tabelas\n  lubridate,  # manipulação de datas\n  epikit,     # criação de categorias de idade\n  gtsummary,  # estatísticas descritivas, testes e regressão\n  apyramid,   # gráficos de pirâmides etárias\n  flextable,  # tabelas prontas para apresentação\n  naniar,     # análise de dados faltantes\n  remotes,    # instalação de pacotes para baixar dados\n  tidyverse   # manipulação e visualização de dados\n)\n\n# Importar os dados ------------------------------------------------\n\n# dados de notificação\ndados_notif_bruto &lt;- import(\"data/notificacoes_multidoencas.xlsx\")\n\n# Dados laboratoriais\ndados_lab_bruto &lt;- import(\"data/testes_multidoencas.csv\")\n\n# Limpar os dados de notificação -----------------------------------\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao = data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt; \n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(data_notificacao = ymd(data_notificacao)) \n\n\n# Limpar e consolidar os dados laboratoriais -----------------------\n# Padronizar valores\ndados_lab &lt;- dados_lab_bruto |&gt; \n  mutate(resultado = case_match(resultado, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\n# Criar base em nível de exame laboratorial\ndados_lab_testes &lt;- dados_lab |&gt; \n  filter(alvo != \"Dengue IgG\") |&gt; \n  group_by(id_amostra) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Criar base em nível de caso\ndados_lab_casos &lt;- dados_lab_testes |&gt; \n  group_by(id_notificacao) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Vincular dados de notificação e dados laboratoriais --------------\ndados_vinculados &lt;- left_join(dados_notif, dados_lab_casos, by = \"id_notificacao\")\n\n# Limpar os dados --------------------------------------------------\ndados_vinculados &lt;- dados_vinculados |&gt; \n  mutate(categoria_caso = case_when(resultado==\"Positivo\" ~ \"Confirmado\",\n                                   resultado==\"Negativo\" ~ \"Descartado\",\n                                   resultado==\"Indeterminado\" | is.na(resultado) ~ \"Suspeito\"))\n\ndados_vinculados_confirmados &lt;- dados_vinculados |&gt; \n  filter(categoria_caso==\"Confirmado\")\n\n# ANÁLISE ----------------------------------------------------------\n# Número de casos suspeitos em Feveria\ntabyl(dados_notif, doenca_notificada)\n\n# Distribuição de casos suspeitos por distrito\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribuição de resultados por exames específicos\ntabyl(dados_lab_testes, exame, resultado) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição da categoria de caso, nos dados vinculados: todos os casos\ntabyl(dados_vinculados, categoria_caso) \n\n# Distribuição da categoria de caso por doença, nos dados vinculados: todos os casos\ntabyl(dados_vinculados, doenca_notificada, categoria_caso) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição da categoria de caso por doença, nos dados vinculados: apenas casos com um resultado válido\ndados_vinculados |&gt; \n    filter(categoria_caso != \"Suspeito\") |&gt; \n    tabyl(doenca_notificada, categoria_caso) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição de casos confirmados por distrito\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada, distrito_de_residencia) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualizar casos confirmados ao longo do tempo\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) +\n  facet_wrap(.~doenca_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito de residência\",\n       x = \"Data comunicada pela clínica\",\n       y = \"Contagem\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, malária, febre tifoide e febre amarela por semana em Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# Primeira e última notificações por doença\ndados_vinculados_confirmados |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutores originais: Paula Blomquist e Alanah Jansen, com apoio técnico fornecido pelo CDC Global Surveillance, Laboratory, and Data Systems Branch em colaboração com a TEPHINET.\nFonte de dados: Dados fictícios fornecidos pela Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nData\nAlterações efetuadas\nVersão\nAutor\n\n\n\n\nJulho de 2025\nPrimeiro rascunho\n1\nPaula Blomquist e Alanah Jansen, Applied Epi, com o apoio técnico do CDC Global Surveillance, Laboratory, and Data Systems Branch em colaboração com a TEPHINET\n\n\nAgosto de 2025\nTradução para o português\n1\nLucca Nielsen e Pedro Menezes\n\n\n\n\n\n\nAviso legal: A informação apresentada neste exercício e os arquivos de dados associados foram desenvolvidos para ajudar os alunos a atingir os objetivos de aprendizagem pretendidos. Os conteúdos são da responsabilidade do(s) autor(es) e não representam necessariamente as opiniões oficiais do CDC, do Departamento de Saúde e Serviços Humanos dos EUA ou da TEPHINET.\nLicença: Este estudo de caso está sob uma licença CC BY-NC-SA 4.0. Para mais informações sobre o compartilhamento e adaptação deste estudo de caso, consulte a escritura associada.\nFinanciamento Este estudo de caso foi 100% apoiado pelo Acordo de Cooperação número NU2HGH000044 financiado pelos Centros de Controle e Prevenção de Doenças (CDC) dos EUA."
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#cenário",
    "href": "pages/multidisease_surveillance.pt.html#cenário",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Você é um epidemiologista que trabalha no serviço nacional de vigilância de Feveria, um país tropical muito pequeno. Existem três distritos em Feveria:\n\nFeveria Central:uma área urbana superpovoada, com infraestrutura de água e saneamento às vezes precária.\nLago Minara: uma zona lacustre com boa infra-estrutura mas muitos mosquitos nos meses mais quentes do ano.\nKasara: uma zona mais suburbana do outro lado de Feveria Central.\n\nMapa dos distritos do país Feveria\n\nÉ janeiro de 2025, e sua supervisora gostaria que você transferisse o processamento rotineiro dos dados de doenças de notificação compulsória do Excel para o R e realizasse algumas análises com os dados. Ela quer saber pelo menos:\n\nQuantos casos suspeitos das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi a mais comum?\nQual porcentagem deles acabou sendo confirmada?\nQuantos casos confirmados das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi a mais comum?\nComo é que os casos confirmados foram distribuídos geográfica e temporalmente em Feveria?\n\nEla pede que você escreva código para importar, limpar, relacionar e analisar as seguintes listas de casos (linelists):\n\nDados de vigilância de doenças notificáveis de 2024: Também designados por “dados de notificação”, estes são dados de vigilância de cinco doenças notificáveis comunicadas pelas clínicas do Feveria: dengue, malária, cólera, febre tifoide e febre amarela. Trata-se de casos suspeitos, baseados nos sintomas dos pacientes. Os médicos introduzem cada notificação num sistema em linha todos os dias da semana.\n2024 dados de resultados de testes laboratoriais: Estes dados provêm de resultados de análises laboratoriais de três grandes laboratórios de Feveria. Estes resultados referem-se a amostras colhidas dos casos suspeitos de doenças notificáveis mencionados acima.\n\nVamos lá!"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#objetivos",
    "href": "pages/multidisease_surveillance.pt.html#objetivos",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Neste estudo de caso, você vai:\n\nUsar funções-chave do R para limpar os dados, reorganizar os conjuntos de dados, relacionar fontes de dados e criar novas colunas usando condições lógicas, a fim de preparar os dados para análise.\nRealizar inspecções de dados e verificações da qualidade dos dados em várias fases do projeto e compreender a sua importância para uma análise confiável.\nRealizar análises descritivas básicas para comparar as tendências das doenças entre diferentes fontes de dados, antes e depois do linkage.\nInterpretar as diferenças nos resultados entre as fontes de dados e compreender como elas refletem a estrutura e o desenho do sistema de vigilância como um todo."
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-1.-configuração",
    "href": "pages/multidisease_surveillance.pt.html#passo-1.-configuração",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Comece por estabelecer um fluxo de trabalho reproduzível e bem organizado. Este facilitará a repetição da sua análise sempre que necessário.\nTarefas:\n\nConfigurar um projeto RStudio\nConfigurar subpastas claras onde o seu código, dados e resultados serão colocados\nCrie um script R, ou um arquivo R Markdown, se preferir. Certifique-se de que que o objetivo do script, a data e o autor estão escritos como comentários no topo.\nExtra: Certifique-se de que a sua linguagem de trabalho no RStudio é apropriada (por exemplo, inglês para este exercício)\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\n\nCrie uma pasta para onde irá todo o trabalho deste estudo de caso. Por exemplo, crie a pasta ‘multidoencas_lab’ no ambiente de trabalho do seu computador. Crie o seu projeto RStudio para ser baseado nesta pasta.\nSugerimos que crie as seguintes subpastas: scripts (para os códigos), data (para os seus dados), e outputs (para os resultados da análise).\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nCrie uma pasta (por exemplo, ‘multidoencas_lab’ no seu ambiente de trabalho) para o seu trabalho. Para criar um projeto Rstudio na sua nova pasta, clique em New Project… no canto superior esquerdo do seu R Studio e, em seguida Existing Directory e, em seguida Browse para selecionar a sua nova pasta. Para mais informações, consulte a secção Projetos R do Manual de R para Epidemiologistas\nInicie um novo script R clicando em New File… no canto superior esquerdo do seu R Studio e, em seguida R Script. Salve-o imediatamente no local apropriado, por exemplo, em uma subpasta ‘scripts’ dentro da pasta que contém seu projeto RStudio.\nNo topo do seu novo script R, escreva algumas informações essenciais como o seu nome, o objetivo do script e a data.\nO locale do R determina o idioma e as definições regionais utilizadas para o coisas como formatos de data e traduções. Se a sua localidade for diferente do idioma que pretende para o seu relatório (por exemplo, uma localidade francesa vs. uma localidade em inglês), pode alterá-la para inglês executando Sys.setlocale(\"LC_ALL\", \"English\"). Inclua isto no seu script se necessário, ou ignore-o se a sua localidade for normalmente apropriada. Isto é explicado em mais detalhes na seção Guia de instruções.\n\n\n\n\n\n\nA seguir, no seu script R, você precisa instalar e carregar os pacotes R necessários. Isto garante que as funções necessárias estarão disponíveis para sua análise.\nSão necessários os seguintes pacotes: {rio} (para importação de dados),{skimr} (para explroar os dados), {janitor} (para limpeza de dados), {lubridate} (para limpeza de datas), {epikit} (para tarefas relacionadas com epidemiologia), {gtsummary} (para estatísticas resumidas/testes e regressão), {apyramid} (para pirâmides etárias), {flextable} (para tabelas prontas para apresentação), {naniar} (para avaliar dados faltantes), e {tidyverse} (para tarefas gerais de manipulação de dados). Também vai precisar do {remotes} para baixar os dados - o que explicaremos na seção de download.\nAo começar, seu colega de confiança te cutuca e sussurra: “Ouvi dizer que uma ótima forma de gerenciar seus pacotes é com o pacote {pacman}”.\nAgora é com você!\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize a função p_load() do pacote pacman para esta tarefa. Você fornece uma lista de pacotes que deseja utilizar. A função executará dois passos por pacote: 1) Verificar se o pacote está instalado no seu computador, e instalá-lo se necessário, depois 2) Carregar o pacote para que ele possa ser usado durante esta sessão do R.\nSe ainda não tem pacman instalado, será necessário instalar ele da “maneira tradicional”, com install.packages().\nNote que a ordem dos pacotes na sua função p_load pode ser importante. Se dois pacotes tiverem os mesmos nomes de função (por exemplo select() no pacote MASS e select() na tidyverse, que fazem diferentes coisas), então o R utilizará a função do pacote mais recentemente carregado. Para dar prioridade às funções do tidyverse, que são normalmente utilizadas para manipulação e visualização de dados, carregue sempre tidyverse por último.\n\n# Garante que o pacote \"pacman\" está instalado\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\")\n}\n\n# Instala (se necessário) a partir do CRAN e carrega os pacotes a serem usados\npacman::p_load(\n  rio,        # importar dados\n  skimr,      # obter visão geral dos dados\n  janitor,    # limpeza de dados e criação de tabelas\n  lubridate,  # trabalhar com datas\n  epikit,     # criar categorias de idade\n  gtsummary,  # estatísticas resumidas, testes e regressões\n  apyramid,   # plotar pirâmides etárias\n  flextable,  # tabelas prontas para apresentação\n  naniar,     # avaliar dados ausentes\n  remotes,    # usado para instalar pacotes para baixar dados\n  tidyverse   # gestão de dados e visualização\n)"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-2.-baixar-e-importar-os-dados",
    "href": "pages/multidisease_surveillance.pt.html#passo-2.-baixar-e-importar-os-dados",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "O seu escritório fornece-lhe dois arquivos para a sua análise, ambos com dados relativos a 2024 e atualizados a partir de 15 de janeiro de 2025:\n\nUm conjunto de dados no nível de notificação de doenças (“notificacoes_multidoencas.xlsx”) com informações de casos de 5 centros de saúde.\nUm conjunto de dados a nível de exames laboratoriais (“testes_multidoencas.csv”) apresentado por três laboratórios que efetuam exames para os 5 centros de saúde.\n\nPara este estudo de caso, você pode baixar os dados através do repositório de dados muito útil do Applied Epi, que pode ser acessado usando o pacote {appliedepidata}.\nSiga estes passos:\n\nInstale o pacote {appliedepidata} do GitHub usando a função install_github() do pacote {remotes} (que você instalou anteriormente).\n\n\n# Use a função install_github do pacote remotes para instalar o appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSalve os dois conjuntos de dados numa pasta específica utilizando a função save_data() do pacote {appliedepidata}. Execute o código abaixo. O exemplo abaixo salva os dados em uma subpasta data dentro do projeto do RStudio. Observe que, se você não especificar um local no argumento path da função, uma janela será exibida pedindo para selecionar manualmente uma pasta.\n\n\n# Salva os dois arquivos de dados usando a função save_data() do pacote appliedepidata\nappliedepidata::save_data(\"testes_multidoencas\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"notificacoes_multidoencas\",\n                          path = \"data\")\n\n\n\n\nÓtimo! Obrigado ao escritório do país e à Applied Epi! Agora é hora de importar os dados dessa pasta para o RStudio, para que você possa analisá-los.\n\n\nIdealmente, utilizará a mesma função para importar ambos os conjuntos de dados, apesar de uma ser um arquivo .csv e o outro um arquivo .xlsx. Nota: daqui para a frente, diremos simplesmente “ambiente” quando nos referirmos ao painel ambiente (Environment) no R Studio.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nUse a função import do pacote {rio} que consegue reconhecer e importar diferentes tipos de arquivos. Ela substitui funções de importação específicas para cada tipo de arquivo, como read.csv() do {base} para arquivos .csv e read_excel() do {readxl} para importar arquivos .xlsx.\nSe achar que precisa de saber mais sobre funções de importação, leia o capítulo Importar e exportar do Manual de R para Epidemiologistas\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAbaixo usamos a função import para carregar os dois arquivos. Note que estamos atribuindo os dados importados a dois objetos: um chamado dados_notif_bruto e outro chamado dados_lab_bruto. Adicionamos o sufixo ‘bruto’ para diferenciar esses dados das versões limpas que criaremos posteriormente.\n\n# Importar dados\n\n# Dados de notificação\ndados_notif_bruto &lt;- import(\"data/notificacoes_multidoencas.xlsx\")\n\n# Dados laboratoriais\ndados_lab_bruto &lt;- import(\"data/testes_multidoencas.csv\")"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-3.-inspecionar-os-dados",
    "href": "pages/multidisease_surveillance.pt.html#passo-3.-inspecionar-os-dados",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Os dados foram importados e agora é hora de ver que história eles contam. Faça uma análise inicial dos dois data frames brutos para verificar seu conteúdo e qualidade.\n\n\n\n\nUse as funções skim() do pacote {skimr}, names(), ncol() e nrow() para inspecionar seu conjunto de dados.\nA função skim() fornece muitas informações sobre a estrutura e o conteúdo dos dados, enquanto names() mostra os diferentes nomes das colunas. As funções ncol() e nrow() contam, respectivamente, o número de colunas e linhas do conjunto de dados. Você sabe o que colocar dentro dos parênteses?\nO jeito mais fácil, no entanto, é olhar diretamente o ambiente do RStudio.\nLembre-se: o objeto no seu ambiente referente às notificações se chama dados_notif_bruto.\nClique na caixa de solução abaixo das perguntas se precisar de ajuda.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas existem nos dados de notificações?\n\n 10 11 12 13\n\nQuais dessas colunas NÃO estão nos dados?\n\n Data de início dos sintomas Data comunicada pela unidade de saúde/comunidade Data do Resultado Data do teste Data de nascimento\n\nQual é o nome da coluna nos dados de notificação que identifica cada notificação?\n\n ID notificacao ID do teste Codigo da unidade de saude Combinação de ID notificacao e Sexo\n\nQuantas linhas existem nos dados de notificação?\n\n 987 1314 950 778\n\nQue tipo de informação você NÃO consegue ver nos dados de notificação?\n\n Resultados de exames laboratoriais Distrito de residência Data de nascimento e Sexo Unidade de saúde em que o caso foi diagnosticado Desfecho\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUse a função skim() do pacote {skimr} para ver um resumo de todo o data frame, e View() para visualizar diretamente o data frame completo:\n\nskim(dados_notif_bruto)\n\nOu você pode usar names() para exibir apenas os nomes das colunas. Com skim() ou names() você poderá ver os tipos de informação, incluindo: a unidade de saúde do caso, data de nascimento, sexo, um indicador de gravidez, distrito de residência, data de início dos sintomas, data comunicada pela clínica e informações sobre o desfecho.\nTambém existe um ID notificacao, que parece ser um identificador único para cada caso, mas é recomendável verificar duplicatas antes de ter certeza.\nObserve que NÃO há resultados de testes nesses dados, pois essas notificações são de clínicas que diagnosticam doenças de notificação compulsória com base em definições clínicas de caso.\n\nnames(dados_notif_bruto)\n\n [1] \"Nome da unidade organizacional\"                  \n [2] \"Codigo da unidade de saude\"                      \n [3] \"ID notificacao\"                                  \n [4] \"Data de nascimento\"                              \n [5] \"Sexo\"                                            \n [6] \"Gestante\"                                        \n [7] \"Distrito de residencia\"                          \n [8] \"Doenca notificada\"                               \n [9] \"Data de inicio dos sintomas\"                     \n[10] \"Data comunicada pela unidade de saude/comunidade\"\n[11] \"Resultado\"                                       \n[12] \"Data do resultado\"                               \n\n\nUse ncol() e nrow() para exibir o número de colunas e linhas, assim:\n\nncol(dados_notif_bruto)\nnrow(dados_notif_bruto)\n\nIsso exibirá o número de colunas e linhas no console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nDe outro modo, ao olhar para o ambiente, você pode ver que o número de observações (que é o mesmo que o número de linhas) e o número de colunas estão listados ao lado do nome do data frame.\n\n\n\n\n\n\nUse a função skim() do pacote {skimr} ou class() para inspecionar as classes das colunas.\nVocê se lembra de como especificar a coluna de interesse dentro da função class()?\nComo alternativa, você pode simplesmente olhar para o ambiente.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas do data frame de notificações são reconhecidas pelo R como colunas de data?\n\n 0 2 4\n\nQual é a classe da maioria das colunas no data frame bruto de notificações?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVocê pode usar a função class() como no exemplo abaixo. O $ é um operador usado para selecionar uma coluna específica do data frame dados_notif_bruto.\nObserve que os acentos graves (`) são usados em torno de Data de nascimento porque o nome da coluna contém espaços.\n\nclass(dados_notif_bruto$`Data de nascimento`)\n\nPara verificar a classe pelo ambiente, clique na seta azul ao lado do nome do data frame.\nOs nomes das colunas aparecerão, com a classe ao lado (por exemplo, aparece “chr” para indicar que é do tipo character).\nVocê pode ver que nenhuma das colunas que deveriam ser datas é reconhecida como tal.\nEm vez disso, elas são reconhecidas como valores do tipo character.\n\n\n\n\n\n\nUse a função tabyl() para inspecionar os valores dentro de colunas categóricas, especificando o objeto do data frame no primeiro argumento e o nome da coluna no segundo argumento.\nPor exemplo, este código tabula os valores da coluna Sexo. A saída mostra que “masculino” e “feminino” estão escritos de forma inconsistente nos dados. Essa coluna precisará de limpeza adicional antes da análise.\n\ntabyl(dados_notif_bruto, Sexo)\n\n      Sexo   n    percent valid_percent\n         F  47 0.04761905    0.05452436\n  FEMININO 146 0.14792300    0.16937355\n         M  40 0.04052685    0.04640371\n MASCULINO 172 0.17426545    0.19953596\n         f 154 0.15602837    0.17865429\n  feminino  98 0.09929078    0.11368910\n         m 119 0.12056738    0.13805104\n masculino  86 0.08713273    0.09976798\n      &lt;NA&gt; 125 0.12664640            NA\n\n\nPara inspecionar dados ausentes, você pode usar a função miss_var_summary() do pacote {naniar}:\n\nmiss_var_summary(dados_notif_bruto)\n\n# A tibble: 12 × 3\n   variable                                         n_miss pct_miss\n   &lt;chr&gt;                                             &lt;int&gt;    &lt;num&gt;\n 1 Data de inicio dos sintomas                         691     70.0\n 2 Gestante                                            510     51.7\n 3 Resultado                                           197     20.0\n 4 Data do resultado                                   197     20.0\n 5 Data de nascimento                                  168     17.0\n 6 Sexo                                                125     12.7\n 7 Nome da unidade organizacional                        0      0  \n 8 Codigo da unidade de saude                            0      0  \n 9 ID notificacao                                        0      0  \n10 Distrito de residencia                                0      0  \n11 Doenca notificada                                     0      0  \n12 Data comunicada pela unidade de saude/comunidade      0      0  \n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nOs valores na coluna Distrito de residência estão padronizados?\n\n Não - precisam ser limpas Estão padronizadas e prontas para análise\n\nOs valores na coluna Doença notificada estão padronizados?\n\n Não - precisam ser limpas Estão padronizadas e prontas para análise\n\nO que o R reconhece como valor ausente?\n\n Ou nenhum valor, ou apenas um espaço, ou apenas um ponto Nenhum valor em uma célula, representado por NA As palavras Desconhecido e Incerto\n\nCom base na quantidade de valores ausentes, a coluna Data de início dos sintomas é útil?\n\n Sim, o índice de ausentes é baixo, então esta coluna é útil Minimamente, pois o índice de ausentes é muito alto\n\nPor que algumas colunas nos dados de notificação podem ter diferentes grafias e categorias não padronizadas?\n\n Um robô embaralha os dados para que fiquem menos identificáveis Cada clínica pode usar softwares configurados de forma ligeiramente diferente ou permitir entradas em texto livre, gerando variações na escrita O software do sistema de vigilância usado pelas unidades clínicas possui muitos erros\n\nPor que algumas colunas nos dados de notificação podem apresentar grande quantidade de valores ausentes?\n\n O clínico não faz a pergunta ao paciente durante a consulta O paciente pode não saber ou não querer informar a resposta O clínico pode não ter tempo de priorizar o preenchimento desse campo, mesmo sabendo a informação Todas as alternativas acima, e muitos outros motivos\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUse a função tabyl() para tabular os valores da coluna Distrito de residencia.\nNovamente, o primeiro argumento é o nome do objeto do data frame e o segundo argumento é o nome da coluna.\n\ntabyl(dados_notif_bruto, `Distrito de residencia`)\n\n Distrito de residencia   n    percent\n              F Central  32 0.03242148\n              FEVERIA C  23 0.02330294\n        FEVERIA CENTRAL  85 0.08611955\n              Feveria C  24 0.02431611\n        Feveria Central  12 0.01215805\n                 KASARA  64 0.06484296\n                    KSR  17 0.01722391\n                 Kasara 109 0.11043566\n               L MINARA  50 0.05065856\n               L Minara 193 0.19554205\n            LAGO MINARA 185 0.18743668\n            Lago Minara  68 0.06889564\n               Lakeside 125 0.12664640\n\n\nVocê pode ver que cada uma das três localidades (Feveria Central, Lago Minara e Kasara) está escrita de maneiras diferentes e com capitalização diferente. Será necessário corrigir isso se quisermos analisar a distribuição geográfica das doenças de notificação compulsória.\nDe forma semelhante, use a função tabyl() para tabular os valores da coluna Doença notificada.\nVocê pode ver que os nomes estão escritos de forma adequada e consistente, permitindo visualizar a distribuição de linhas por doença sem necessidade de limpeza adicional.\n\ntabyl(dados_notif_bruto, `Doenca notificada`)\n\n Doenca notificada   n    percent\n            colera  46 0.04660588\n            dengue 273 0.27659574\n     febre amarela 100 0.10131712\n     febre tifoide  35 0.03546099\n           malaria 533 0.54002026\n\n\nUma forma diferente de verificar dados ausentes é tabular o resultado da função is.na(). No exemplo abaixo, a função is.na() avalia cada célula da coluna Data de início dos sintomas, retornando TRUE para as ausentes e FALSE para as presentes.\nExecutar tabyl() sobre essa saída TRUE/FALSE fornece rapidamente a contagem e o percentual de valores ausentes e não ausentes nessa coluna. Lembre-se: valores como um espaço ou as palavras “Desconhecido” ou “Ausente” não serão reconhecidos pelo R como ausentes. O R reconhece apenas espaços verdadeiramente em branco como ausentes, representados por NA.\nPara a coluna Data de início dos sintomas, você pode ver que 70% dos casos estão sem essa informação, sugerindo que essa coluna não seria particularmente útil para analisar tendências de doenças ao longo do tempo.\n\ntabyl(is.na(dados_notif_bruto$`Data de inicio dos sintomas`))\n\n is.na(dados_notif_bruto$`Data de inicio dos sintomas`)   n   percent\n                                                  FALSE 296 0.2998987\n                                                   TRUE 691 0.7001013\n\n\nDados ausentes ou não padronizados podem ocorrer por diversos motivos, incluindo o design da ferramenta de coleta de dados (por exemplo, se as perguntas são obrigatórias ou permitem texto livre versus listas suspensas), os processos e padrões estabelecidos (como quais campos a equipe é instruída a priorizar) e fatores contextuais (como se a equipe dispõe de tempo suficiente para coletar a informação) — entre muitos outros.\n\n\n\n\n\n\n\n\n\nDa mesma forma como acontece com os dados de notificação, utilize as funções skim(), ncol(), e nrow() ou verifique o objeto no ambiente para inspecionar os dados laboratoriais.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual data frame tem mais colunas - os dados de notificação ou os dados laboratoriais?\n\n Dados laboratoriais Dados de notificação Eles têm o mesmo número de colunas\n\nQual data frame tem mais linhas?\n\n Dados laboratoriais Dados de notificação Eles têm o mesmo número de linhas\n\nInspecione os dados laboratoriais com View(). Por que pode haver mais registros nos dados laboratoriais?\n\n Pode haver vários testes ou alvos por amostra Existem muitos resultados de testes de ensaio nos dados Nem todas as notificações têm resultados de testes ainda\n\nQual destas colunas NÃO está nos dados laboratoriais?\n\n ID notificação ID da amostra Tipo de teste Data de nascimento Resultado do teste\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nAssim como na seção 3.1, você pode usar a função skim() do pacote {skimr} para visualizar todos os dado laboratoriais com os resultados dos testes. Isso também mostrará os diferentes nomes de colunas nos dados, evidenciando que os dados laboratoriais contém apenas informações sobre o teste e não sobre o paciente. No entanto, ele também contém um ID notificação, assim como os dados das notificações.\n\nskim(dados_lab_bruto)\n\nUtilizar ncol() e nrow() para exibir o número de colunas e linhas, assim:\n\nncol(dados_lab_bruto)\nnrow(dados_lab_bruto)\n\nIsto exibirá os números de colunas e linhas no painel console, mostrando que os dados do laboratório têm mais linhas do que os dados da notificação inspecionados anteriormente.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nFrequentemente há mais registros nos dados laboratoriais do que nos dados de notificação. Se você inspecionar os dados com View(dados_lab_bruto) e, em seguida, clicar na seta no topo da coluna id_notificacao para ordená-la alfabeticamente, verá que várias linhas compartilham o mesmo id_notificacao.\nIsso pode acontecer quando múltiplos alvos são testados a partir da mesma amostra (mesmo ID de amostra) ou quando um caso é retestado (resultando em um ID de amostra diferente).\n\nView(dados_lab_bruto)\n\n\n\nnome_laboratorioid_notificacaoid_amostradata_exameexamealvoresultadoHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHospital Geral de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHospital Geral de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nComo acima, utilize as funções class(), skim(), ou tabyl(), ou inspecione o objeto direto no ambiente RStudio, para analisar as suas colunas com mais detalhes.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas colunas dos dados laboratoriais são reconhecidas pelo R como colunas de data?\n\n 0 1 2\n\nQuantas colunas nos dados laboratoriais possuem dados completos?\n\n 1 3 7 (todas elas!)\n\nQual teste detecta múltiplos alvos (e, portanto, possui múltiplas linhas por amostra)?\n\n Malária Dengue Febre Amarela Cólera Febre Tifoide\n\nQuantos valores possíveis de resultado de teste existem na coluna resultado?\n\n 5 3 4\n\nQual NÃO é um resultado possível para o teste de cultura de fezes que detecta a bactéria V. cholerae?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nOs dados laboratoriais têm uma coluna de data, reconhecida pelo R como uma classe “IDate”. Esta é uma classe de data utilizada pela função import() do pacote {rio} ao importar arquivos csv. Da mesma forma como a classe Data do R base, ela permite ordenar pela data e analisar tendências ao longo do tempo.\n\nclass(dados_lab_bruto$data_exame)\n\n[1] \"IDate\" \"Date\" \n\n\nO uso da função miss_var_summary() do pacote {naniar} demonstra que todas as colunas dos dados laboratoriais estão efetivamente completas. Isto talvez se deva ao fato de os sistemas laboratoriais utilizarem processos automatizados, por isso é muito menos provável que haja erro humano.\n(Ponto importante: Nota-se que, na vida real, os dados laboratoriais provavelmente teriam alguns problemas!)\n\nmiss_var_summary(dados_lab_bruto)\n\n# A tibble: 7 × 3\n  variable         n_miss pct_miss\n  &lt;chr&gt;             &lt;int&gt;    &lt;num&gt;\n1 nome_laboratorio      0        0\n2 id_notificacao        0        0\n3 id_amostra            0        0\n4 data_exame            0        0\n5 exame                 0        0\n6 alvo                  0        0\n7 resultado             0        0\n\n\nPara ver quantos alvos são detectados por cada tipo de exame, faça uma tabulação cruzada das colunas exame e alvo com tabyl(). Escreva os nomes das colunas na função como dois argumentos separados. O resultado mostra que cada exame está claramente alinhado com um ou mais alvos, e apenas o teste da dengue detecta mais do que um alvo (IgG, IgM e NS.1).\nDica: Experimente alterar a ordem dos nomes das colunas na função para ver o impacto na tabela.\n\ntabyl(dados_lab_bruto, alvo, exame)\n\n                 alvo Cultura de fezes Dengue NS1/IgG/IgM Hemocultura IgM ELISA\n    Bacteria S. Typhi                0                  0          33         0\n Bacteria V. cholerae               45                  0           0         0\n           Dengue IgG                0                215           0         0\n           Dengue IgM                0                215           0         0\n          Dengue NS.1                0                215           0         0\n    Febre Amarela IgM                0                  0           0        88\n           Plasmodium                0                  0           0         0\n Microscopia de sangue total\n                           0\n                           0\n                           0\n                           0\n                           0\n                           0\n                         503\n\n\nFinalmente, inspecione os diferentes valores dos resultados do teste na coluna resultado usando tabyl(). Pode ver que existem seis resultados possíveis, incluindo N para negativo, P para positivo e I para indeterminado. A cólera, especificamente, não apresenta P, mas pode apresentar P01 e P0139, o que, neste caso, significa ser positivo para os serogrupos O1 ou O139.\n\ntabyl(dados_lab_bruto, exame, resultado)\n\n                       exame  I   N   P PO1 PO139\n            Cultura de fezes  5   2   0  22    16\n          Dengue NS1/IgG/IgM  0 354 291   0     0\n                 Hemocultura  2  24   7   0     0\n                   IgM ELISA 10  45  33   0     0\n Microscopia de sangue total 56 257 190   0     0"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-4.-limpar-e-descrever-os-dados-de-notificação",
    "href": "pages/multidisease_surveillance.pt.html#passo-4.-limpar-e-descrever-os-dados-de-notificação",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Agora já sabemos que os dados de notificação (dados_notif_bruto) contêm informações sobre casos suspeitos, além de variáveis demográficas básicas (idade, sexo, gravidez, distrito de residência), bem como dados sobre a data de início dos sintomas, a dados de notificação pela unidade de saúde e o desfecho. Algumas dessas colunas precisam ser limpas antes da análise, seja por variações na ortografia de valores categóricos, seja porque algumas datas não foram corretamente reconhecidas como tal.\nA partir deste ponto, você começará a escrever trechos mais longos de código para realizar a limpeza, utilizando várias funções do {dplyr} encadeadas com pipes (que se parecem com isso: |&gt;).\nNOTA SOBRE PIPES Os pipes permitem realizar várias operações em sequência, “encadeando” diferentes funções. O resultado de uma função passa a ser a entrada como primeiro argumento da seguinte.\nCaso queira mais detalhes sobre o uso de pipes, veja a seção do Manual de R para Epidemiologistas.\nNeste exercício será utilizado o pipe nativo do R (|&gt;), que é mais rápido e não exige instalação de pacotes adicionais. Se preferir, você também pode usar o pipe do pacote magrittr (%&gt;%).\n\n\n\n\nDevido a questões de qualidade e armazenamento de dados, a sua equipe recomenda que seja criado um data frame limpo, contendo apenas as seguintes variáveis: identificador único, localização do caso, doença e a data em que a notificação foi registrada no sistema de vigilância.\nEscreva um código em R para produzir um novo data frame limpo chamado dados_notif, aplicando as seguintes tarefas de limpeza:\n\nRenomear as colunas para serem mais legíveis pela máquina (remover espaços e capitalização) usando a função clean_names() do pacote {janitor}.\n\nUsar a função rename() do pacote {dplyr} para que a coluna com a data em que o caso foi notificado seja alterada para o nome mais conciso data_notificacao.\nSelecionar colunas relevantes para análise com a função select() do pacote {dplyr}.\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nComece seu código com o nome do novo data frame, a seta do operador de atribuição e o nome do objeto de dados brutos. Isso indica que o resultado do processamento dos dados brutos será atribuído a um novo objeto chamado dados_notif. .\n\ndados_notif &lt;- dados_notif_bruto\n\nEm seguida, desenvolva este código adicionando funções adicionais, encadeadas com um pipe. Isto permite executar várias operações em uma sequência contínua. Primeiro, utilize clean_names() para padronizar todos os nomes das suas colunas. Essa função substitui automaticamente espaços e caracteres especiais por sublinhados e converte tudo para minúsculas, tornando os nomes mais fáceis de trabalhar. Depois, você pode usar rename() para atribuir um novo nome a uma coluna. Lembre-se de que, ao utilizar rename(), a coluna já possui a versão de seu nome gerada pelo clean_names().\n\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(NOVO_NOME = ANTIGO_NOME) |&gt; \n  select(VAR_NOMES)\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código para limpar os nomes das colunas e selecionar as colunas certas para análise:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao)\n\n\n\n\n\n\n\nA partir da inspeção dos dados, já se sabe que os valores para distritonão estão padronizados.\nAdicione um mutate() para limpar a coluna distrito_de_residencia da seguinte maneira:\n\nNormalizar a capitalização dos valores dessa coluna\nSubstituir a coluna existente distrito_de_residencia existente por uma coluna limpa que contenha apenas estes valores de distrito: “Lago Minara”, “Feveria Central” e “Kasara”.\n\nVeja a dica para saber quais funções utilizar.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nTente usar str_to_title() do pacote {stringr} para que a primeira letra de cada palavra seja maiúscula e todas as outras letras sejam minúsculas. Também pode utilizar case_match() para corrigir erros tipográficos específicos.\nUse a funcionalidade de ajuda do RStudio para aprender a utilizar essas funções. Por exemplo, digite ?case_match no console para abrir a página de ajuda e a documentação da função. Nota: case_match() é uma função muito útil para substituir ou corrigir valores, e pode substituir recode().\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nO seu código de limpeza deve agora ter o seguinte aspecto:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = str_to_title(distrito_de_residencia)) |&gt; \n  mutate(distrito_de_residencia = case_match(distrito_de_residencia,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\nTambém pode envolver o str_to_title na função case_match() para um código mais curto, como se segue:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\n\n\n\n\n\n\nA coluna data_notificacao precisa ser transformada para que seja reconhecida como uma data no R. Isso permitirá analisar tendências ao longo do tempo, incluindo semanas e meses.\nReveja os valores da coluna data_notificacao. Em seguida, adicione uma linha ao seu código de limpeza para converter data_notificacao em uma classe de data.\nConhecer a estrutura dos dados permitirá utilizar a função correta para a conversão.\nRecomendamos o uso de funções do pacote {lubridate}, como ymd() (para datas no formato ano-mês-dia), mdy() (para datas no formato mês-dia-ano) ou dmy() (para datas no formato dia-mês-ano). Essas funções reconhecerão qualquer forma de escrever a data, desde que a ordem esteja correta; por exemplo, “21 de agosto de 2025” e “21-08-2024” seriam reconhecidas por dmy().\n\n\n\n\n\n\nPerguntas\n\n\n\n\nComo as datas estão atualmente formatadas?\n\n dia-mês-ano ano-mês-dia mês-dia-ano ano-dia-mês\n\nQual função mutate() deve ser usada para converter a coluna data_notificacao para a classe de data?\n\n mutate(data_notificacao = ymd(data_notificacao)) mutate(data_notificacao = dmy(data_notificacao)) mutate(data_notificacao = mdy(data_notificacao))\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize a função head() para ver as primeiras seis linhas dos dados da coluna data_notificacao. É possível ver que elas são escritas no formato: ano primeiro, depois o mês e depois o dia.\n\nhead(dados_notif$data_notificacao)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nÉ possível utilizar a função ymd() dentro de mutate() para converter a coluna data_notificacao para a classe de data. Você pode verificar se a conversão foi correta executando class() em seguida.\nO seu código de limpeza deve agora ter o seguinte aspecto:\n\n# Limpeza dos dados\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao =  data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt;\n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))|&gt; \n  mutate(data_notificacao = ymd(data_notificacao)) \n\nE pode verificar novamente a classe assim:\n\nclass(dados_notif$data_notificacao)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nOs seus colegas dizem-lhe que cada id_notificacao representa um caso suspeito. Agora você pretende criar uma tabela para verificar se id_notificacao está duplicado nas linhas dos seus dados.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nUma linha nos dados de notificação equivale a um caso?\n\n Sim Não\n\nÉ necessário deduplicar seus dados para análise epidemiológica dos casos?\n\n Sim Não\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nHá várias formas de fazer isso, mas tente utilizar a função count() do pacote {dplyr}. Ela cria uma tabela que conta o número de linhas para cada valor único da coluna que você especificar. Em seguida, utilize tabyl() para visualizar a distribuição dessas contagens.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nPrimeiro, passe os dados de notificação para a função count(), usando id_notificacao como único argumento. Isso cria uma contagem do número de linhas para cada valor único de id_notificacao, apresentada em uma nova coluna chamada n. Por exemplo, neste excerto é possível ver que existe apenas uma linha para cada um desses 6 id_notificacao.\n\ndados_notif |&gt; \n  count(id_notificacao) \n\n\n\n  id_notificacao n\n1         00399b 1\n2         005c85 1\n3         006f52 1\n4         00cbbb 1\n5         01830d 1\n6         019045 1\n\n\nEm seguida, tabule a nova coluna n com a função tabyl(), que mostrará que existe apenas uma linha por id_notificacao único. Isso significa que cada linha equivale a um caso e não é necessária nenhuma deduplicação adicional.\n\ndados_notif |&gt; \n  count(id_notificacao) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nVocê pode agora proceder confortavelmente às análises descritivas dos casos, pois os dados estão limpos e cada linha equivale a um caso. Use a função tabyl() para realizar as tarefas seguintes.\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual doença foi mais frequentemente diagnosticada pelas clínicas em Feveria em 2024?\n\n Cólera Malária Dengue Febre Tifoide Febre Amarela\n\nQual doença foi menos frequentemente diagnosticada pelas clínicas em Feveria em 2024?\n\n Cólera Malária Dengue Febre Tifoide Febre Amarela\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUsando a função tabyl() podemos ver que houve 533 casos suspeitos de malária em Feveria em 2024, e apenas 35 casos suspeitos de febre tifoide.\n\ntabyl(dados_notif, doenca_notificada)\n\n doenca_notificada   n    percent\n            colera  46 0.04660588\n            dengue 273 0.27659574\n     febre amarela 100 0.10131712\n     febre tifoide  35 0.03546099\n           malaria 533 0.54002026\n\n\n\n\n\n\n\n\nUtilize tabyl() para fazer uma tabulação cruzada das colunas da doença notificada e do distrito de residência.\nDesenvolva a tabulação adicionando várias funções adorn() do pacote {janitor} para visualizar as distribuições percentuais, como por exemplo adorn_percentages(), adorn_pct_formatting() e adorn_ns().\nDigite o nome da função precedido de ? no console (por exemplo, ?adorn_ns) para acessar as páginas de ajuda relevantes. Você também pode consultar a seção sobre {janitor} no Manual de R para Epidemiologistas para mais explicações sobre as funções adorn_xxx().\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual distrito reportou o maior número de doenças transmitidas por vetores em 2024 (malária, dengue, febre amarela)?\n\n Lago Minara Feveria Central Kasara\n\nQual distrito reportou o maior número de doenças diarreicas em 2024 (cólera, febre tifoide)?\n\n Lago Minara Feveria Central Kasara\n\nQuais fatores contribuem para o aumento de doenças diarreicas neste distrito específico (selecionado na pergunta anterior)?\n\n Infraestrutura de água e saneamento pouco confiável Superlotação de mosquitos Não sabemos\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nAqui está um código para ajudá-lo a começar. Ele cria tabelas cruzadas entre doenca_notificada e distrito_de_residencia usando tabyl() e, em seguida, aplica adorn_percentages() para converter os números em percentagens com muitas casas decimais. Depois, é necessário passar para adorn_pct_formatting() para formatar as percentagens corretamente, e então usar adorn_ns() para adicionar os números originais entre parênteses.\nNote que as funções adorn_xxx() devem ser aplicadas em uma ordem específica!\n\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages()\n\nPara entender os fatores que contribuem para o aumento de casos de diarreia, volte ao início do estudo de caso, quando os distritos foram apresentados pela primeira vez.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUsando a função tabyl() podemos ver que a maioria dos casos suspeitos de dengue, malária e febre amarela ocorreu no Lago Minara, a área do lago com maior densidade de mosquitos e, portanto, maior transmissão de doenças por vetores. Por outro lado, cólera e febre tifoide foram predominantemente registradas em Feveria Central, uma zona urbana superlotada com problemas de infraestrutura de água e saneamento, que aumentam o risco de inundações e contaminação da água potável durante o período chuvoso.\n\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n doenca_notificada Feveria Central      Kasara Lago Minara\n            colera      91.3% (42)  8.7%   (4)  0.0%   (0)\n            dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n     febre amarela      11.0% (11) 21.0%  (21) 68.0%  (68)\n     febre tifoide      68.6% (24) 31.4%  (11)  0.0%   (0)\n           malaria      13.7% (73) 19.9% (106) 66.4% (354)"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-5.-limpar-consolidar-e-descrever-os-dados-laboratoriais",
    "href": "pages/multidisease_surveillance.pt.html#passo-5.-limpar-consolidar-e-descrever-os-dados-laboratoriais",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Com base no seu trabalho anterior, na Etapa 3, você verificou que os dados laboratoriais contêm apenas informações sobre os testes e nenhuma informação sobre o paciente. Os dados já estão bastante limpos, então só precisamos padronizar uma coluna. Também queremos processar o data frame do laboratório para que haja uma linha por notificação, permitindo que ele seja corretamente vinculado ao data frame de notificações.\n\n\n\n\nCriar um novo objeto dados_lab. Isto permitirá uma abordagem e análise mais direta bem como facilitará a interpretação dos resultados.\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilize case_match() para transformar os diferentes valores originais em “Positivo”, “Negativo” ou “Indeterminado”:\n\ndados_lab &lt;- dados_lab_bruto |&gt; \n  mutate(resultado = case_match(resultado, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\nVocê pode então verificar novamente se os novos valores estão corretos, tabulando e comparando os valores no data frame original e no data frame limpo. Certifique-se de que utilizou a letra ‘O’ e não o número ‘0’!\n\ntabyl(dados_lab_bruto, resultado)\n\n resultado   n    percent\n         I  73 0.05555556\n         N 682 0.51902588\n         P 521 0.39649924\n       PO1  22 0.01674277\n     PO139  16 0.01217656\n\n\n\ntabyl(dados_lab, resultado)\n\n     resultado   n    percent\n Indeterminado  73 0.05555556\n      Negativo 682 0.51902588\n      Positivo 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nJá sabemos que algumas amostras possuem várias linhas, porque o teste de dengue possui três alvos, gerando uma linha por resultado de alvo.\nAgora, identifique o número de amostras com várias linhas.\nFaça isso da mesma forma que fez com os dados de notificação: use dados_lab para primeiro contar o número de linhas por amostra e, em seguida, crie uma tabela para mostrar a distribuição desses números de linhas. Lembre-se de que cada amostra é identificada por um id_amostra.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas amostras (valores únicos de id_amostra) estão sendo repetidos em três linhas?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nPrimeiro, passe os dados laboratoriais para a função count(), usando id_amostra como único argumento.\nIsso cria uma tabela que conta o número de linhas por valor único de id_amostra, apresentado em uma nova coluna n.\nPor exemplo, pode-se ver que o id_amostra “000e8eee” possui três linhas, enquanto o id_amostra “001e1878” aparece em apenas uma linha.\n\ndados_lab |&gt; \n  count(id_amostra) \n\n\n\n  id_amostra n\n1   000e8eee 3\n2   001e1878 1\n3   005f39af 1\n4   00b30781 3\n5   00b56d18 1\n6   0110abcd 3\n\n\nEm seguida, tabule a nova coluna n com o tabyl().\n\ndados_lab |&gt; \n  count(id_amostra) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nPode até verificar se isto se aplica apenas ao exame de dengue adicionando a exame ao cálculo. Pode ver que é apenas o teste da dengue que tem 3 linhas por amostra.\n\ndados_lab |&gt; \n  count(exame, id_amostra) |&gt; \n  tabyl(exame, n)\n\n                       exame   1   3\n            Cultura de fezes  45   0\n          Dengue NS1/IgG/IgM   0 215\n                 Hemocultura  33   0\n                   IgM ELISA  88   0\n Microscopia de sangue total 503   0\n\n\n\n\n\n\n\n\nComo você viu na Seção 3.2, o teste de dengue fornece resultados para três alvos diferentes: IgG, IgM e NS1. Os resultados para cada um desses alvos podem ser negativos ou positivos. No entanto, para simplificar e consolidar os dados, deseja-se atribuir um único valor, negativo ou positivo, para cada amostra, indicando se a amostra representa uma infecção ativa.\n\n\nalvoNegativoPositivoDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nO seu colega Ben, que trabalha no laboratório, aconselha sobre a limpeza da seguinte forma:\n\nUma amostra pode ser considerada positiva se NS1 ou IgM forem positivos (já que ambos podem indicar uma infecção aguda).\n\nO IgG pode ser ignorado (porque um resultado positivo, na ausência de NS1 ou IgM positivos, indica imunidade de uma infecção passada resolvida).\n\nAgora, você precisa consolidar os resultados dos testes de dengue em uma linha por teste, com um valor de resultado. Utilize filter(), arrange() e slice(), garantindo que qualquer amostra positiva para NS1 ou IgM seja considerada positiva para dengue.\nCrie um novo objeto chamado dados_lab_testes.\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nTente aplicar o seguinte para consolidar os resultados de acordo com a recomendação do Ben:\n\nRemover resultados de IgG: filtre as linhas em que o alvo é \"IgG\" usando filter() do {dplyr}.\n\nPriorizar resultados positivos de IgM/NS1: agrupe por id_amostra e organize as linhas com arrange() para que qualquer resultado \"P\" (positivo) apareça primeiro.\n\nFiltrar para o status final: mantenha apenas a primeira linha usando slice(1) para obter o resultado positivo ou negativo da amostra.\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nAqui está o código para filtrar os resultados de IgG da dengue e, em seguida, consolidar o resultado do teste dentro de cada grupo de linhas com o mesmo id_amostra, dando prioridade aos resultados positivos.\nÉ necessário especificar desc dentro de arrange(), pois isso faz com que os resultados sejam ordenados em ordem alfabética inversa, colocando \"P\" no topo.\nAlém disso, adicione ungroup() no final para que os novos dados não permaneçam agrupados, o que poderia interferir em análises posteriores.\n\ndados_lab_testes &lt;- dados_lab |&gt; \n  filter(alvo != \"Dengue IgG\") |&gt; \n  group_by(id_amostra) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nEm seguida, é possível verificar novamente se o novo objeto dados_lab_testes contém apenas uma linha por teste, utilizando a combinação de count() e tabyl() como feito na Tarefa A.\nEsta tabela mostra que todos os IDs de amostra únicos estão presentes em apenas uma linha cada:\n\ndados_lab_testes |&gt; \n  count(id_amostra) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nEm seguida, verifique o número de testes por ID de notificação nos novos dados consolidados.\nPode-se observar que existem 26 linhas com o mesmo id_notificacao que outra linha, mas apenas entre os casos testados com microscopia de sangue total para malária.\n\ndados_lab_testes |&gt; \n  count(exame, id_notificacao) |&gt; \n  tabyl(exame, n)\n\n                       exame   1  2\n            Cultura de fezes  45  0\n          Dengue NS1/IgG/IgM 215  0\n                 Hemocultura  33  0\n                   IgM ELISA  88  0\n Microscopia de sangue total 451 26\n\n\nInvestiga-se mais detalhadamente analisando um caso de exemplo com id_notificacao “043228”.\nIsso mostra que este caso foi testado duas vezes, com duas amostras diferentes, com uma semana de intervalo. O primeiro resultado foi positivo e o segundo resultado foi negativo.\n\ndados_lab_testes |&gt; \n  filter(id_notificacao == \"043228\")\n\n# A tibble: 2 × 7\n  nome_laboratorio    id_notificacao id_amostra data_exame exame alvo  resultado\n  &lt;chr&gt;               &lt;chr&gt;          &lt;chr&gt;      &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    \n1 Hospital Universit… 043228         27c37cd8   2024-06-18 Micr… Plas… Positivo \n2 Hospital Universit… 043228         d2271be0   2024-06-25 Micr… Plas… Negativo \n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual afirmação sobre os dados laboratoriais está correta?\n\n Todos os casos de diferentes doenças são retestados Alguns casos de malária são retestados Todos os casos de malária são retestados\n\nSerá necessário deduplicar os dados laboratoriais para ligar com os dados de notificação?\n\n Sim - precisamos de uma linha representando o resultado do laboratório por notificação Não - os dados já estão suficientemente deduplicados\n\n\n\n\nSe respondeu que precisa deduplicar, está correto!\nDeduplicar os dados para ter uma linha por ID de notificação priorizando os resultados positivos, para que seja possível fazer a vinculação com os dados da notificação.\nPara fazer isso, siga um processo semelhante ao da tarefa B, utilizando a estrutura de dados produzida pela tarefa B:\n\nAgrupar por id_notificacao\nOrdenar pelo valor do resultado do exame, de modo a que os valores que começam por P tenham prioridade na linha superior, seguidos por N (negativo) e depois I (indeterminado).\nEm seguida, mantenha a primeira linha dentro de cada grupo de id_notificacaos, utilizando slice().\nAo fazer isto, crie um novo objeto chamado dados_lab_casos.\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código para deduplicar as linhas dentro de cada grupo de linhas com o mesmo id_notificacao dando prioridade aos resultados positivos. Mais uma vez, você precisa especificar desc dentro de arrange(). Isto funciona perfeitamente porque a ordem de prioridade desejada para os resultados — positivos, depois negativos, depois indeterminados — alinha-se com a ordem alfabética inversa (P vem antes de N, que vem antes de I, quando ordenado de forma descendente).\nSe a sua ordem de prioridades fosse mais complexa ou não correspondesse à ordem alfabética (por exemplo, se “indeterminado” precisasse de vir antes de “negativo”), teria de converter a coluna de resultados num fator e explicitamente definir a ordem desejada dos seus níveis. Não se esqueça de desagrupar novamente no final.\n\ndados_lab_casos &lt;- dados_lab_testes |&gt; \n  group_by(id_notificacao) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nVocê pode então verificar novamente se o novo objeto dados_lab_casos tem apenas uma linha por exame, usando a combinação de count() e tabyl() como fez na Tarefa A. Esta tabela lhe mostra que todos os IDs de amostra únicos estão presentes em apenas uma linha cada:\n\ndados_lab_casos |&gt; \n  count(id_notificacao) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nAgora temos dois objetos que podemos utilizar para a análise de dados laboratoriais: dados_lab_testes e dados_lab_casos.\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue objeto você deve utilizar para analisar os exames?\n\n dados_lab_testes dados_lab_casos nenhum destes\n\nQuantos exames foram conduzidos para examinar para malária (através da microscopia de sangue total)?\n\n 215 503 88 190\n\nQue porcentagem dos exames para cólera (através da cultura de fezes) foi positiva?\n\n 21% 11% 84% 87%\n\nQuais exames tiveram a maior porcentagem de resultados indeterminados?\n\n IgM ELISA (para detecção de febre amarela) Cultura de fezes (para detecção de cólera) Hemocultura (para detecção de febre tifóide)\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilizando tabyl() podemos ver o número de resultados positivos, negativos e indeterminados por exame. Você pode adicionar uma série de funções adorn() para mostrar porcentagens e totais.\n\ntabyl(dados_lab_testes, exame, resultado) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                       exame Indeterminado    Negativo    Positivo        Total\n            Cultura de fezes    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n          Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n                 Hemocultura     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                   IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopia de sangue total    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue data frame de dados laboratoriais você deve usar para contar o número de casos supeitos examinados?\n\n dados_lab_bruto dados_lab_casos dados_lab_testes dados_lab\n\nQuantos casos suspeitos foram examinados nos dados laboratoriais de 2024?\n\n 858 1314 884\n\nExistem mais casos suspeitos nos dados de notificação ou nos dados laboratoriais?\n\n dados de notificação Dados laboratoriais\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nVocê pode simplesmente analisar o número de linhas no data frame dados_lab_casos para ver o número de casos suspeitos que foram examinados.\n\nnrow(dados_lab_casos)\n\n[1] 858\n\n\nEste número é inferior ao número de casos suspeitos que estavam nos dados limpos de vigilância de doenças de notificação compulsória (dados_notif) - o que sugere que nem todos os casos suspeitos em 2024 foram examinados quando estes dados estavam disponíveis.\n\nnrow(dados_notif)\n\n[1] 987"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#etapa-6.-vinculação-e-processamento-final",
    "href": "pages/multidisease_surveillance.pt.html#etapa-6.-vinculação-e-processamento-final",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Agora que ambas as listas de casos estão limpas e têm uma linha por caso suspeito, você pode vinculá-las para permitir a análise completa solicitada pelo seu chefe.\n\n\n\n\nCriar um novo objeto chamado dados_vinculados, utilizando uma função xxx_join() do {dplyr}. Pretende-se manter todas as notificações, mas adicionar resultados de exames, quando disponíveis, para cada caso suspeito.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue função traz a abordagem correta se você quiser manter todas as linhas dos seus dados de notificação e trazer os resultados dos dados laboratoriais?\n\n left_join(dados_notif, dados_lab_casos… full_join(dados_notif, dados_lab_casos… right_join(dados_notif, dados_lab_casos…\n\nQue identificador deve ser utilizado para vincular as duas listas de casos?\n\n id_amostra id_notificacao id_amostra e data de notificação id_notificacao e data de notificação\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (experimente primeiro!)\n\n\n\n\n\nLigue os dados utilizando o left_join() com os dados de notificação como data frame principal à esquerda. Isto manterá todas as linhas deste data frame e apenas introduzirá os resultados dos exames nos dados laboratoriais especificados à “direita” da função.\n\ndados_vinculados &lt;- left_join(dados_notif, dados_lab_casos, \n                         by = \"id_notificacao\")\n\nVocê está ligando através da coluna id_notificacao, que está presente, completa e limpa em ambas as listas de casos.\nNota: Você tem sorte de trabalhar com um exemplo de ligação tão simples! Normalmente, seria necessário limpar e verificar a coluna de ID, ou vincular a outras colunas como o nome e a data de nascimento. Em Feveria, os clínicos são fantásticos em atribuir consistentemente IDs de notificação a cada doente, incluindo nos formulários de amostra enviados para o laboratório, e ainda o pessoal do laboratório é igualmente brilhante em registrar o ID de notificação nos seus sistemas de laboratório, para que os resultados possam ser associados ao caso.\n\n\n\n\n\n\nAgora, verifique os seus dados e revise algumas coisas.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantas linhas tem o seu novo data frame dados_vinculados?\n\n 987 884 858\n\nComo este resultado se compara aos seus dados de notificação originais?\n\n mais linhas que o original o mesmo número de linhas menos linhas\n\nQue termo melhor descreve a vinculação que você acabou de realizar?\n\n muitos-para-um um-para-um muitos-para-muitos\n\nQuantos resultados de laboratório NÃO foram vinculados? (dica: use anti-join())?\n\n 30 19 0\n\nQuão sortudo você foi por sua vinculação de dados ter sido tão bem-sucedida?\n\n O quê? Nem toda vinculação de dados é simples assim?? Bastante! Normalmente alguns registros não têm correspondência.\n\nQuais são razões típicas para os dados laboratoriais não possuírem correspondência entre os dados de notificação?\n\n Existem erros de digitação nas colunas utilizadas para a vinculação, e por isso elas não são reconhecidas como correspondências Os dados laboratoriais podem conter casos adicionais de outras clínicas ou países Os dados laboratoriais podem incluir amostras de exames Notificações podem ter sido acidentalmente perdidas nos dados de notificação apesar da amostra ter sido examinada em laboratório Todas as opções acima\n\nQuantos casos supeitos não possuem um resultado?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVerifique o número de linhas em cada quadro de dados com o comando nrow() ou olhando as informações do objeto no seu ambiente. É possível ver que esta foi simplesmente uma vinculação de um para um, porque cada linha tinha um único id_notificacao, então uma linha nos dados de notificação se vinculou exatamente a uma linha dos dados laboratoriais.\nNúmero de linhas nos dados de notificação\n\nnrow(dados_notif)\n\n[1] 987\n\n\nNúmero de linhas nos dados vinculados\n\nnrow(dados_vinculados)\n\n[1] 987\n\n\nPara verificar se houve algum resultado de laboratório que não estava ligado aos dados de notificação, é possível usar anti_join(). Desta vez, o objeto dados_lab_casos está à esquerda, pois a função avalia quantas linhas do data frame da esquerda não foram encontradas no data frame da direita, ao realizar a correspondência por id_notificacao. Aqui não é necessário gerar um novo data frame, você pode simplesmente passar, através de um pipe, o resultado para nrow() para contar o número de linhas. A saída é 0, o que mostra que não houve resultados sem vínculo - incrível!\n\nanti_join(dados_lab_casos, dados_notif, \n          by = \"id_notificacao\") |&gt; nrow()\n\n[1] 0\n\n\nFinalmente, para verificar o número de notificações sem um resultado, você pode efetuar um anti_join ao colocar dados_notif primeiro:\n\nanti_join(dados_notif, dados_lab_casos, \n          by = \"id_notificacao\") |&gt; nrow()\n\n[1] 129\n\n\nOu, pode simplesmente tabular o número de valores em falta na coluna resultado em dados_vinculados (já que a coluna resultado provém dos dados laboratoriais).\n\ntabyl(is.na(dados_vinculados$resultado)) \n\n is.na(dados_vinculados$resultado)   n   percent\n                             FALSE 858 0.8693009\n                              TRUE 129 0.1306991\n\n\nAmbas as abordagens mostram que 129 casos suspeitos não têm um resultado de exame laboratorial.\n\n\n\n\n\n\n\n\n\nUtilize mutate() para criar uma nova coluna categoria_caso atualizando o rótulo dos casos suspeitos de acordo com o seu resultado laboratorial. As categorias devem ser as seguintes:\n\nSe o resultado for positivo: Confirmado\nSe o resultado for negativo: Descartado\nSe o resultado for indeterminado ou inexistente: Suspeito\n\nIsto significa que todos os casos nos dados de notificação são inicialmente suspeitos quando notificados, e permanecem suspeitos se não houver um resultado conclusivo no exame.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual é a função mais apropriada para criar essa nova coluna?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nVocê deve utilizar o case_when() para criar a nova coluna. Esta função é ideal para aplicar múltiplas condições lógicas para criar múltiplos valores, enquanto que case_match() é melhor para substituir valores específicos, e if_else() é melhor se houver apenas dois valores possíveis.\n\ndados_vinculados &lt;- dados_vinculados |&gt; \n  mutate(categoria_caso = case_when(resultado==\"Positivo\" ~ \"Confirmado\",\n                                   resultado==\"Negativo\" ~ \"Descartado\",\n                                   resultado==\"Indeterminado\" | is.na(resultado) ~ \"Suspeito\"))\n\n\n\n\n\n\n\n\n\n\nUtilizar tabyl() em geral, e também a tabulação cruzada por doença para responder às perguntas abaixo.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuantos casos nos dados de notificação vinculados não possuem um resultado positivo ou negativo?\n\n 202 347 250\n\nQue porcentagem dos casos nos dados de notificação POSSUEM um resultado positivo ou negativo?\n\n 60.1% 79.5% 92.2%\n\nPor que existem mais casos suspeitos remanescentes do que notificações sem vinculação?\n\n Casos suspeitos incluem notificações sem um resulado laboratorial e com um resultado indeterminado Existem casos suspeitos adicionais sendo trazidos dos laboratórios Existe algum problema com os dados\n\nQuais doenças possuíram a maior porcentagem de casos que permaneceram suspeitos após a vinculação?\n\n Cólera Malária Dengue Febre amarela\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nMais uma vez, você pode utilizar tabyl() para ver a distribuição das categorias de casos pelas notificações. O número total de casos suspeitos, ou seja, os que não têm qualquer resultado laboratorial ou têm um resultado indeterminado, é de 202. Isto significa que 785 casos, ou seja, 79,5%, tiveram um resultado laboratorial definitivo.\n\ntabyl(dados_vinculados, categoria_caso) \n\n categoria_caso   n   percent\n     Confirmado 438 0.4437690\n     Descartado 347 0.3515704\n       Suspeito 202 0.2046606\n\n\nPode também fazer uma tabela cruzada dos resultados originais (indeterminado/negativo/positivo) na coluna resultado com os novos resultados categoria_caso, primeiro para verificar se a sua lógica funcionou, e para ver como os valores originais se relacionam com os valores da nova coluna. Isto mostra que, além das 129 notificações que não foram vinculadas (com NA na coluna resultado), 73 tiveram resultados indeterminados, e assim foram classificadas como casos suspeitos.\n\ntabyl(dados_vinculados, categoria_caso, resultado) \n\n categoria_caso Indeterminado Negativo Positivo NA_\n     Confirmado             0        0      438   0\n     Descartado             0      347        0   0\n       Suspeito            73        0        0 129\n\n\nFinalmente, você pode também fazer uma tabela cruzada com o nome da doença para ver as categorias de casos por doença. Adicione adorn_xxx() para formatar as porcentagens. A tabela mostra que 22% dos casos de febre amarela permaneceram suspeitos, e que essa porcentagem foi a mais elevada em comparação com as outras doenças.\n\ntabyl(dados_vinculados, doenca_notificada, categoria_caso) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n doenca_notificada  Confirmado  Descartado    Suspeito        Total\n            colera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n            dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n     febre amarela 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n     febre tifoide 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n           malaria 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n             Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilize tabyl() mais uma vez para esta tarefa, analisando os resultados por doença. Pense no denominador correto!\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQue porcentagem de casos suspeitos repotados em em 2024 eram casos verdadeiros, de acordo com os resultados dos exames?\n\n 44% 56% 59%\n\nQue porcentagem dos casos suspeitos de malária eram realmente malária?\n\n 86% 41% 23%\n\nQue porcentagem de casos suspeitos de dengue eram realmente dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nClique para ler uma dica\n\n\n\n\n\nDividir o número de casos confirmados (ou seja, aqueles com um resultado positivo) pelo número de casos confirmados e descartados (ou seja, aqueles com um resultado positivo ou negativo). Obtém-se assim uma taxa de positivos, que se aproxima da porcentagem de casos suspeitos que eram efetivamente casos. Os resultados indeterminados são excluídos porque não fornecem um resultado claro e distorceriam a taxa de positivos.\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nFiltre os casos suspeitos e, em seguida, faça uma tabela cruzada para ver a porcentagem de casos originalmente suspeitos que foram confirmados ou descartados, entre aqueles com resultados de exame válidos.\nUma vez que existe uma linha de totais, pode ver-se que 56% dos casos suspeitos em geral foram confirmados, entre os que tinham um resultado válido. Também se pode ver que 41% e 87% dos casos de malária e dengue, respetivamente, foram confirmados.\n\ndados_vinculados |&gt; \n  filter(categoria_caso != \"Suspeito\") |&gt; \n  tabyl(doenca_notificada, categoria_caso) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n doenca_notificada  Confirmado  Descartado        Total\n            colera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n            dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n     febre amarela 42.3%  (33) 57.7%  (45) 100.0%  (78)\n     febre tifoide 22.6%   (7) 77.4%  (24) 100.0%  (31)\n           malaria 41.3% (174) 58.7% (247) 100.0% (421)\n             Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTarefa A: Criar uma nova lista de casos chamada dados_vinculados_confirmados.\nEsta é a que você utilizará nos relatórios oficiais de vigilância.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nPor que estamos optando por relatar apenas casos confirmados em nossos dados de vigilância?\n\n Relatar casos confirmados pode ser mais confiável e preciso quando a porcentagem de resultados positivos é baixa e os exames laboratoriais são rotineiros, ajudando assim a evitar a superestimação da carga da doença Relatar casos confirmados é mais lento, o que nos dá mais tempo para ter certeza do que estamos relatando Porque queremos esconder o número real de casos\n\nQual função é importante para criar a nova lista de linhas (linelist)?\n\n filter() arrange() mutate()\n\nQuantas linhas há neste novo data frame?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nA sua unidade de vigilância quer concentrar-se em notificar os casos confirmados. Isto deve-se ao fato de os exames laboratoriais serem rotina em Feveria, tendo em vista que a notificação de casos suspeitos seria desnecessariamente imprecisa, com uma elevada porcentagem de casos suspeitos sendo descartados.\nA decisão de publicar casos suspeitos pode ser diferente em outros contextos. Por exemplo, se a taxa de positivos for elevada (a maioria dos casos são casos confirmados se examinados) e os exames em si não forem comuns, ou se os exames demorarem muito tempo e resultarem numa notificação tardia, isso sugeriria que as tendências de casos suspeitos são suficientemente precisas e também mais oportunas do que esperar pela confirmação laboratorial.\nCriar a nova lista de casos com a função filter():\ndados_vinculados_confirmados &lt;- dados_vinculados |&gt; \n  filter(categoria_caso==\"Confirmado\")\nE verifique o número de linhas consultando as informações no seu ambiente ou com nrow():\nnrow(dados_vinculados_confirmados)\n[1] 438"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#passo-7.-análise-descritiva-dos-casos-confirmados",
    "href": "pages/multidisease_surveillance.pt.html#passo-7.-análise-descritiva-dos-casos-confirmados",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Agora que você tem sua lista de casos confirmados de doenças de notificação compulsória registrados em Feveria em 2024, você está pronto para conduzir a parte final da sua análise de vigilância! Especificamente, isso significa resumir as cinco doenças de notificação compulsória por área geográfica e tempo.\nDica: Normalmente, a análise de vigilância incluiria também uma análise por pessoa. Você pode expandir este estudo de caso, analisando também por variáveis demográficas.\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQual doença de notificação compulsória foi mais comumente relatada em 2024, quando restringimos apenas os casos confirmados?\n\n Dengue Malária Febre Amarela\n\nPor que a doença mais notificada muda quando olhamos os casos confirmados e suspeitos?\n\n A sensibilidade e especificidade do diagnóstico clínico pode variar por doença O desempenho dos exames utilizados nos laboratórios pode variar por doença Pode existir vieses de notificação Todas as opções acima!\n\nQual distrito relatou o maior número de casos confirmados de cólera em 2024?\n\n Lago Minara Feveria Central Kasara\n\nQuantos casos confirmados de cólera relatados em 2024 foram entre moradores de Feveria Central?\n\n 35 42 4\n\nQual distrito relatou mais casos confirmados de malária em 2024?\n\n Lago Minara Feveria Central Kasara\n\nEstes dados confirmam que a dengue é a doença infecciosa mais comum em Feveria?\n\n Não - uma doença diferente pode estar sendo subnotificada e/ou não ser de notificação compulsória Sim - se é a mais notificada então deve ser a mais comum\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que a dengue foi a doença mais frequentemente notificada em Feveria em 2024 quando consideramos apenas os casos confirmados, com 186 casos.\n\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada) \n\n doenca_notificada   n    percent\n            colera  38 0.08675799\n            dengue 186 0.42465753\n     febre amarela  33 0.07534247\n     febre tifoide   7 0.01598174\n           malaria 174 0.39726027\n\n\nNote que isto é diferente dos casos suspeitos, em que a malária foi a doença mais notificada (com 533 casos suspeitos)! Isto foi sugerido anteriormente, quando se viu que a taxa de positivos para casos suspeitos de dengue era mais elevada do que para casos suspeitos de malária. Isto pode dever-se a diferentes razões, por exemplo, o método de diagnóstico clínico utilizado para a malária pode ser menos específico (então muitos dos casos suspeitos são, na realidade, outras doenças), ou o exame utilizado para a dengue pode ser mais sensível.\nPara fazer uma tabela cruzada com o distrito de residência, adicione as funções adorn_xxx() relevantes.\n\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada, distrito_de_residencia) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n doenca_notificada Feveria Central     Kasara Lago Minara        Total\n            colera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n            dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n     febre amarela       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n     febre tifoide      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n           malaria      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n             Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nTal como acontece com os casos suspeitos, podemos ver que a maioria dos casos confirmados de dengue, malária e febre amarela se localizaram em Lago Minara - a zona do lago com maior densidade de mosquitos e, por conseguinte, de doenças transmitidas por vetores. A maioria dos casos confirmados de cólera e febre tifoide registou-se em Feveria Central, onde existem problemas de água e saneamento.\nOs dados sugerem que as doenças transmitidas por vetores (dengue e malária) constituem uma preocupação especial neste país tropical. No entanto, não sabemos ao certo qual é a doença mais comum e quais são os padrões subjacentes - apenas cinco doenças são de notificação compulsória e, normalmente, os casos notificados representam apenas uma fração dos casos reais na comunidade.\n\n\n\n\n\n\n\nVocê irá trabalhar na construção desta curva epidêmica, ao longo das várias tarefas abaixo.\n\n\n\n\n\n\n\n\n\n\n\nCertifique-se de especificar o argumento binwidth=7 para que cada barra no histograma represente o número de casos dentro de um período de 7 dias.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuando foi notificado o primeiro caso de febre tifoide em Feveria em 2024?\n\n Janeiro de 2024 Maio de 2024 Outubro de 2024\n\nDe acordo com este gráfico, qual foi o maior número de casos de dengue notificados em uma única semana em 2024?\n\n 10 20 30 É muito difícil responder isto a partir do gráfico empilhado!\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está um código simples para construir a curva epidêmica. Note que ainda não está controlando as cores, nem especificando em que dia da semana começa cada período de 7 dias.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = doenca_notificada)), binwidth=7)\n\n\n\n\n\n\n\n\nConsulte o capítulo sobre datas do Manual de R para Epidemiologistas caso queira uma formatação de data mais específica, por exemplo, de modo que cada barra represente uma semana de segunda a domingo, ou o eixo x indique o número da semana (semanas 1 - 52).\nImportante - não é simples visualizar as tendências por doença quando os dados estão empilhados dessa forma! Para ver essas tendências temporais, você deve produzir um histograma para cada doença.\n\n\n\n\n\n\nUtilize facet_wrap() para criar facilmente vários mini-plots, um por doença. Para entender isto melhor, você pode consultar a seção seção de facetas do capítulo sobre ggplot2 no Manual de R para Epidemiologistas\n\n\n\n\n\n\nPerguntas\n\n\n\n\nDe acordo com este gráfico facetado, qual foi o maior número de casos de dengue notificados em uma mesma semana em 2024?\n\n 11 15 29 Ainda não consigo responder!\n\nDentre os casos de dengue notificados naquela semana, em que distrito moravam?\n\n Todos os três distritos Feveria Central Kasara Lago Minara Este gráfico não mostra esta informação\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgora você pode ver uma curva epidêmica por doença! E pode ver que, durante uma semana de julho, foram notificados 15 casos de dengue. No entanto, este gráfico ainda não apresenta qualquer informação geográfica.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao)), binwidth=7) + \n  facet_wrap(.~doenca_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nDentre os 15 casos de dengue notificados na mesma semana de julho de 2024, em que distritos moravam?\n\n Todos os três distritos Feveria Central Kasara Lago Minara\n\nEm qual distrito foi notificado o primeiro caso de febre tifoide de 2024?\n\n Kasara Feveria Central Lago Minara Ainda não consigo responder!\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgora você pode ver uma curva epidêmica por doença, com a coloração refletindo o distrito de residência de onde é o caso\nPode-se ver que entre os 15 casos de dengue notificados na mesma semana, estes residiam em três distritos diferentes. Você também pode ver que o primeiro caso de febre tifoide foi notificado em Feveria Central.\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) + \n  facet_wrap(.~doenca_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVocê pode especificar:\n\nO tema/aparência geral do gráfico (por exemplo, cor de fundo, aparência das linhas de grade)\nO título e os rótulos\nAs cores das barras (com scale_fill_manual())\nA formatação e o espaçamento das datas ao longo do eixo x (com scale_x_date)\nMuitas outras coisas!\n\n\n\n\n\n\n\nPerguntas\n\n\n\n\nA cólera e a febre tifoide aparentam ser endêmicas?\n\n Não - os dados sugerem pequenos surtos ocasionais Sim, ambas são endêmicas\n\nHouve alguma época específica do ano em que a malária atingiu o pico em 2024?\n\n Sim - por volta de novembro/dezembro Sim - por volta de julho/agosto (verão) Não, é consistentemente alta\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAqui está o código totalmente formatado. Observe que algumas outras alterações incluem especificar que queremos apenas duas colunas de mini gráficos dentro do facet_wrap() e que a etiqueta de data ao longo do eixo x deve apenas mostrar o dia e o mês (não o ano, uma vez que todos os casos são em 2024).\n\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) +\n  facet_wrap(.~doenca_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito de residência\",\n       x = \"Data comunicada pela clínica\",\n       y = \"Contagem\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, malária, febre tifoide e febre amarela por semana em Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nTambém podemos ver na curva epidêmica que a cólera e a febre tifoide parecem estar ocorrendo como surtos isolados, em vez de mostrarem endemicidade. No entanto, a malária e a dengue estiveram presentes em Feveria durante todo o ano, com a malária atingindo um pico mais evidente nos meses de verão.\n\n\n\n\n\n\nDesta vez, utilize group_by() e summarize() para produzir uma tabela por distrito com as datas mais antigas e mais recentes dos relatórios.\nVocê pode modificar a sua tabela com um filter() para criar esta tabela para um distrito de cada vez.\n\n\n\n\n\n\nPerguntas\n\n\n\n\nQuando foi notificado o primeiro caso de dengue de 2024 em Feveria?\n\n 18 de janeiro de 2024 17 de janeiro de 2024 12 de fevereiro de 2024\n\nQuando foi notificado o último caso de dengue em Feveria Central de 2024?\n\n 22 de agosto de 2024 18 de novembro de 2024 25 de dezembro de 2024\n\n\n\n\n\n\n\n\n\n\nClique para ver a solução (tente sozinho primeiro!)\n\n\n\n\n\nAgrupe os dados por doença e, em seguida, resuma a primeira e a última data para ver a cronologia geral de cada doença em Feveria.\n\ndados_vinculados_confirmados |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  doenca_notificada primeira_notificacao ultima_notificacao\n  &lt;chr&gt;             &lt;date&gt;               &lt;date&gt;            \n1 colera            2024-06-03           2024-09-23        \n2 dengue            2024-01-17           2024-11-18        \n3 febre amarela     2024-03-08           2024-08-23        \n4 febre tifoide     2024-05-02           2024-11-07        \n5 malaria           2024-01-08           2024-12-25        \n\n\nAdicione um filter() ao código para ver as datas da primeira e da última notificações no distrito em que está interessado.\n\ndados_vinculados_confirmados |&gt; \n  filter(distrito_de_residencia == \"Feveria Central\") |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  doenca_notificada primeira_notificacao ultima_notificacao\n  &lt;chr&gt;             &lt;date&gt;               &lt;date&gt;            \n1 colera            2024-06-03           2024-09-23        \n2 dengue            2024-01-29           2024-08-22        \n3 febre tifoide     2024-05-02           2024-11-07        \n4 malaria           2024-01-29           2024-12-17"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#conclusão",
    "href": "pages/multidisease_surveillance.pt.html#conclusão",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Uau! De acordo com os objetivos deste estudo de caso, você conseguiu fazer o seguinte:\n\nUtilizar funções-chave do R para limpar, remodelar e vincular data frames, além de criar novas colunas utilizando condições lógicas.\nPara orientar o processamento dos dados, você realizou inspeções e verificações de dados ao longo do caminho\nVocê conduziu uma análise descritiva detalhada para compreender os dados dos exames e notificações, antes e depois da vinculação. Em resposta às quatro perguntas iniciais do seu supervisor, você pode dizer:\n\nQuantos casos suspeitos das diferentes doenças de notificação compulsória foram notificados em 2024, e qual foi o mais comum? A malária foi a doença de notificação compulsória mais comum em Feveria em 2024, notificada através do sistema de vigilância de doenças de notificação compulsória: Foram notificados 533 casos suspeitos de malária, 273 casos suspeitos de dengue, 100 de febre amarela, 46 de cólera e 35 de febre tifoide.\nQual a porcentagem de casos acabaram sendo confirmados? Quase 80% dos casos notificáveis notificados em 2024 tinham um resultado de exame laboratorial no momento em que o conjunto de dados vinculados foi criado, com alguma variação por doença. No total, 56% dos casos notificados acabaram por ser confirmados, mas esta percentagem variou entre 23% para a febre tifoide (7 casos confirmados de 31 casos suspeitos com resultados de exames) e 95% para a cólera (38 casos confirmados de 40 casos suspeitos com resultados de exames). Além disso, a taxa de positivos foi mais elevada para a suspeita de dengue do que para a suspeita de malária (87% contra 41%).\nQuantos casos confirmados das diferentes doenças de notificação compulsória foram notificados em 2024 e qual foi o mais comum? Os casos confirmados seguiram uma tendência ligeiramente diferente da dos casos suspeitos: a infecção mais notificada foi a dengue, com 186 casos, seguida da malária (174), da cólera (38), da febre amarela (33) e da febre tifoide (7).\nComo é que os casos confirmados se distribuem geográfica e temporalmente em Feveria? Feveria registrou transmissão de dengue e malária ao longo do ano, com picos no verão, e concentrados no distrito de Lago Minara. Feveria também registrou surtos pequenos e pouco frequentes de doenças diarreicas, por exemplo, cólera e febre tifoide, particularmente na área urbana de Feveria Central, onde pode haver problemas com água e saneamento.\n\nPor último, você refletiu sobre a forma como os processos envolvidos nos sistemas de vigilância de doenças de notificação compulsória e nos exames laboratoriais, por exemplo, a transferência de dados entre clínicas e laboratórios, podem afetar a qualidade e a integridade dos dados e, como consequência, os seus resultados.\n\nHá muito mais potencial pela frente. Você pode explorar padrões de doença por idade ou sexo, calcular taxas de doença com dados populacionais e até analisar atrasos na notificação, examinando as diferentes datas nos seus conjuntos de dados.\nVocê construiu uma base sólida e está bem equipado para levar a sua análise para o nível seguinte. Continue firme - descobertas emocionantes o aguardam!\nPara saber mais, consulte os outros estudos de caso ou mergulhe no Manual de R para Epidemiologistas."
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#código-para-limpeza-e-análise-dos-dados",
    "href": "pages/multidisease_surveillance.pt.html#código-para-limpeza-e-análise-dos-dados",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Veja abaixo um script de todas as etapas de limpeza de dados e análises descritivas. Repare como as análises são combinadas no final ao invés de intercaladas entre os passos de limpeza. Esta é uma forma mais organizada de estruturar o seu script.\nPara simplificar, o código abaixo não inclui todas as inspeções e verificações realizadas ao longo do processo, mas você pode optar por criar uma seção específica para esses verificações.\nO início do seu script também deve trazer informações que ajudem o leitor a entender para que ele serve, além de comentários ao longo do código. Você mesmo vai agradecer por ter incluído esses comentários no futuro!\n\n\n\n\n\n\nCódigo para limpar e analisar dados de notificação e dados laboratoriais de Feveria, 2024\n\n\n\n\n\n\n# Código para limpar e analisar dados de notificação e dados laboratoriais de Feveria, 2024\n# Data:\n# Autor:\n\n# Instalar os pacotes ----------------------------------------------\n# Verificar se o pacote \"pacman\" está instalado\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Instala (se necessário) a partir do CRAN e carrega os pacotes a serem usados\npacman::p_load(\n  rio,        # importação de dados\n  skimr,      # visão geral dos dados\n  janitor,    # limpeza de dados e tabelas\n  lubridate,  # manipulação de datas\n  epikit,     # criação de categorias de idade\n  gtsummary,  # estatísticas descritivas, testes e regressão\n  apyramid,   # gráficos de pirâmides etárias\n  flextable,  # tabelas prontas para apresentação\n  naniar,     # análise de dados faltantes\n  remotes,    # instalação de pacotes para baixar dados\n  tidyverse   # manipulação e visualização de dados\n)\n\n# Importar os dados ------------------------------------------------\n\n# dados de notificação\ndados_notif_bruto &lt;- import(\"data/notificacoes_multidoencas.xlsx\")\n\n# Dados laboratoriais\ndados_lab_bruto &lt;- import(\"data/testes_multidoencas.csv\")\n\n# Limpar os dados de notificação -----------------------------------\ndados_notif &lt;- dados_notif_bruto |&gt; \n  clean_names() |&gt; \n  rename(data_notificacao = data_comunicada_pela_unidade_de_saude_comunidade) |&gt; \n  select(id_notificacao, distrito_de_residencia, doenca_notificada, data_notificacao) |&gt; \n  mutate(distrito_de_residencia = case_match(str_to_title(distrito_de_residencia),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(data_notificacao = ymd(data_notificacao)) \n\n\n# Limpar e consolidar os dados laboratoriais -----------------------\n# Padronizar valores\ndados_lab &lt;- dados_lab_bruto |&gt; \n  mutate(resultado = case_match(resultado, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\n# Criar base em nível de exame laboratorial\ndados_lab_testes &lt;- dados_lab |&gt; \n  filter(alvo != \"Dengue IgG\") |&gt; \n  group_by(id_amostra) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Criar base em nível de caso\ndados_lab_casos &lt;- dados_lab_testes |&gt; \n  group_by(id_notificacao) |&gt; \n  arrange(desc(resultado)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Vincular dados de notificação e dados laboratoriais --------------\ndados_vinculados &lt;- left_join(dados_notif, dados_lab_casos, by = \"id_notificacao\")\n\n# Limpar os dados --------------------------------------------------\ndados_vinculados &lt;- dados_vinculados |&gt; \n  mutate(categoria_caso = case_when(resultado==\"Positivo\" ~ \"Confirmado\",\n                                   resultado==\"Negativo\" ~ \"Descartado\",\n                                   resultado==\"Indeterminado\" | is.na(resultado) ~ \"Suspeito\"))\n\ndados_vinculados_confirmados &lt;- dados_vinculados |&gt; \n  filter(categoria_caso==\"Confirmado\")\n\n# ANÁLISE ----------------------------------------------------------\n# Número de casos suspeitos em Feveria\ntabyl(dados_notif, doenca_notificada)\n\n# Distribuição de casos suspeitos por distrito\ntabyl(dados_notif, doenca_notificada, distrito_de_residencia) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribuição de resultados por exames específicos\ntabyl(dados_lab_testes, exame, resultado) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição da categoria de caso, nos dados vinculados: todos os casos\ntabyl(dados_vinculados, categoria_caso) \n\n# Distribuição da categoria de caso por doença, nos dados vinculados: todos os casos\ntabyl(dados_vinculados, doenca_notificada, categoria_caso) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição da categoria de caso por doença, nos dados vinculados: apenas casos com um resultado válido\ndados_vinculados |&gt; \n    filter(categoria_caso != \"Suspeito\") |&gt; \n    tabyl(doenca_notificada, categoria_caso) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribuição de casos confirmados por distrito\ndados_vinculados_confirmados |&gt; \n  tabyl(doenca_notificada, distrito_de_residencia) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualizar casos confirmados ao longo do tempo\ndados_vinculados_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = data_notificacao, fill = distrito_de_residencia)), binwidth=7) +\n  facet_wrap(.~doenca_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito de residência\",\n       x = \"Data comunicada pela clínica\",\n       y = \"Contagem\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, malária, febre tifoide e febre amarela por semana em Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# Primeira e última notificações por doença\ndados_vinculados_confirmados |&gt; \n  group_by(doenca_notificada) |&gt; \n  summarize(primeira_notificacao = min(data_notificacao), \n            ultima_notificacao = max(data_notificacao)) |&gt;\n  ungroup()"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#informações-sobre-o-estudo-de-caso",
    "href": "pages/multidisease_surveillance.pt.html#informações-sobre-o-estudo-de-caso",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Autores originais: Paula Blomquist e Alanah Jansen, com apoio técnico fornecido pelo CDC Global Surveillance, Laboratory, and Data Systems Branch em colaboração com a TEPHINET.\nFonte de dados: Dados fictícios fornecidos pela Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nData\nAlterações efetuadas\nVersão\nAutor\n\n\n\n\nJulho de 2025\nPrimeiro rascunho\n1\nPaula Blomquist e Alanah Jansen, Applied Epi, com o apoio técnico do CDC Global Surveillance, Laboratory, and Data Systems Branch em colaboração com a TEPHINET\n\n\nAgosto de 2025\nTradução para o português\n1\nLucca Nielsen e Pedro Menezes"
  },
  {
    "objectID": "pages/multidisease_surveillance.pt.html#termos-de-uso",
    "href": "pages/multidisease_surveillance.pt.html#termos-de-uso",
    "title": "Ligação e análise de dados de notificação e de dados laboratoriais em R",
    "section": "",
    "text": "Aviso legal: A informação apresentada neste exercício e os arquivos de dados associados foram desenvolvidos para ajudar os alunos a atingir os objetivos de aprendizagem pretendidos. Os conteúdos são da responsabilidade do(s) autor(es) e não representam necessariamente as opiniões oficiais do CDC, do Departamento de Saúde e Serviços Humanos dos EUA ou da TEPHINET.\nLicença: Este estudo de caso está sob uma licença CC BY-NC-SA 4.0. Para mais informações sobre o compartilhamento e adaptação deste estudo de caso, consulte a escritura associada.\nFinanciamento Este estudo de caso foi 100% apoiado pelo Acordo de Cooperação número NU2HGH000044 financiado pelos Centros de Controle e Prevenção de Doenças (CDC) dos EUA."
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html",
    "href": "pages/multidisease_surveillance.fr.html",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Outil: R Complexité technique: Intermédiaire Complexité méthodologique: Basique\nConnaissances préalables requises: bases de R (Utilisation de Rstudio ; packages R, fonctions et arguments, utilisation de l’opérateur pipe) ainsi que les fonctions clés de tidyverse et de ggplots.\nSource: Applied Epi, avec le soutien technique du CDC Global Surveillance, Laboratory, and Data Systems Branch en collaboration avec TEPHINET.\nDurée estimée: 4 heures\n\n\n\nPour savoir comment utiliser nos études de cas, consultez notre site web Guide Pratique. Nous vous invitons à nous faire part de vos commentaires et suggestions à l’adresse contact@appliedepi.org. Vous pouvez également discuter de l’étude de cas ou de sujets associés sur le Forum communautaire d’Applied Epi.\n\n\nVous êtes un épidémiologiste travaillant au bureau national de surveillance de Feveria, un tout petit pays tropical. Le pays compte trois districts :\n\nFeveria Central: une zone urbaine surpeuplée, avec des infrastructures d’eau et d’assainissement parfois peu fiables.\nLac Minara: une région lacustre dotée de bonnes infrastructures, mais avec une forte présence de moustiques pendant les mois les plus chauds de l’année.\nKasara: une zone suburbaine de l’autre côté de Feveria Central.\n\nCarte des districts du pays Feveria\n\nNous sommes en janvier 2025, et votre supérieure hiérarchique souhaite que vous transfériez le traitement de routine des données sur les maladies à déclaration obligatoire d’Excel à R, et d’effectuer quelques analyses sur ces données. Elle souhaite connaître au minimum:\n\nCombien de cas suspects des différentes maladies à déclaration obligatoire ont été signalés en 2024, et quelle était la plus représentée ?\nParmi eux, quel était le pourcentage de cas confirmés ?\nCombien de cas confirmés des différentes maladies à déclaration obligatoire ont été signalés en 2024, et quelle était la plus représentée ?\nComment se répartissaient géographiquement et temporellement les cas confirmés dans la région de Feveria ?\n\nElle vous demande d’écrire le code pour importer, nettoyer, joindre et analyser les listes linéaires suivantes :\n\nDonnées de surveillance 2024 des maladies à déclaration obligatoire : Appelées également “données de notification”, il s’agit de données de surveillance sur cinq maladies à déclaration obligatoire signalées par les cliniques de Feveria : la dengue, le paludisme, le choléra, la fièvre typhoïde et la fièvre jaune. Il s’agit de cas suspects, basés sur les symptômes des patients. Les cliniciens saisissent chaque notification dans un système en ligne tous les jours de la semaine.\nDonnées 2024 sur les résultats des tests de laboratoire : Ces données sont issues des résultats des tests de laboratoire effectués par trois grands laboratoires de Feveria. Ces résultats concernent des échantillons prélevés sur les cas suspects de maladies à déclaration obligatoire enregistrés dans la première base de données ci-dessus.\n\nAllons-y !\n\n\n\nDans cette étude de cas, vous allez :\n\nUtiliser des fonctions essentielles de R pour nettoyer des données, remodeler des bases de données, fusionner différentes sources de données et créer de nouvelles colonnes à l’aide de conditions logiques pour préparer les données pour l’analyse.\nPasser en revue les données et effectuer des contrôles de leur qualité à plusieurs étapes du projet et comprendre l’importance de ces actions pour une analyse fiable.\nConduire des analyses descriptives de base pour comparer les tendances des maladies à partir de différentes sources de données, avant et après la jointure.\nInterpréter les différences de résultats selon les sources de données et comprendre comment elles reflètent la structure et la conception du système de surveillance dans son ensemble.\n\n\n\n\n\n\nCommencez par la mise en place d’un flux de travail reproductible et bien organisé. Ce processus facilitera le renouvellement de votre analyse chaque fois que cela sera nécessaire.\nTâches :\n\nCréation d’un un projet RStudio\nCréation d’une structure claire de sous-dossiers dans lesquels vous placerez votre code, vos données et vos résultats / sorties.\nCréation d’un script R, ou d’un fichier R Markdown si vous préférez. Assurez-vous que que le but du script, la date et l’auteur sont écrits sous forme de commentaires en haut du script.\nAdditionnel : Assurez-vous que votre langue de travail dans RStudio est appropriée (par ex. le français pour cet exercice)\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\n\nCréez un dossier dans lequel vous placerez tous les travaux de cette étude de cas. Par exemple, créez un dossier “Analyse_multi_maladies” sur le bureau de votre ordinateur. Créez votre projet RStudio dans ce dossier.\nNous suggérons de créer les sous-dossiers suivants : scripts (pour votre code), donnees (pour vos données), et resultats (pour vos résultats d’analyse).\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nCréez un dossier (par exemple “Analyse_multi_maladies” sur votre bureau) pour cet exercice. Pour créer un projet Rstudio dans votre nouveau dossier, cliquez sur l’icône New Project en haut à gauche de votre fenêtre R Studio (ou sur File puis New Project), puis surExisting Directory puis Browse pour sélectionner votre nouveau dossier. Pour plus d’informations, consultez la section Projets R du Epi R Handbook.\nOuvrez un nouveau script R en cliquant sur l’icône New File en haut à gauche de votre écran R Studio (ou sur File puis New File), puis R Script. Sauvegardez-le immédiatement à un endroit approprié, par exemple, dans le sous-dossier scripts de votre dossier de projet R.\nAu début de votre nouveau script R, écrivez sous forme de commentaires quelques informations essentielles telles que votre nom, le but du fichier et la date.\nLes paramètres R “locale” déterminent la langue et les paramètres régionaux utilisés pour les scripts R comme les formats de date et les traductions. Si vos paramètres régionaux sont différents de la langue que vous souhaitez utiliser pour votre rapport (par exemple, les paramètres anglophones au lieu des paramètres francophones), vous pouvez les remplacer par les francophones en exécutant la commande Sys.setlocale(\"LC_ALL\", \"French\"). Incluez cette commande dans votre script si nécessaire, ou ignorez-la si vos paramètres sont appropriés. Ceci est expliqué plus en détail dans le Guide pratique.\n\n\n\n\n\n\nDans votre script R, vous devez maintenant installer et charger les packages R nécessaires. Cela permet de s’assurer que les fonctions nécessaires sont disponibles pour votre analyse.\nVous aurez besoin des packages suivants : {rio} (pour l’importation des données),{skimr} (pour l’examen des données), {janitor} (pour le nettoyage des données), {lubridate} (pour le nettoyage des dates), {epikit} (pour des tâches liées à l’épidémiologie), {gtsummary} (pour les statistiques descriptives / les tests et régressions), {apyramid} (pour les pyramides des âges et des sexes), {flextable} (pour des tableaux prêts à être présentés), {naniar} (pour l’analyse des données manquantes), et {tidyverse} (pour la manipulation générale des données et autres tâches scientifiques).\nVous aurez également besoin du package{remotes} pour télécharger les données - ce que nous expliquerons dans la section sur le téléchargement.\nAlors que vous commencez, votre collègue expérimenté vous glisse : “J’ai entendu parler du package {pacman} pour facilement gérer l’instalation et le chargement des packages dans R”.\nÀ vous de jouer !\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez la fonction p_load() de pacman pour cette tâche. Vous fournissez à la fonction une liste de packages que vous souhaitez utiliser. La fonction effectuera deux étapes pour chaque package :\n\nVérifier si le package est installé sur votre ordinateur, et l’installer si nécessaire, puis\nCharger le package pour qu’il pour qu’il puisse être utilisé pendant cette session R.\n\nSi vous n’avez pas encore installé pacman, vous devrez d’abord l’installer de manière “traditionnelle”, à l’aide de la fonction install.packages().\nNotez que l’ordre des packages dans votre fonction p_load peut être important. Si deux packages possèdent une fonction avec un nom identique (par exemple select() dans le package MASS et select() dans tidyverse qui réalisent des tâches différentes), alors R utilisera la fonction du dernier package chargé. Pour donner la priorité aux fonctions de tidyverse, qui sont couramment utilisées pour la manipulation et la visualisation des données, chargez tidyverse en dernier.\n\n# Pour s'assurer que le package \"pacman\" est installé\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Installation (si nécessaire) depuis le CRAN et chargement des packages à utiliser\npacman::p_load(\n  rio,        # importation de données  \n  skimr,      # aperçu des données\n  janitor,    # nettoyage des données et tableaux descriptifs\n  lubridate,  # manipulation des dates\n  epikit,     # pour créer des catégories d'âge\n  gtsummary,  # statistiques descriptives, tests et régressions \n  apyramid,   # tracé de pyramides des âges \n  flextable,  # tableaux prêts à être présentés\n  naniar,     # analyse des données manquantes\n  remotes,    # pour installer le package permettant de télécharger les données\n  tidyverse   # gestion et visualisation des données\n)\n\n\n\n\n\n\n\n\n\n\nVotre bureau vous fournit deux fichiers pour votre analyse, tous deux contenant des données pour 2024 et mises à jour au 15 janvier 2025 :\n\nun ensemble de données de notification des maladies (“multi_maladies_notifications.xlsx”) avec l’information sur les cas de 5 centres de santé.\nUn ensemble de données au niveau des tests de laboratoire (“multi_maladies_tests.csv”) soumis par trois laboratoires effectuant des tests pour les cinq centres de santé.\n\nPour cette étude de cas, vous pouvez télécharger les données via le répertoire de données d’Applied Epi, auquel vous pouvez accéder grâce au package {appliedepidata}. Suivez les étapes suivantes :\n\nInstallez le package {appliedepidata} depuis GitHub à l’aide de la fonction install_github() du package {remotes} (que vous avez installé précédemment)\n\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nEnregistrez les deux ensembles de données dans un dossier spécifique à l’aide de la fonction save_data() de {appliedepidata} en exécutant le code ci-dessous. Dans l’exemple ci-dessous, les données sont enregistrées dans un sous-dossier donnees du dossier de projet RStudio. Notez que si vous ne spécifiez pas d’emplacement spécifique avec l’argument path de la fonction, une fenêtre s’ouvrira pour vous demander de sélectionner manuellement un dossier.\n\n\n# Téléchargement des deux fichiers de données en utilisant la fonction save_data()de appliedepidata\nappliedepidata::save_data(\"multi_maladies_tests\",\n                        path = \"donnees\")\n\nappliedepidata::save_data(\"multi_maladies_notifications\",\n                          path = \"donnees\")\n\n\n\n\nTrès bien ! Merci au bureau national et à Applied Epi ! Il est maintenant temps d’importer les données de ce dossier dans RStudio, afin de pouvoir les analyser.\n\n\nIdéalement, vous utiliserez la même fonction pour importer les deux ensembles de données, bien qu’un soit un fichier .csv et l’autre un fichier .xlsx. Notez qu’à l’avenir, nous dirons simplement “environnement” lorsque nous parlerons de la fenêtre environnement dans R Studio.\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nUtiliser la fonction import du package {rio}, qui peut reconnaître et importer différents types de fichiers. Elle remplace les fonctions d’importation qui sont spécifiques à un type de fichier, telles que read.csv() de {base} pour les fichiers .csv et read_excel() de {readxl} pour importer des fichiers .xlsx.\nPour en savoir plus sur les fonctions d’importation, lisez le chapitre Importer et exporter des données du Epi R Handbook.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nCi-dessous, nous utilisons la fonction d’importation pour importer les deux fichiers. Notez que nous assignons les données importées à deux objets, l’un appelé data_notif_brut et un autre appelé data_lab_brut. Nous ajoutons le suffixe “brut” pour distinguer ces données des versions nettoyées que nous créerons plus tard.\n\n# Importation des données\n\n# Données de notification\ndata_notif_brut &lt;- import(\"donnees/multi_maladies_notifications.xlsx\")\n\n# Données de labo\ndata_lab_brut &lt;- import(\"donnees/multi_maladies_tests.csv\")\n\n\n\n\n\n\n\n\n\nLes données sont là, il est maintenant temps de voir ce qu’elles racontent. Jetez un premier coup d’oeil à vos deux ensembles de données brutes pour en vérifier le contenu et la qualité.\n\n\n\n\nUtilisez skim() du package {skimr} package, ainsi que names(), ncol() et nrow() pour inspecter votre ensemble de données.\nskim() vous donne de nombreuses informations sur la structure et le contenu des données, et names() vous fournira les différents noms de colonnes des données. Les fonctions ncol() et nrow() renvoient le nombre de colonnes ou de lignes dans les données. Savez-vous ce qu’il faut mettre entre les parenthèses ?\nLe plus simple est de regarder dans l’environnement. Rappelez-vous que l’objet de votre environnement contenant les données de notification s’appelle data_notif_brut.\nCliquez sur la solution sous l’encart de questions si vous avez besoin d’aide.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien y a-t-il de colonnes dans les données de notification?\n\n 10 11 12 13\n\nLaquelle de ces colonnes n’apparait PAS dans les données?\n\n Date d'apparition Date signalée par l'établissement de santé/la communauté Date du résultat Date de test Date de naissance\n\nQuel est le nom de la / des colonne(s) permettant d’identifier chaque notification de cas?\n\n ID de notification Test ID Code de l'établissement de santé Combinaison de ID de notification et Sexe\n\nCombien y a-t-il de lignes dans les données de notification?\n\n 987 1314 950 778\n\nA quel type d’information n’avez vous PAS accès dans les données de notification?\n\n Le résultat du test de laboratoire Le district de résidence La date de naissance et le sexe La structure de santé où a eu lieu la notification L'issue de la maladie\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez skim() du package {skimr} pour obtenir un résumé de l’ensemble des données, et View() pour consulter directement l’ensemble de la base de données sous forme de tableur :\n\nskim(data_notif_brut)\n\nVous pouvez également utiliser names() pour imprimer uniquement les noms des colonnes. Par l’intermédiaire de skim() et names() vous aurez accès à différents type d’information, notamment : l’établissement de santé du cas, la date de naissance, le sexe, un indicateur de grossesse, le district de résidence, la date d’apparition et la date rapportée par la clinique, ainsi que des informations sur l’issue de la maladie.\nIl y a également ID de notification qui semble être un identifiant unique pour un cas, mais nous devrions vérifier les doublons avant d’en être sûrs.\nNotez qu’il n’y a AUCUN résultat de test dans ces données, car ces notifications proviennent des cliniques qui notifient les maladies à déclaration obligatoire sur la base de définitions de cas cliniques.\n\nnames(data_notif_brut)\n\n [1] \"Nom de l'unite d'organisation\"                           \n [2] \"Code de l'etablissement de sante\"                        \n [3] \"ID de notification\"                                      \n [4] \"Date de naissance\"                                       \n [5] \"Sexe\"                                                    \n [6] \"Enceinte\"                                                \n [7] \"District residentiel\"                                    \n [8] \"Maladie notifiee\"                                        \n [9] \"Date d'apparition\"                                       \n[10] \"Date signalee par l'etablissement de sante/la communaute\"\n[11] \"Resultat\"                                                \n[12] \"Date du resultat\"                                        \n\n\nUtilisez ncol() et nrow() pour imprimer le nombre de colonnes et de lignes, comme ceci :\n\nncol(data_notif_brut)\nnrow(data_notif_brut)\n\nCeci imprimera le nombre de colonnes et de lignes dans votre console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nPar ailleurs, si l’on examine l’environnement, on constate que le nombre d’observations (qui sont les mêmes que les lignes) et de colonnes sont à côté du nom de la base de données.\n\n\n\n\n\n\nUtilisez skim() du package {skimr} ou class() pour explorer les classes des colonnes.\nVous souvenez-vous de la façon de spécifier la colonne qui vous intéresse à l’intérieur de la fonction class() ? Vous pouvez également explorer les classes depuis l’environnement.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de colonnes dans l’ensemble de données de notification sont reconnues par R comme étant de classe date ?\n\n 0 2 4\n\nQuelle est la classe de la plupart des colonnes dans les données brutes de notification?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez utiliser class comme dans l’exemple ci-dessous. Le $ est un opérateur utilisé pour sélectionner une colonne spécifique de l’ensemble de données data_notif_brut.\nNotez l’utilisation d’apostrophes inversées (`) autour de Date de naissance parce que le nom de la colonne contient des espaces.\n\nclass(data_notif_brut$`Date de naissance`)\n\nPour consulter la classe via l’environnement, cliquez sur la flèche bleue à côté du nom de l’ensemble de données. Les noms des colonnes apparaissent, avec la classe à côté (par exemple, “chr” indique la classe texte / caractères).\nVous pouvez voir qu’aucune des colonnes qui devraient être des dates n’est reconnue comme telle. Au lieu de cela, elles sont reconnues comme des valeurs texte.\n\n\n\n\n\n\nUtiliser la fonction tabyl() pour inspecter les valeurs dans les colonnes qualitatives/catégorielles en spécifiant le nom de la base de données comme premier argument, et le nom de la colonne comme second argument.\nPar exemple, ce code renvoie le contenu de la colonne Sexe. La sortie montre que masculin et féminin sont sont orthographiés de manière incohérente dans les données. Cette colonne devra faire l’objet d’un nettoyage avant de pouvoir être analysée.\n\ntabyl(data_notif_brut, Sexe)\n\n     Sexe   n    percent valid_percent\n        F  47 0.04761905    0.05452436\n  FEMININ 146 0.14792300    0.16937355\n        M  40 0.04052685    0.04640371\n MASCULIN 172 0.17426545    0.19953596\n        f 154 0.15602837    0.17865429\n  feminin  98 0.09929078    0.11368910\n        m 119 0.12056738    0.13805104\n masculin  86 0.08713273    0.09976798\n     &lt;NA&gt; 125 0.12664640            NA\n\n\nPour analyser les données manquantes, vous pouvez utiliser la fonction miss_var_summary() du package {naniar} :\n\nmiss_var_summary(data_notif_brut)\n\n# A tibble: 12 × 3\n   variable                                                 n_miss pct_miss\n   &lt;chr&gt;                                                     &lt;int&gt;    &lt;num&gt;\n 1 Date d'apparition                                           691     70.0\n 2 Enceinte                                                    510     51.7\n 3 Resultat                                                    197     20.0\n 4 Date du resultat                                            197     20.0\n 5 Date de naissance                                           168     17.0\n 6 Sexe                                                        125     12.7\n 7 Nom de l'unite d'organisation                                 0      0  \n 8 Code de l'etablissement de sante                              0      0  \n 9 ID de notification                                            0      0  \n10 District residentiel                                          0      0  \n11 Maladie notifiee                                              0      0  \n12 Date signalee par l'etablissement de sante/la communaute      0      0  \n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nLes valeurs dans la colonne District résidentiel sont-elles standardisées ?\n\n Non, elles doivent être nettoyées Elles sont standardisées et prêtes à être utilisées dans l'analyse\n\nLes valeurs dans la colonne Maladie notifiee sont-elles normalisées ?\n\n Non, elles doivent être nettoyées Elles sont standardisées et prêtes à être utilisées dans l'analyse\n\nQu’est-ce que R reconnait comme une valeur manquante?\n\n Soit une absence de valeur, ou juste un espace ou un point Pas de valeur dans la cellule, représenté par NA Les mots Inconnu et Indéterminé\n\nSelon l’analyse des données manquantes, est-ce que la colonne Date d'apparition vous paraît exploitable et utile?\n\n Oui, il y a peu de données manquantes, elle est donc utile Assez peu, au vu de la proportion de données manquantes\n\nPourquoi certaines colonnes des données de notification peuvent présenter des orthographes différentes et des catégories non standardisées ?\n\n Un bot brouille les données afin qu'elles soient moins identifiables Chaque clinique peut utiliser un logiciel configuré de manière légèrement différente, ou utiliser des entrées en texte libre, ce qui entraîne des variations orthographiques Le logiciel du système de surveillance utilisé par les établissements cliniques comporte de nombreux bugs\n\nWhy might some columns in the notification data have high missingness?\n\n The clinician does not ask the patient the question during their consultation The patient might not know or want to share the answer The clinician might not have time to prioritise filling in that field in the data, even if they know the information All of the above, and many more reasons\n\nPourquoi certaines colonnes de données de notification peuvent présenter une proportion élevée de données manquantes ?\n\n Le clinicien ne pose pas la question au patient pendant la consultation Le patient peut ne pas connaître la réponse ou ne pas vouloir la partager Le clinicien peut ne pas avoir le temps de remplir ce champ dans les données, même s'il connaît l'information Toutes les raisons ci-dessus, et bien d'autres encore\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez la fonction tabyl() le résumé des valeurs de la colonne District residentiel. Là encore, le premier argument est le nom de l’ensemble de données et le deuxième argument est le nom de la colonne.\n\ntabyl(data_notif_brut, `District residentiel`)\n\n District residentiel   n    percent\n       Au bord du lac 125 0.12664640\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n           LAC MINARA 185 0.18743668\n           Lac Minara  68 0.06889564\n\n\nVous pouvez constater que chacun des trois emplacements (Feveria Central, Lac Minara et Kasara) sont orthographiés de différentes manières et en lettres majuscules ou minuscules. Il faudra faire le ménage si l’on veut analyser la distribution géographique des maladies à déclaration obligatoire.\nDe même, utilisez tabyl() résumer les valeurs contenues dans la colonne Maladie notifiee. Vous pouvez voir qu’elles sont écrites en toutes lettres de manière appropriée et cohérente, de sorte que vous pouvez déjà voir la distribution des maladie sans nettoyage supplémentaire.\n\ntabyl(data_notif_brut, `Maladie notifiee`)\n\n Maladie notifiee   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n     fievre jaune 100 0.10131712\n        paludisme 533 0.54002026\n         typhoide  35 0.03546099\n\n\nUne autre façon d’analyser les données manquantes est de résumer la sortie de la fonction is.na(). Dans l’exemple ci-dessous, la fonction is.na() évalue chaque cellule de la colonne Date d'apparition et renvoie TRUE pour pour les valeurs manquantes et FAUX pour les valeurs présentes.\nAppliquer tabyl() à cette série de TRUE/FALSE vous permet d’obtenir rapidement les effectifs et proportions de données manquantes dans cette colonne. N’oubliez pas que les valeurs comme un espace ou les mots “Inconnu” ou “Manquant” ne seront pas reconnues par R comme manquantes. R ne reconnaîtra que les cellules vides comme données manquantes, représentées par NA.\nPour Date d'apparition, vous pouvez voir que 70 % des cas n’ont pas de valeur, ce qui suggère que cette colonne n’est pas particulièrement utile pour analyser des tendances de maladies au fil du temps.\n\ntabyl(is.na(data_notif_brut$`Date d'apparition`))\n\n is.na(data_notif_brut$`Date d'apparition`)   n   percent\n                                      FALSE 296 0.2998987\n                                       TRUE 691 0.7001013\n\n\nLes données manquantes ou non standardisées peuvent être dues à de nombreuses raisons, notamment:\n\nla conception de l’outil de collecte de données (par exemple, si les questions sont obligatoires ou si elles utilisent du texte libre plutôt que des listes déroulantes),\nles processus et les normes en place (par exemple, des champs que le personnel a pour instruction de prioriser), et\nles facteurs contextuels (par exemple, si le personnel dispose de suffisamment de temps pour collecter les informations).\n\n\n\n\n\n\n\n\n\n\nComme pour les données de surveillance, utilisez skim(), ncol() et nrow()ou inspecter l’environnement pour inspecter les données de laboratoire.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle liste linéaire comporte le plus de colonnes : les données de surveillance ou les données de laboratoire ?\n\n Les données de laboratoire Les données de surveillance Elles ont le même nombre de colonnes\n\nQuelle liste linéaire comporte le plus de lignes ?\n\n Les données de laboratoire Les données de surveillance Elles ont le même nombre de lignes\n\nInspectez les données de laboratoire avec View(). Pour quelle raison les données de laboratoire pourraient avoir plus d’enregistrements ?\n\n Il peut y avoir plusieurs tests ou cibles analysées par échantillon Il y a de nombreux résultats de tests d'étalonnage dans les données Toutes les notifications n'ont pas encore reçu de résultats de tests\n\nLaquelle de ces informations ne figure PAS dans les données de laboratoire ?\n\n ID de notification ID d'échantillon Type de test Date de naissance Résultat du test\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nComme dans la section 3.1, vous pouvez utiliser skim() du package {skimr} pour examiner l’ensemble de données de laboratoire avec les résultats des tests. Vous verrez également les différents noms de colonnes de données, montrant que les données de laboratoire ne contiennent que des informations sur le test et non sur le patient. Elles contiennent toutefois un identifiant de notification, comme les données de notification.\n\nskim(data_lab_brut)\n\nUtiliser ncol() et nrow() pour imprimer le nombre de colonnes et de lignes, comme ceci :\n\nncol(data_lab_brut)\nnrow(data_lab_brut)\n\nLes nombres de colonnes et de lignes s’afficheront dans votre console, vous montrant que les données de laboratoire ont plus de lignes que les données de notification que vous avez inspectées plus tôt.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nIl y a souvent plus d’enregistrements dans les données de laboratoire que dans les données cliniques. Si vous inspectez les données avec View(data_lab_brut) et que vous cliquez ensuite sur la flèche en haut de la colonne id_notification pour les trier par ordre alphabétique, vous verrez que plusieurs lignes partagent le même numéro de notification. Cela peut se produire lorsque plusieurs cibles sont testées à partir du même échantillon (même ID d’échantillon), ou lorsqu’un cas est retesté (ce qui donne un numéro d’identification d’échantillon différent).\n\nView(data_lab_brut)\n\n\n\nnom_laboratoireid_notificationid_echantillondate_testtestciblevaleurHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nComme ci-dessus, utilisez les fonctionc class(), skim() ou tabyl(), ou explorer l’environnement, pour examiner vos colonnes en détail.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de colonnes dans les données de laboratoire sont reconnues par R comme étant des colonnes de date ?\n\n 0 1 2\n\nCombien de colonnes des données de laboratoire n’ont aucune donnée manquante ?\n\n 1 3 7 (toutes!)\n\nQuel test détecte plusieurs cibles (et comporte donc plusieurs lignes par échantillon) ?\n\n Paludisme Dengue Fièvre jaune Choléra Fièvre typhoïde\n\nCombien de valeurs de résultats de test possibles y a-t-il dans la colonne valeur ?\n\n 5 3 4\n\nQuel résultat ne semble PAS être possible pour le test de culture des selles qui détecte la bactérie V.cholerae ?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nLes données du laboratoire ont une colonne de date, reconnue par R comme une classe “IDate”. Il s’agit d’une classe de date utilisée par import() de {rio} lors de l’importation de fichiers csv. Comme la classe Date native de R, elle permet de trier par date et d’analyser les tendances dans le temps.\n\nclass(data_lab_brut$date_test)\n\n[1] \"IDate\" \"Date\" \n\n\nEn utilisant la fonction miss_var_summary() du package {naniar}, on réalise que toutes les colonnes des données de laboratoire sont complètes. Cela peut s’expliquer par le fait que les laboratoires utilisent des processus automatisés et qu’il y a donc beaucoup moins de risques d’erreur humaine.\n(Point important : Notez que dans la vie réelle, les données de laboratoire présenteraient probablement des problèmes aussi !)\n\nmiss_var_summary(data_lab_brut)\n\n# A tibble: 7 × 3\n  variable        n_miss pct_miss\n  &lt;chr&gt;            &lt;int&gt;    &lt;num&gt;\n1 nom_laboratoire      0        0\n2 id_notification      0        0\n3 id_echantillon       0        0\n4 date_test            0        0\n5 test                 0        0\n6 cible                0        0\n7 valeur               0        0\n\n\nPour connaître le nombre de cibles détectées par chaque test, vous pouvez croiser les colonnes test et cible avec tabyl(). Ecrivez les noms des colonnes dans la fonction comme deux arguments distincts (et donc séparés par une virgule). Le résultat montre que chaque test correspond clairement à une ou plusieurs cibles, et que seul le test de la dengue détecte plus d’une cible (IgG, IgM et NS.1).\nConseil : Essayez de modifier l’ordre des noms de colonnes dans tabyl() pour voir l’impact sur le tableau.\n\ntabyl(data_lab_brut, cible, test)\n\n                 cible Culture de selles Dengue NS1/IgG/IgM Hemoculture\n    Bacteries S. Typhi                 0                  0          33\n Bacteries V. cholerae                45                  0           0\n            Dengue IgG                 0                215           0\n            Dengue IgM                 0                215           0\n           Dengue NS.1                 0                215           0\n      Fievre jaune IgM                 0                  0           0\n            Plasmodium                 0                  0           0\n IgM ELISA Microscopie du sang total\n         0                         0\n         0                         0\n         0                         0\n         0                         0\n         0                         0\n        88                         0\n         0                       503\n\n\nEnfin, vous pouvez examiner les différentes valeurs des résultats du test dans la colonne valeur toujours à l’aide de la fonction tabyl(). Vous pouvez voir qu’il y a six résultats possibles, dont N pour négatif, P pour positif et I pour indéterminé. Seul le choléra ne présente aucun P, mais est le seul à présenter P01 et P0139, ce qui correspond à un résultat positif pour les sérogroupes O1 ou O139.\n\ntabyl(data_lab_brut, test, valeur)\n\n                      test  I   N   P PO1 PO139\n         Culture de selles  5   2   0  22    16\n        Dengue NS1/IgG/IgM  0 354 291   0     0\n               Hemoculture  2  24   7   0     0\n                 IgM ELISA 10  45  33   0     0\n Microscopie du sang total 56 257 190   0     0\n\n\n\n\n\n\n\n\n\n\nVous savez maintenant que les données de notification (data_notif_brut) contiennent des des informations sur les cas suspects, ainsi que des données démographiques de base (âge, sexe, grossesse, district de résidence), et des informations sur la date d’apparition des symptômes, la date de notification par l’établissement de santé, et l’issue. Certaines colonnes doivent être nettoyées avant de poursuivre l’analyse, en raison des variations dans l’orthographe des valeurs catégorielles et de certaines colonnes non reconnues comme des dates.\nVous allez maintenant commencer à écrire de plus longs morceaux de code pour nettoyer les données, à l’aide de plusieurs fonctions {dplyr} reliées à l’aide d’opérateurs “pipe” (qui ressemblent à ceci : |&gt;).\nNOTE SUR LES ‘PIPES’ : Les “pipes” vous permettent d’effectuer plusieurs opérations en une seule commande fluide, en “enchaînant” différentes fonctions. La sortie d’une fonction devient l’entrée de la suivante. Si vous avez besoin de plus d’informations sur les pipes, veuillez vous référer au chapitre du Epi R Handbook.\nNotez que cet exercice utilise le pipe de base (|&gt;) plutôt que le pipe magrittr (%&gt;%), car il est plus rapide et ne nécessite pas l’installation de packages. Utilisez le pipe magrittr si vous préférez.\n\n\n\n\nPour des raisons de qualité et de stockage des données, votre équipe vous recommande de créer une liste linéaire propre qui ne contienne que des informations sur l’identifiant unique, la localisation du cas, la maladie et la date de notification au système de surveillance.\nÉcrivez une commande R pour produire une nouvelle base de données propre appelée data_notif, en appliquant les étapes de nettoyage suivantes:\n\nRenommer les colonnes pour qu’elles soient plus facilement lisibles par la machine (supprimer les espaces et les majuscules) en utilisant clean_names() du package {janitor}.\nUtiliser la fonction rename() de {dplyr} pour que:\n\nle nom de la colonne avec la date à laquelle le cas a été signalé soit remplacé par un nom plus concis date_notif.\nle nom de la colonne d’identifiant de la notification soit plus concis (id_notification).\n\nSélectionnez les colonnes pertinentes pour l’analyse à l’aide de la fonction select() du package {dplyr}.\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nCommencez votre code par le nom du nouvel ensemble de données, l’opérateur d’assignation et le nom de l’objet contenant les données brutes. Ainsi le résultat du traitement des données brutes sera assigné à un nouvel objet appelé data_notif.\n\ndata_notif &lt;- data_notif_brut\n\nIl faudra ensuite construire la commande de nettoyage en ajoutant des fonctions supplémentaires, liées à l’aide d’un pipe. Cela vous permet d’effectuer plusieurs opérations en une seule commande fluide. Tout d’abord, vous utiliserez clean_names() pour normaliser tous les noms de colonnes. Il remplace automatiquement les espaces et les caractères spéciaux par des traits de soulignement (underscore), supprime les accents et les apostrophes, et convertit tous les caractères en minuscules, ce qui rend les noms de colonnes plus facile à utiliser. Vous pouvez ensuite utiliser rename() pour donner à une colonne un nouveau nom. Rappelez-vous que lorsque vous utilisez rename(), la colonne aura déjà reçu le nom issu de clean_names().\n\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(NOUVEAU_NOM = ANCIEN_NOM) |&gt; \n  select(VAR_NAMES)\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code permettant de nettoyer les noms de colonnes et de sélectionner les bonnes colonnes pour l’analyse :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif)\n\n\n\n\n\n\n\nVous savez déjà, grâce à l’inspection des données, que les valeurs de district ne sont pas normalisées.\nAjouter un mutate() pour nettoyer la colonne district_residentiel, afin de:\n\nNormaliser l’utilisation d’écriture minuscule / majuscule dans la colonne\nRemplacer la colonne district_residentiel existante par une colonne qui ne contient que les valeurs pour les districts : “Lac Minara”, “Feveria Central” et “Kasara”.\n\nConsultez l’indice pour savoir quelles fonctions vous pourriez utiliser.\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nEssayez d’utiliser str_to_title() du package {stringr} de façon à ce que la première lettre de chaque mot soit en majuscule et que toutes les autres lettres soient en minuscule. Vous pouvez également utiliser case_match() pour spécifier différentes fautes de frappe spécifiques. Comme pour l’utilisation de rename() après clean_names(), prenez en compte que la fonction str_to_title() a modifié les valeurs des données fournies à la fonctioncase_match().\nUtilisez le panneau d’aide (“Help”) de RStudio pour savoir comment utiliser ces fonctions. Par exemple, tapez ?case_match dans votre console pour obtenir la page d’aide. NOTE sur case_match() : il s’agit d’une fonction très utile pour remplacer ou corriger des valeurs, qui remplace la fonction recode().\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVotre code de nettoyage devrait maintenant ressembler à ceci :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = str_to_title(district_residentiel)) |&gt; \n  mutate(district_residentiel = case_match(district_residentiel,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\"))\n\nVous pouvez également directement insérer la fonction str_to_title() dans la fonction case_match() pour un code plus court, comme suit :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\"))\n\n\n\n\n\n\n\nLa colonne de la date de notification doit être transformée de manière à ce qu’elle soit reconnue comme une date dans R. Cela vous permettra d’analyser les tendances au fil du temps, y compris en utilisant un décompte par semaine ou par mois.\nExaminez les valeurs de la colonne date_notif. Ajoutez ensuite une ligne à votre code de nettoyage pour modifier date_notif en une classe de date.\nConnaître le format de date d’origine vous permettra d’utiliser la bonne fonction pour convertir la colonne en classe de date. Nous vous recommandons d’utiliser l’une des fonctions du package {lubridate} : soit ymd() (pour convertir les dates écrites sous la forme année-mois-jour), mdy() (pour les dates mois-jour-année), ou dmy() (pour les dates jour-mois-année). Ces fonctions reconnaîtront n’importe quelle façon d’écrire la date, à condition qu’elle soit organisée dans cet ordre. Par exemple “21 août 2025” (oui! oui! même en français) et “21-08-2024” seraient toutes deux reconnues par dmy().\n\n\n\n\n\n\nQuestions\n\n\n\n\nComment les dates sont-elles actuellement formatées ?\n\n jour-mois-année année-mois-jour mois-jour-année année-jour-mois\n\nQuelle fonction mutate() devez-vous utiliser pour convertir la colonne date_notif en une classe de date ?\n\n mutate(date_notif = ymd(date_notif)) mutate(date_notif = dmy(date_notif)) mutate(date_notif = mdy(date_notif))\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez utiliser la fonction head() pour afficher les six premières lignes de données de la colonne date_notif. Vous pouvez voir qu’elles sont écrites avec d’abord l’année, puis le mois, puis le jour.\n\nhead(data_notif$date_notif)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nVous pouvez utiliser la fonction ymd() à l’intérieur de mutate() pour convertir la classe de la colonne date_notif. Vous pouvez vérifier que la classe est correcte en utilisant la fonction class() par la suite.\nVotre code de nettoyage devrait maintenant ressembler à ceci :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\")) |&gt; \n  mutate(date_notif = ymd(date_notif)) \n\nEt vous pouvez vérifier la classe comme ceci :\n\nclass(data_notif$date_notif)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nVos collègues vous disent que chaque id_notification représente un cas suspect unique. Vous souhaitez maintenant créer une table pour vérifier s’il existe des doublons de id_notification sur plusieurs lignes de vos données.\n\n\n\n\n\n\nQuestions\n\n\n\n\nUne ligne dans les données de notification correspond-elle à un cas ?\n\n Oui Non\n\nAvez-vous besoin de dédupliquer vos données pour l’analyse épidémiologique des cas ?\n\n Oui Non\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nIl existe de nombreuses façons de procéder, mais essayez d’utiliser la fonction count() de {dplyr}. Elle créera un tableau qui comptera le nombre de lignes par valeur unique de la colonne que vous spécifiez dans la fonction. Ensuite, utiliser tabyl() pour examiner la distribution de ces effectifs.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nTout d’abord, il faut faire passer les données de surveillance dans la fonction count() en spécifiant à la fonction id_notification comme seul argument. Cela crée un tableau qui compte le nombre de lignes par valeur unique de id_notification, dans une nouvelle colonne n. Vous pouvez voir par exemple dans les premières lignes qu’il n’y a qu’une seule ligne pour chacune de ces 6 id_notification.\n\ndata_notif |&gt; \n  count(id_notification) \n\n\n\n  id_notification n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nEnsuite décrivez la nouvelle colonne n avec tabyl(), qui montrera qu’il n’y a qu’une ligne par id_notification. Cela signifie qu’une ligne correspond à un cas, et qu’aucune autre déduplication n’est nécessaire.\n\ndata_notif |&gt; \n  count(id_notification) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nVous pouvez maintenant procéder à une analyse descriptive des cas, puisque vos données sont propres et que vous savez qu’une ligne équivaut à un cas. Utilisez la fonction tabyl() pour réaliser les tâches suivantes.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle maladie a été la plus fréquemment diagnostiquée par les cliniques de Feveria en 2024 ?\n\n Choléra Paludisme Dengue Fièvre typhoïde Fièvre jaune\n\nQuelle maladie a été la moins fréquemment diagnostiquée par les cliniques de Feveria en 2024 ?\n\n Choléra Paludisme Dengue Fièvre typhoïde Fièvre jaune\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir qu’il y a eu 533 cas suspects de paludisme à Feveria en 2024, et seulement 35 cas suspects de fièvre typhoïde.\n\ntabyl(data_notif, maladie_notifiee)\n\n maladie_notifiee   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n     fievre jaune 100 0.10131712\n        paludisme 533 0.54002026\n         typhoide  35 0.03546099\n\n\n\n\n\n\n\n\nUtilisez tabyl() pour croiser les colonnes maladie et district de résidence.\nComplétez votre tableau en ajoutant diverses fonctions adorn du package {janitor}, pour afficher la distribution en pourcentage. Par exemple adorn_percentages(), adorn_pct_formatting() et adorn_ns().\nTapez le nom de la fonction après un ? dans votre console (par ex. ?adorn_ns) pour afficher les pages d’aide correspondantes. Vous pouvez également consulter la section à propos de {janitor} dans le Epi R Handbook pour plus d’explications sur les fonctions adorn_xxx().\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel district a signalé le plus grand nombre de maladies vectorielles en 2024 (paludisme, dengue, fièvre jaune) ?\n\n Lac Minara Feveria Central Kasara\n\nQuel district a signalé le plus grand nombre de maladies diarrhéiques en 2024 (choléra, fièvre typhoïde) ?\n\n Lac Minara Feveria Central Kasara\n\nQuels facteurs contribuent à l’augmentation des maladies diarrhéiques dans ce district spécifique (sélectionné dans la question précédente) ?\n\n Infrastructures d'approvisionnement en eau et d'assainissement peu fiables Surpopulation de moustiques Nous ne savons pas\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nVoici du code pour vous aider à démarrer. Il croise maladie_notifiee et district_residentiel avec tabyl(), puis en ajoutant adorn_percentages() convertit ces nombres en proportions avec de nombreuses décimales. Vous devrez ensuite rajouter adorn_pct_formatting() avec un autre pipe, pour convertir les proportions en pourcentages, et enfin adorn_ns() pour ajouter à nouveau les effectifs entre parenthèses. Notez que les fonctions adorn_xxx() doivent être appliquées dans un ordre spécifique !\n\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages()\n\nPour les facteurs contribuant à l’augmentation des maladies diarrhéiques, revenez au début de l’étude de cas, à la partie présentant les districts!\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utlisant tabyl(), nous pouvons constater que la plupart des cas suspects de dengue, de paludisme et de fièvre jaune étaient localisés dans le district de Lac Minara - la zone lacustre avec une forte densité de moustiques et donc de maladies à transmission vectorielle. Dans le même temps, la majorité des cas de choléra et de fièvre typhoïde se trouvait à Feveria Central, la zone urbaine surpeuplée souffrant de problèmes d’infrastructures d’approvisionnement en eau et d’assainissement entraînant un risque accru d’inondation et de contamination de l’eau potable par temps de pluie.\n\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n maladie_notifiee Feveria Central      Kasara  Lac Minara\n          cholera      91.3% (42)  8.7%   (4)  0.0%   (0)\n           dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n     fievre jaune      11.0% (11) 21.0%  (21) 68.0%  (68)\n        paludisme      13.7% (73) 19.9% (106) 66.4% (354)\n         typhoide      68.6% (24) 31.4%  (11)  0.0%   (0)\n\n\n\n\n\n\n\n\n\n\nLe travail effectué à l’étape 3 vous a permis de constater que les données de laboratoire ne contiennent que des données sur les tests et aucune information sur les patients. Les données sont déjà très propres, nous n’avons à standardiser qu’une seule colonne. Nous voudrons également traiter l’ensemble de données du laboratoire de manière à ce qu’il y ait une ligne par notification, afin de pouvoir le lier proprement à l’ensemble de données de notification.\n\n\n\n\nCréez un nouvel objet data_lab. Cela permettra une analyse et une interprétation des résultats plus simples.\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez case_match() pour transformer les différentes valeurs originales en “Positif”, “Négatif” ou “Indéterminé” :\n\ndata_lab &lt;- data_lab_brut |&gt; \n  mutate(valeur = case_match(valeur, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positif\",\n                            \"N\" ~ \"Négatif\",\n                            \"I\" ~ \"Indéterminé\"))\n\nVous pouvez ensuite vérifier que les nouvelles valeurs sont correctes en résumant et en comparant les valeurs de la base de données originale et de la base de données nettoyée. Assurez-vous d’avoir utilisé la lettre “O” et non le chiffre “0”!\n\ntabyl(data_lab_brut, valeur)\n\n valeur   n    percent\n      I  73 0.05555556\n      N 682 0.51902588\n      P 521 0.39649924\n    PO1  22 0.01674277\n  PO139  16 0.01217656\n\n\n\ntabyl(data_lab, valeur)\n\n      valeur   n    percent\n Indéterminé  73 0.05555556\n     Négatif 682 0.51902588\n     Positif 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nNous savons déjà que certains échantillons se retrouvent sur plusieurs lignes, et que c’est dû au test de la dengue qui a trois cibles, avec une ligne par pour le résultat de chaque cible.\nMaintenant, trouvez le nombre d’échantillons présentant plusieurs lignes.\nProcédez de la même manière que pour les données de notification, en utilisant l’objet data_lab: comptez d’abord le nombre de lignes par échantillon, puis créer un tableau montrant la distribution des nombres de lignes. Il faut garder à l’esprit que que chaque échantillon est identifié par un id_echantillon.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien d’échantillons (id_echantillon unique) sont répétés sur 3 lignes?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nTout d’abord, il faut faire passer (avec un pipe) les données du laboratoire à la fonction count() en donnant à la fonction id_echantillon comme seul argument. Cela crée un tableau qui compte le nombre de lignes par valeur unique de id_echantillon, affichée dans une nouvelle colonne n. Vous pouvez voir par exemple que le id_echantillon “000e8eee” est présent sur trois lignes, alors que le id_echantillon “001e1878” n’apparaît que sur une seule ligne.\n\ndata_lab |&gt; \n  count(id_echantillon) \n\n\n\n  id_echantillon n\n1       000e8eee 3\n2       001e1878 1\n3       005f39af 1\n4       00b30781 3\n5       00b56d18 1\n6       0110abcd 3\n\n\nPuis résumez la nouvelle colonne n avec tabyl().\n\ndata_lab |&gt; \n  count(id_echantillon) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nVous pouvez même vérifier que cela ne s’applique qu’au test de la dengue en en ajoutant la colonne test dans la commande. Vous pouvez voir que seul le test de la dengue comporte 3 lignes par échantillon.\n\ndata_lab |&gt; \n  count(test, id_echantillon) |&gt; \n  tabyl(test, n)\n\n                      test   1   3\n         Culture de selles  45   0\n        Dengue NS1/IgG/IgM   0 215\n               Hemoculture  33   0\n                 IgM ELISA  88   0\n Microscopie du sang total 503   0\n\n\n\n\n\n\n\n\nComme vous l’avez vu dans la section 3.2, votre test de dengue fournit des résultats pour trois cibles biologiques différentes : IgG, IgM et NS.1. Les résultats pour chacune de ces cibles peuvent être soit négatifs, soit positifs. Cependant, pour simplifier et consolider vos données, vous souhaitez attribuer une seule valeur “Négatif” ou “Positif” à chaque échantillon, pour indiquer si l’échantillon révélait une infection en cours.\n\n\ncibleNégatifPositifDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nVotre collègue Ben, qui travaille au laboratoire, vous conseille ce qui suit :\n\nUn échantillon peut être considéré comme positif si le NS.1 ou les IgM sont positifs (les deux pouvant représenter une infection aiguë).\nVous pouvez ignorer les IgG (parce qu’un résultat positif en l’absence de NS.1 ou d’IgM positifs indique une immunité après une infection passée résolue).\n\nVous devez maintenant consolider les résultats du test de la dengue en une ligne par test, avec une valeur unique de résultat. Utiliser filter(), arrange() et slice(), en veillant à ce que tout échantillon positif pour NS.1 ou IgM soit considéré comme positif pour la dengue. Créez un nouvel objet appelé data_lab_tests\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nEssayez d’appliquer ce qui suit pour consolider selon la recommandation de Ben :\n\nSupprimer les résultats IgG : filtrez les lignes où la cible est “IgG” à l’aide de filter() de {dplyr}.\nDonner la priorité aux résultats positifs pour les IgM/NS1 : Regroupez par id_echantillon et réorganisez les lignes avec arrange() afin que tout résultat “Positif” apparaisse en premier.\nFiltrer pour obtenir le résultat final : Ne conservez que la première ligne de chaque groupe en utilisant slice(1) pour obtenir le résultat global positif ou négatif de l’échantillon.\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour filtrer les résultats des IgG de la dengue, et ensuite consolider les résultats des tests à l’intérieur de chaque groupe de lignes ayant les mêmes id_echantillon, en donnant la priorité aux résultats positifs.\nVous devez utiliser desc à l’intérieur de arrange() car cela signifie que les résultats seront listés par ordre alphabétique DESCendant, ce qui signifie que “Positif” sera en haut pour chaque identifiant.\nAjoutez également la fonction ungroup() à la fin pour que les nouvelles données ne soient plus groupées, ce qui pourrait perturber les analyses ultérieures.\n\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(cible != \"Dengue IgG\") |&gt; \n  group_by(id_echantillon) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nVous pouvez alors vérifier que le nouvel objet data_lab_tests ne présente qu’une seule ligne par test, en utilisant la combinaison de count() et tabyl() comme vous l’avez fait pour la tâche A.\nCe tableau vous montre que tous les ID d’échantillons uniques ne sont présents que dans une seule ligne chacun :\n\ndata_lab_tests |&gt; \n  count(id_echantillon) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nMaintenant, vérifiez le nombre de tests par identifiant de notification dans vos nouvelles données consolidées.\nVous pouvez voir qu’il y a 26 lignes avec le même id_notification, mais seulement parmi les cas testés par microscopie du sang total pour le paludisme.\n\ndata_lab_tests |&gt; \n  count(test, id_notification) |&gt; \n  tabyl(test, n)\n\n                      test   1  2\n         Culture de selles  45  0\n        Dengue NS1/IgG/IgM 215  0\n               Hemoculture  33  0\n                 IgM ELISA  88  0\n Microscopie du sang total 451 26\n\n\nVous poursuivez vos recherches en examinant un exemple de cas avec le id_notification “043228”. Cela vous apprend que ce cas a été testé deux fois, avec deux échantillons différents, à une semaine d’intervalle. Le premier résultat était positif, et le second résultat était négatif.\n\ndata_lab_tests |&gt; \n  filter(id_notification == \"043228\")\n\n# A tibble: 2 × 7\n  nom_laboratoire   id_notification id_echantillon date_test  test  cible valeur\n  &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;          &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; \n1 Hopital universi… 043228          27c37cd8       2024-06-18 Micr… Plas… Posit…\n2 Hopital universi… 043228          d2271be0       2024-06-25 Micr… Plas… Négat…\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle affirmation concernant les données de laboratoire est correcte ?\n\n Tous les cas des différentes maladies sont retestés Certains cas de paludisme sont retestés Tous les cas de paludisme sont retestés\n\nAurez-vous besoin de dédupliquer les données de laboratoire pour les relier aux données de notification ?\n\n Oui, nous avons besoin d'une unique ligne représentant le résultat de laboratoire par notification Non, les données sont suffisamment dédupliquées\n\n\n\n\nSi vous avez répondu que vous devez dédupliquer, vous avez raison !\nDédupliquez vos données afin d’avoir une ligne par id_notification, en priorisant les résultats positifs, afin de pouvoir établir un lien avec les données de notification.\nPour ce faire, suivez un processus similaire à celui de la tâche B, en utilisant la base de données produite par la tâche B :\n\nRegrouper par id_notification\nClasser par valeur du résultat du test de manière à ce que les valeurs commençant par P soient listées dans la première ligne, suivies des N (Négatif), puis des I (Indéterminé).\nConservez ensuite la première ligne de chaque groupe de id_notificationen utilisant slice().\nPour finir, assignez le résultat à un nouvel objet appelé data_lab_cas.\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour dédupliquer les lignes à l’intérieur de chaque groupe de lignes avec un même id_notification en donnant la priorité aux résultats positifs. Une fois de plus, vous devez utiliser desc à l’intérieur dearrange(). Cela fonctionne parfaitement car l’ordre de priorité souhaité pour les résultats - positifs, puis négatifs, puis indéterminés - correspond à l’ordre alphabétique inversé (P vient à avant N, qui vient avant I, dans l’ordre alphabétique inversé).\nSi votre ordre de priorité était plus complexe ou ne correspondait pas à l’ordre alphabétique (par exemple, si “indéterminé” devait être placé avant “négatif”), vous devriez convertir la colonne de résultats en un facteur et fournir explicitement l’ordre souhaité de ses niveaux. N’oubliez pas de dégrouper à nouveau à la fin.\n\ndata_lab_cas &lt;- data_lab_tests |&gt; \n  group_by(id_notification) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nVous pouvez alors vérifier que le nouvel objet data_lab_cas n’a qu’une seule ligne par identifiant de notification, en utilisant la combinaison de count() et tabyl() comme dans la tâche A. Ce tableau vous montre que tous id_notification uniques sont ne sont présents que dans une seule ligne chacun:\n\ndata_lab_cas |&gt; \n  count(id_notification) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nNous disposons maintenant de deux objets que nous pouvons utiliser pour l’analyse des données de laboratoire : data_lab_tests et data_lab_cas.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel objet devez-vous utiliser pour analyser les tests ?\n\n data_lab_tests data_lab_cas Aucun des deux\n\nCombien de tests ont été effectués pour dépister le paludisme (par microscopie du sang total) ?\n\n 215 503 88 190\n\nQuel pourcentage de tests de dépistage du choléra (par culture de selles) s’est révélé positif ?\n\n 21% 11% 84% 87%\n\nQuel test a donné le pourcentage le plus élevé de résultats indéterminés ?\n\n IgM ELISA (pour la détection de la fièvre jaune) Culture de selles (pour la détection du choléra) Hémoculture (pour la détection de la fièvre typhoïde)\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir le nombre de résultats positifs, négatifs et indéterminés par test. Vous pouvez ajouter une série de adorn() pour afficher les pourcentages et les totaux.\n\ntabyl(data_lab_tests, test, valeur) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                      test Indéterminé     Négatif     Positif        Total\n         Culture de selles  11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n        Dengue NS1/IgG/IgM   0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n               Hemoculture   6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                 IgM ELISA  11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopie du sang total  11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle base de données de laboratoire devez-vous utiliser pour compter le nombre de cas suspects testés ?\n\n data_lab_brut data_lab_cas data_lab_tests data_lab\n\nCombien de cas suspects ont été testés dans les données de laboratoire de 2024 ?\n\n 858 1314 884\n\nY a-t-il plus de cas suspects dans les données de notification ou dans les données de laboratoire ?\n\n Données de notification Données de laboratoire\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez simplement regarder le nombre de lignes dans le fichier data_lab_cas pour connaître le nombre de cas suspects qui ont été testés.\n\nnrow(data_lab_cas)\n\n[1] 858\n\n\nCe nombre est inférieur au nombre de cas suspects figurant dans la base de données des maladies à déclaration obligatoire (data_notif); ce qui suggère qu’une partie seulement des cas suspect notifié en 2024 avait été testée au moment où ces données étaient rendues disponibles.\n\nnrow(data_notif)\n\n[1] 987\n\n\n\n\n\n\n\n\n\n\nMaintenant que les deux listes linéaires sont nettoyées et qu’elles comportent une ligne par cas suspect, vous pouvez les joindre pour permettre l’analyse complète demandée par votre patron.\n\n\n\n\nCréer un nouvel objet appelé data_jointes en utilisant une fonction xxx_join() de {dplyr}. Vous souhaitez conserver toutes les notifications, mais ajouter les résultats de tests lorsqu’ils sont disponibles pour chaque cas suspect.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle fonction permet la bonne approche si vous souhaitez conserver toutes les lignes de vos données de notification et intégrer les résultats de vos données de laboratoire ?\n\n left_join(data_notif, data_lab_cas… full_join(data_notif, data_lab_cas… right_join(data_notif, data_lab_cas…\n\nQuel identifiant doit être utilisé pour joindre les deux listes linéaires ?\n\n id_echantillon id_notification id_echantillon et date_notif id_notification et date_notif\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nReliez les données à l’aide de la fonction left_join() avec les données de notification comme ensemble de données principal à gauche. Toutes les lignes de cet ensemble de données seront conservées et seuls les résultats des tests provenant de l’ensemble de données de laboratoire renseigné à “droite” de la fonction seront ajoutés.\n\ndata_jointes &lt;- left_join(data_notif, data_lab_cas, \n                         by = \"id_notification\")\n\nVous créez la jointure avec la colonne id_notification qui est présente, complète et propre dans les deux base de données.\nNote: Vous avez de la chance de travailler avec un exemple de jointure aussi simple ! D’habitude, il faut vraiment nettoyer et vérifier la colonne d’identifiant, ou établir un lien avec d’autres colonnes comme le nom et la date de naissance. À Feveria, le personnel de la clinique est fantastique pour attribuer systématiquement des identifiants de notification à chaque patient, et de les renseigner sur les formulaires d’échantillon envoyés au laboratoire, et le personnel du laboratoire est tout aussi brillant pour enregistrer l’identifiant de notification dans leur système informatique afin que les résultats puissent être reliés au cas.\n\n\n\n\n\n\nVérifiez maintenant vos données et examinez quelques points.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de lignes contient votre nouvelle base de données data_jointes ?\n\n 987 884 858\n\nEt par rapport à vos données de notification d’origine ?\n\n plus de lignes que l'original même nombre de lignes moins de lignes\n\nQuel terme décrit le mieux la jointure que vous venez de réaliser?\n\n plusieurs-à-un un-à-un plusieurs-à-plusieurs\n\nCombien de résultats de laboratoire n’ont PAS été joints aux données de notification (indice : utilisez la fonction anti_join()) ?\n\n 30 19 0\n\nAvez-vous de la chance que votre jointure soit si réussi ?\n\n Quoi ? Toutes les jointures ne sont-ils pas aussi simples que cela ? Tout à fait ! En général, certains enregistrements ne trouvent pas de correspondance\n\nQuelles sont les raisons typiques pour lesquelles il n’y a pas de correspondance trouvé pour des données de laboratoire et des données sur les maladies à déclaration obligatoire ?\n\n Il y a des fautes de frappe dans les colonnes utilisées pour la correspondance, elles ne sont donc pas reconnues comme correspondant Les données de laboratoire peuvent contenir des cas supplémentaires provenant d'autres cliniques ou pays Les données de laboratoire peuvent inclure des échantillons de test Des notifications peuvent avoir été accidentellement omises dans les données de surveillance même si l'échantillon a été testé en laboratoire Toutes les réponses ci-dessus\n\nCombien de cas suspects n’ont pas de résultat ?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVérifiez le nombre de lignes dans chaque ensemble de données à l’aide de la fonction nrow() ou en vérifiant les informations relatives à l’objet dans votre environnement. Vous pouvez constater l’opération était une jointure un-à-un, car chaque ligne avait un id_notification unique, de sorte qu’une ligne dans les données de notification était directement liée à une ligne dans les données de laboratoire.\nNombre de lignes dans les données de notification\n\nnrow(data_notif)\n\n[1] 987\n\n\nNombre de lignes dans les données jointes\n\nnrow(data_jointes)\n\n[1] 987\n\n\nPour vérifier si des résultats de laboratoire n’ont pas été reliés à des données de notification, vous pouvez utiliser la fonction anti_join(). Cette fois, data_lab_cas est à gauche, car la fonction évalue le nombre de lignes de l’objet de gauche qui n’ont pas été trouvées dans l’ensemble de données de droite, en les faisant correspondre par id_notification. Ici, il n’est pas nécessaire de créer un nouvel objet, vous pouvez simplement faire passer le résultat à nrow() avec un pipe pour compter le nombre de lignes. Le résultat est 0, ce qui montre qu’il n’y a pas eu de résultats de labo non reliés - incroyable !\n\nanti_join(data_lab_cas, data_notif, \n          by = \"id_notification\") |&gt; nrow()\n\n[1] 0\n\n\nEnfin, pour vérifier le nombre de notifications sans résultat, vous pouvez soit réaliser un anti_join() en mettant data_notif d’abord :\n\nanti_join(data_notif, data_lab_cas, \n          by = \"id_notification\") |&gt; nrow()\n\n[1] 129\n\n\nOu vous pouvez aussi simplement évaluer le nombre de valeurs manquantes dans la colonne valeur dans data_jointes (puisque valeur provient des données de laboratoire).\n\ntabyl(is.na(data_jointes$valeur)) \n\n is.na(data_jointes$valeur)   n   percent\n                      FALSE 858 0.8693009\n                       TRUE 129 0.1306991\n\n\nCes deux approches montrent que 129 cas suspects ne présentent pas de résultat de laboratoire.\n\n\n\n\n\n\n\n\n\nUtiliser mutate() pour créer une nouvelle colonne cas_categorie, afin de mettre à jour le status de cas suspect en fonction de leurs résultats de laboratoire. Les catégories devraient être les suivantes :\n\nSi le résultat est positif : Confirmé\nSi le résultat est négatif : Ecarté\nSi le résultat est indéterminé ou manquant : Suspect\n\nCela signifie que tous les cas figurant dans les données de notification sont d’abord “Suspect” lorsqu’ils sont déclarés, puis restent “Suspect” en l’absence d’un résultat de test concluant.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle est la fonction la plus appropriée pour créer cette nouvelle colonne?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous devez utiliser case_when() pour créer la nouvelle colonne. Cette fonction est idéale pour appliquer plusieurs conditions logiques afin d’attribuer de multiples valeurs différentes, alors que case_match() est plus adapté pour remplacer des valeurs spécifiques, et if_else() est préférable s’il n’y a que deux valeurs possibles.\n\ndata_jointes &lt;- data_jointes |&gt; \n  mutate(cas_categorie = case_when(valeur==\"Positif\" ~ \"Confirmé\",\n                                   valeur==\"Négatif\" ~ \"Ecarté\",\n                                   valeur==\"Indéterminé\" | is.na(valeur) ~ \"Suspect\"))\n\n\n\n\n\n\n\n\n\n\nUtilisez tabyl() directement, et aussi en croisant avec les maladies pour répondre aux questions ci-dessous.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de cas dans les données de notification jointes n’ont pas de résultat positif ou négatif ?\n\n 202 347 250\n\nQuel pourcentage de cas dans les données de notification ONT un résultat positif ou négatif ?\n\n 60,1 % 79,5 % 92,2 %\n\nPourquoi y a-t-il plus de cas suspects restants que de notifications sans résultat de laboratoire relié?\n\n Les cas suspects comprennent les notifications sans résultat de laboratoire et avec un résultat de laboratoire indéterminé Il y a des cas suspects supplémentaires provenant du laboratoire Il y a un problème avec les données\n\nQuelle maladie présentait le pourcentage le plus élevé de cas restés suspects après la jointure?\n\n Choléra Paludisme Dengue Fièvre jaune\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUne fois de plus, vous pouvez utiliser tabyl() pour voir la répartition des catégories de cas entre les notifications. Le nombre total de cas suspects, c’est-à-dire ceux pour lesquels aucun résultat de laboratoire n’a été obtenu ou pour lesquels le résultat est indéterminé, est de 202. Cela signifie que 785 cas, soit 79,5 %, ont obtenu un résultat de laboratoire définitif.\n\ntabyl(data_jointes, cas_categorie) \n\n cas_categorie   n   percent\n      Confirmé 438 0.4437690\n        Ecarté 347 0.3515704\n       Suspect 202 0.2046606\n\n\nVous pouvez également croiser les résultats originaux (indéterminé/négatif/positif) de valeur avec la nouvelle colonne cas_categorie, pour vérifier que votre logique a fonctionné et pour voir comment les valeurs originales correspondent aux valeurs de la nouvelle colonne. Cela montre qu’en plus des 129 notifications qui n’ont pas été reliées à un résultat de test (avec NA dans la colonne valeur), 73 avaient des résultats indéterminés et ont donc été classées dans la catégorie des cas suspects.\n\ntabyl(data_jointes, cas_categorie, valeur) \n\n cas_categorie Indéterminé Négatif Positif NA_\n      Confirmé           0       0     438   0\n        Ecarté           0     347       0   0\n       Suspect          73       0       0 129\n\n\nEnfin, vous pouvez également croiser les catégories avec les noms de maladie pour voir les catégories de cas par maladie. Ajoutez des fonctions adorn_xxx() pour ajouter et mettre en forme des pourcentages. Le tableau montre ainsi que 22 % des cas de fièvre jaune sont restés suspects, ce qui représente le pourcentage le plus élevé par rapport aux autres maladies.\n\ntabyl(data_jointes, maladie_notifiee, cas_categorie) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n maladie_notifiee    Confirmé      Ecarté     Suspect        Total\n          cholera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n           dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n     fievre jaune 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n        paludisme 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n         typhoide 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n            Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilisez tabyl() à nouveau, en examinant les résultats par maladie. Réfléchissez au dénominateur adéquat !\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel pourcentage de cas suspects notifié en 2024 étaient de vrais cas selon leurs résultats de test?\n\n 44% 56% 59%\n\nQuel pourcentage de cas supects de paludisme étaient effectivement atteint de paludisme?\n\n 86% 41% 23%\n\nQuel pourcentage de cas supects de dengue étaient effectivement atteint de dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nDiviser le nombre de cas confirmés (c’est-à-dire ceux dont le résultat est positif) par le nombre de cas confirmés plus les cas écartés (c’est-à-dire ceux dont le résultat est soit positif, soit négatif). On obtient ainsi un taux de positivité, qui correspond approximativement au pourcentage de cas suspects qui étaient réellement des cas. Les résultats indéterminés sont exclus du dénominateur car ils ne fournissent pas de résultat clair et fausseraient le taux de positivité.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nFiltrez les cas toujours suspects, puis réalisez un tableau croisé pour connaître le pourcentage de cas initialement suspectés qui ont été ou confirmés ou écartés, parmi ceux dont les résultats de test sont valides.\nAvec la ligne de totaux, vous pouvez voir que 56 % des cas suspects ont été confirmés parmi ceux dont les résultats étaient valides. Vous pouvez également voir que 41 % et 87 % des cas de paludisme et de dengue, respectivement, ont été confirmés.\n\ndata_jointes |&gt; \n  filter(cas_categorie != \"Suspect\") |&gt; \n  tabyl(maladie_notifiee, cas_categorie) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n maladie_notifiee    Confirmé      Ecarté        Total\n          cholera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n           dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n     fievre jaune 42.3%  (33) 57.7%  (45) 100.0%  (78)\n        paludisme 41.3% (174) 58.7% (247) 100.0% (421)\n         typhoide 22.6%   (7) 77.4%  (24) 100.0%  (31)\n            Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTâche A : Créer une nouvelle liste linéaire appelée data_jointes_confirme.\nC’est ce que vous utiliserez dans les rapports de surveillance officiels.\n\n\n\n\n\n\nQuestions\n\n\n\n\nPourquoi choisissons-nous de ne signaler que les cas confirmés dans nos données de surveillance ?\n\n La déclaration des cas confirmés peut être plus fiable et précise lorsque le pourcentage de tests positifs est faible et que les tests en laboratoire sont systématiques, ce qui permet d'éviter une surestimation de la morbidité La déclaration des cas confirmés est plus lente, ce qui nous donne plus de temps pour nous assurer de l'exactitude de nos déclarations Parce que nous voulons cacher le nombre réel de cas\n\nQuelle fonction est importante pour créer la nouvelle liste linéaire ?\n\n filter() arrange() mutate()\n\nCombien de lignes contient ce nouvel ensemble de données ?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVotre équipe de surveillance souhaite se concentrer sur les cas confirmés dans ses rapports. En effet, les tests de laboratoire sont intégrés dans les activités de routine à Feveria, et la déclaration des cas suspects serait inutilement imprécise, un pourcentage élevé de cas suspects étant écartés.\nLa décision de publier les cas suspects peut être différente dans dans d’autres contextes. Par exemple, si le taux de positivité est élevé (la plupart des cas sont des cas réels s’ils sont testés) et que le test lui-même n’est pas courant, ou que le test prend beaucoup de temps et entraînerait un retard dans le rapportage, cela suggérerait que les tendances des cas suspects sont suffisamment précises et également plus opportunes que l’attente d’une confirmation en laboratoire.\nCréez la nouvelle liste linéaire à l’aide de la fonction filter() :\ndata_jointes_confirme &lt;- data_jointes |&gt; \n  filter(cas_categorie==\"Confirmé\")\nEt vérifiez le nombre de lignes en consultant les informations dans votre environnement, ou avec nrow():\nnrow(data_jointes_confirme)\n[1] 438\n\n\n\n\n\n\n\nMaintenant que vous disposez de la liste des cas confirmés de maladies à déclaration obligatoire signalés à Feveria en 2024, vous êtes prêt à effectuer la dernière partie de votre analyse de surveillance ! Il s’agit de décrire les cinq maladies à déclaration obligatoire par zone géographique et par période.\nConseil: L’analyse des données de surveillance comprend généralement une analyse par personne. Vous pourriez développer cette étude de cas en procédant à une analyse selon les variables démographiques.\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle maladie à déclaration obligatoire a été la plus souvent notifiée en 2024, en se limitant aux seuls cas confirmés ?\n\n Dengue Paludisme Fièvre jaune\n\nPourquoi la maladie la plus fréquemment signalée diffère-t-elle entre les cas confirmés et les cas suspects ?\n\n La sensibilité et la spécificité du diagnostic clinique peuvent varier selon la maladie Les performances des tests utilisés en laboratoire peuvent varier selon la maladie Il peut y avoir des biais de notification Toutes les réponses ci-dessus !\n\nQuel district a signalé le plus grand nombre de cas confirmés de choléra en 2024 ?\n\n Lac Minara Feveria Central Kasara\n\nCombien de cas confirmés de choléra signalés en 2024 concernaient des résidents de Feveria Central ?\n\n 35 42 4\n\nQuel district a signalé le plus grand nombre de cas confirmés de paludisme en 2024 ?\n\n Lac Minara Feveria Central Kasara\n\nCes données confirment-elles que la dengue est la maladie infectieuse la plus courante à Feveria ?\n\n Non, une autre maladie peut être sous-déclarée et/ou non systématiquement notifiée Oui, si c'est la maladie la plus notifiée, c'est qu'elle doit être la plus courante\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir que la dengue était la maladie la plus fréquemment notifiée à Feveria en 2024, en se limitant aux cas confirmés, avec 186 cas.\n\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee) \n\n maladie_notifiee   n    percent\n          cholera  38 0.08675799\n           dengue 186 0.42465753\n     fievre jaune  33 0.07534247\n        paludisme 174 0.39726027\n         typhoide   7 0.01598174\n\n\nNotez que cela diffère des cas suspects, où le paludisme a été le plus notifié (avec 533 cas suspects) ! Il y avait déjà des indices, avec un taux de positivité pour les cas suspects de dengue plus élevé que pour les cas suspects de paludisme. Cela peut s’expliquer par différentes raisons, par exemple la méthode de diagnostic clinique utilisée pour le paludisme peut être moins spécifique (de nombreux cas suspects sont en fait d’autres maladies), ou le test utilisé pour la dengue peut être plus sensible.\nCroisez les données avec celles du district résidentiel, puis ajoutez les fonctions adorn_xxx() pertinentes.\n\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee, district_residentiel) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n maladie_notifiee Feveria Central     Kasara  Lac Minara        Total\n          cholera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n           dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n     fievre jaune       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n        paludisme      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n         typhoide      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n            Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nComme pour les cas suspects, on constate que la plupart des cas confirmés de dengue, de paludisme et de fièvre jaune se situent à Lac Minara, zone lacustre où la densité de moustiques et donc de maladies à transmission vectorielle est la plus élevée. La majorité des cas confirmés de choléra et de fièvre typhoïde se trouvaient à Feveria Central, sujet à des problèmes d’eau et d’assainissement.\nLes données suggèrent que les maladies à transmission vectorielle (dengue et paludisme) sont particulièrement préoccupantes dans ce pays tropical. Cependant, nous ne savons pas avec certitude quelle est la maladie la plus fréquente et quels sont les schémas sous-jacents - seules cinq maladies sont à déclaration obligatoire et les cas notifiés ne représentent généralement qu’une fraction des cas réels au sein de la communauté.\n\n\n\n\n\n\n\nVous allez travailler à la réalisation de cette courbe épidémique, à travers les tâches ci-dessous.\n\n\n\n\n\n\n\n\n\n\n\nVeillez à spécifier l’argument binwidth=7 afin que chaque barre de l’histogramme représente le nombre de cas sur une période de 7 jours.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuand a été notifié le premier cas de fièvre typhoïde de 2024 à Feveria?\n\n Janvier 2024 Mai 2024 Octobre 2024\n\nD’après ce graphique, quel a été le plus grand nombre de cas de dengue notifiés en une seule semaine en 2024?\n\n 10 20 30 Difficile à dire avec ce graphique empilé!\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici un code simple pour produire la courbe épidémique. Notez que vous ne contrôlez pas encore les couleurs, ni ne spécifiez le jour de la semaine où commence chaque période de 7 jours.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = maladie_notifiee)), binwidth=7)\n\n\n\n\n\n\n\n\nReportez-vous au chapitre sur les dates du Epi R Handbook si vous souhaitez réaliser un formatage plus spécifique des dates, par exemple pour que chaque barre représente une semaine du lundi au dimanche, ou que l’axe des x indique le numéro de la semaine épidémiologique (semaines 1 à 52).\nIl est important de noter qu’il n’est pas facile de voir les tendances par maladie lorsqu’elles sont empilées de cette manière ! Pour analyser ces tendances temporelles, vous devez produire un histogramme par maladie.\n\n\n\n\n\n\nUtilisez facet_wrap() pour créer facilement plusieurs mini-graphiques, un par maladie. Pour en savoir plus, vous pouvez consulter le chapitre sur les facettes avec ggplot2 du Epi R Handbook\n\n\n\n\n\n\nQuestions\n\n\n\n\nD’après ce graphique stratifié, quel a été le nombre le plus élevé de cas de dengue signalés en une seule semaine en 2024 ?\n\n 11 15 29 Je ne peux toujours rien en dire!\n\nParmi les cas de dengue signalés cette semaine-là, dans quels districts vivaient les personnes concernées ?\n\n Les trois districts Feveria Central Kasara Lac Minara Ce graphique ne montre pas cette information\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez maintenant admirer une courbe épidémique par maladie ! Et vous pouvez voir qu’au cours d’une semaine de juillet, 15 cas de dengue ont été signalés. Cependant, ce graphique ne contient pas encore d’informations géographiques.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif)), binwidth=7) + \n  facet_wrap(.~maladie_notifiee)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nDans quel(s) district(s) vivaient les 15 cas de dengue notifiés en une semaine en juillet 2024?\n\n Les trois districts Feveria Central Kasara Lac Minara\n\nDans quel district vivait le premier cas de fièvre typhoïde notifié en 2024?\n\n Kasara Feveria Central Lac Minara Je ne peux pas encore le savoir!\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez maintenant observer une épicurve par maladie, avec des couleurs reflétant le district dans lequel le cas résidait.\nVous pouvez voir que les 15 cas de dengue signalés au cours d’une seule semaine résidaient dans trois districts différents. Vous pouvez également voir que le premier cas de typhoïde a été signalé à Feveria Central.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) + \n  facet_wrap(.~maladie_notifiee)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVous pouvez ajouter, préciser ou modifier :\n\nLe thème/l’apparence de l’ensemble du graphique (par exemple, la couleur d’arrière-plan ou l’apparence des lignes de la grille)\nLe titre, sous-titre… et les étiquettes des axes\nLes couleurs des barres (avec scale_fill_manual())\nLe formatage et l’espacement des dates le long de l’axe des x (avec scale_x_date)\nBeaucoup d’autres choses !\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nLe choléra et la fièvre typhoïde semblent-ils endémiques ?\n\n Non, les données suggèrent des épidémies occasionnelles de faible ampleur Oui, ils sont tous deux endémiques\n\nY a-t-il une période particulière de l’année où le paludisme a atteint un pic en 2024 ?\n\n Oui, vers novembre/décembre Oui, vers juillet/août (été) Non, le nombre de cas est constamment élevée\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour un formatage complet. Notez que d’autres changements ont été apportés, notamment la spécification que nous ne voulons que deux colonnes de mini-graphiques dans facet_wrap() et que l’étiquette de la date le long de l’axe des x ne doit indiquer que le jour et le mois (et non l’année, puisque tous les cas sont en 2024 de toute façon).\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) +\n  facet_wrap(.~maladie_notifiee, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District de résidence\",\n       x = \"Date de notification par la clinique\",\n       y = \"Nombre\",\n       subtitle = \"Nombres de cas confirmés de choléra, de dengue, de paludisme de fièvre typhoïde et de fièvre jaune par semaine à Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nLes courbes épidémiques montrent également que le choléra et la typhoïde semblent se manifester sous la forme de flambées isolées, plutôt que de présenter un caractère endémique. Le paludisme et la dengue ont par contre présenté une circulation à Feveria tout au long de l’année, le paludisme atteignant un pic assez net pendant les mois d’été.\n\n\n\n\n\n\nCette fois, utilisez group_by() et summarize() pour produire un tableau par district indiquant les dates de notifications les plus anciennes et les plus récentes.\nA l’aide d’une fontion filter(), vous pourrez générer ce tableau pour un district à la fois.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuand le premier cas de dengue a-t-il été signalé à Feveria en 2024 ?\n\n 18 janvier 2024 17 janvier 2024 12 février 2024\n\nQuand le dernier cas de dengue a-t-il été signalé à Feveria Central en 2024 ?\n\n 22 août 2024 18 novembre 2024 25 décembre 2024\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nRegroupez les données par maladie, puis, dans une fonction summarize(), définissez la première et la dernière date pour obtenir la chronologie globale de chaque maladie à Feveria.\n\ndata_jointes_confirme |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  maladie_notifiee prem_notif der_notif \n  &lt;chr&gt;            &lt;date&gt;     &lt;date&gt;    \n1 cholera          2024-06-03 2024-09-23\n2 dengue           2024-01-17 2024-11-18\n3 fievre jaune     2024-03-08 2024-08-23\n4 paludisme        2024-01-08 2024-12-25\n5 typhoide         2024-05-02 2024-11-07\n\n\nAjouter un filter() au code pour consulter les dates de la première notification et de la notification la plus récente pour le district qui vous intéresse.\n\ndata_jointes_confirme |&gt; \n  filter(district_residentiel == \"Feveria Central\") |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  maladie_notifiee prem_notif der_notif \n  &lt;chr&gt;            &lt;date&gt;     &lt;date&gt;    \n1 cholera          2024-06-03 2024-09-23\n2 dengue           2024-01-29 2024-08-22\n3 paludisme        2024-01-29 2024-12-17\n4 typhoide         2024-05-02 2024-11-07\n\n\n\n\n\n\n\n\n\n\nSuperbe ! Conformément aux objectifs de cette étude de cas, vous avez fait ce qui suit :\n\nVous avez utilisé des fonctions clés de R pour nettoyer, remodeler et joindre des ensembles de données, et vous avez créé de nouvelles colonnes à l’aide de conditions logiques.\nPour obtenir des informations sur le traitement des données, vous avez procédé à des analyses exploratoires et à des vérifications des données tout au long du processus.\nVous avez effectué une analyse descriptive approfondie pour comprendre les données de laboratoire et de notification, avant et après la jointure. En réponse aux quatre questions initiales de votre superviseur, vous pouvez dire :\n\nCombien de cas suspects des différentes maladies à déclaration obligatoire ont été signalés en 2024, et lesquels étaient les plus fréquents ? Le paludisme était la maladie à déclaration obligatoire la plus courante à Feveria en 2024. Selon le système de surveillance des maladies à déclaration obligatoire : Il y a eu 533 cas suspects de paludisme, 273 cas suspects de dengue, 100 cas de fièvre jaune, 46 cas de choléra et 35 cas de typhoïde.\nQuel pourcentage de ces cas a été confirmé ? Près de 80 % des cas à déclaration obligatoire signalés en 2024 avaient donné lieu à un résultat de test de laboratoire au moment de la jointure des données, avec quelques variations selon les maladies. Au total, 56 % des cas notifiés ont finalement été confirmés, mais ce pourcentage variait de 23 % seulement pour la fièvre typhoïde (7 cas confirmés sur 31 cas suspects avec résultats de tests) à 95 % pour le choléra (38 cas confirmés sur 40 cas suspects avec résultats de tests). En outre, le taux de positivité était plus élevé pour les cas présumés de dengue que pour les cas présumés de paludisme (87 % contre 41 %).\nCombien de cas confirmés de différentes maladies à déclaration obligatoire ont été signalés en 2024, et laquelle était la plus fréquente ? Les cas confirmés ont suivi une tendance légèrement différente de celle des cas suspects : l’infection la plus fréquemment signalée était la dengue avec 186 cas, suivie du paludisme (174), puis du choléra (38), de la fièvre jaune (33) et de la fièvre typhoïde (7).\nComment les cas confirmés se répartissent-ils géographiquement et temporellement dans la région de Feveria ? Feveria a connu une transmission de la dengue et du paludisme tout au long de l’année, avec un pic en été, et concentrée dans le district de Lac Minara. Feveria a également connu de petites et rares épidémies de maladies diarrhéiques, telles que le choléra et la fièvre typhoïde, en particulier dans la zone urbaine de Feveria Central, où l’eau et l’assainissement peuvent poser problème.\n\nEnfin, vous avez pu réfléchir à la manière dont les processus des systèmes de surveillance des maladies à déclaration obligatoire et ceux des tests de diagnostique de laboratoire, par exemple le transfert des données entre les cliniques et les laboratoires, peuvent affecter la qualité et l’exhaustivité des données, et donc vos résultats.\n\nIl reste encore beaucoup de possibilités. Vous pouvez explorer les distributions des maladies par âge ou par sexe, calculer des taux d’incidence ou de prévalence des maladies à l’aide de données démographiques et même analyser les délais de déclaration en examinant les différentes dates de vos ensembles de données.\nVous avez acquis de solides bases et vous êtes bien équipé pour passer à l’étape suivante de votre analyse. Continuez, des découvertes passionnantes vous attendent !\nPour en savoir plus, consultez les autres études de cas ou plongez dans le Epi R Handbook.\n\n\n\nVous trouverez ci-dessous un script de toutes les étapes de nettoyage des données et des analyses descriptives. Notez que les analyses sont combinées à la fin plutôt qu’intercalées entre les étapes de nettoyage. Il s’agit d’une façon plus ordonnée d’organiser votre script.\nPar souci de concision, le code ci-dessous n’inclut pas toutes les inspections et vérifications effectuées en cours de route, mais vous pouvez décider de créer des sections avec de telles vérifications.\nLe début de votre script doit également contenir des informations pour aider le lecteur à comprendre à quoi sert le script, ainsi que des commentaires tout au long du script. Vous vous remercierez plus tard d’avoir ajouté ces commentaires !\n\n\n\n\n\n\nCode pour nettoyer et analyser les données de notification et les données de laboratoire de Feveria, 2024\n\n\n\n\n\n\n# Code pour nettoyer et analyser les données de notification et les données de laboratoire de Feveria, 2024\n# Date:\n# Author:\n\n# Installation des packages --------------------------------\n# Pour s'assurer que le package \"pacman\" est installé\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Installation (si nécessaire) depuis le CRAN et chargement des packages à utiliser\npacman::p_load(\n  rio,        # importation de données  \n  skimr,      # aperçu des données\n  janitor,    # nettoyage des données et tableaux descriptifs\n  lubridate,  # manipulation des dates\n  epikit,     # pour créer des catégories d'âge\n  gtsummary,  # statistiques descriptives, tests et régressions \n  apyramid,   # tracé de pyramides des âges \n  flextable,  # tableaux prêts à être présentés\n  naniar,     # analyse des données manquantes\n  remotes,    # pour installer le package permettant de télécharger les données\n  tidyverse   # gestion et visualisation des données\n)\n\n# Importation des données --------------------------------------------\n\n# Données de notification\ndata_notif_brut &lt;- import(\"donnees/multi_maladies_notifications.xlsx\")\n\n# Données de labo\ndata_lab_brut &lt;- import(\"donnees/multi_maladies_tests.csv\")\n\n# Nettoyage des données de notification --------------------------------\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\")) |&gt; \n  mutate(date_notif = ymd(date_notif)) \n\n\n# Nettoyage et consolidation des données de labo -----------------------\n# Nettoyage des valeurs\ndata_lab &lt;- data_lab_brut |&gt; \n  mutate(valeur = case_match(valeur, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positif\",\n                            \"N\" ~ \"Négatif\",\n                            \"I\" ~ \"Indéterminé\"))\n\n# Création de la base de données de labo orientée tests\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(cible != \"Dengue IgG\") |&gt; \n  group_by(id_echantillon) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Création de la base de données de labo orientée cas\ndata_lab_cas &lt;- data_lab_tests |&gt; \n  group_by(id_notification) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Jointure des données de notification et de labo -----------------\ndata_jointes &lt;- left_join(data_notif, data_lab_cas, by = \"id_notification\")\n\n# Nettoyage des données jointes -----------------------------------\ndata_jointes &lt;- data_jointes |&gt; \n  mutate(cas_categorie = case_when(valeur==\"Positif\" ~ \"Confirmé\",\n                                   valeur==\"Négatif\" ~ \"Ecarté\",\n                                   valeur==\"Indéterminé\" | is.na(valeur) ~ \"Suspect\"))\n\ndata_jointes_confirme &lt;- data_jointes |&gt; \n  filter(cas_categorie==\"Confirmé\")\n\n# ANALYSE ---------------------------------------------------------\n# Nombre de cas suspects à Feveria\ntabyl(data_notif, maladie_notifiee)\n\n# Distribution des cas suspects par district\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribution des résultats de test par type de test\ntabyl(data_lab_tests, test, valeur) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des catégories de cas dans les données jointes\ntabyl(data_jointes, cas_categorie) \n\n# Distribution des catégories de cas par maladie dans les données jointes\ntabyl(data_jointes, maladie_notifiee, cas_categorie) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des catégories de cas par maladie dans les données jointes, uniquement pour les cas avec un résultat de test valide\ndata_jointes |&gt; \n    filter(cas_categorie != \"Suspect\") |&gt; \n    tabyl(maladie_notifiee, cas_categorie) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des cas confirmés par district\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee, district_residentiel) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualisation de l'évolution temporelle de le nombre de cas confirmé par district\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) +\n  facet_wrap(.~maladie_notifiee, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District de résidence\",\n       x = \"Date de notification par la clinique\",\n       y = \"Nombre\",\n       subtitle = \"Nombres de cas confirmés de choléra, de dengue, de paludisme de fièvre typhoïde et de fièvre jaune par semaine à Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# Première et dernière date de notification de cas confirmé par maladie\ndata_jointes_confirme |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuteurs originaux Paula Blomquist et Alanah Jansen, avec le soutien technique du CDC Global Surveillance, Laboratory, and Data Systems Branch en collaboration avec TEPHINET.\nSource des données Données fictives fournies par Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nModifications apportées\nVersion\nAuteur\n\n\n\n\nJuillet 2025\nPremière version\n1\nPaula Blomquist et Alanah Jansen, Applied Epi, avec le soutien technique du CDC Global Surveillance, Laboratory, and Data Systems Branch en collaboration avec TEPHINET.\n\n\nAoût 2025\nTraduction française\n1\nLaurent LeHot et Olivia Boyd\n\n\n\n\n\n\nClause de non-responsabilité Les informations présentées dans cet exercice et les fichiers de données associés ont été développés pour aider les apprenants à atteindre les objectifs d’apprentissage prévus. Le contenu est celui de l’auteur ou des auteurs et ne représente pas nécessairement les opinions officielles du CDC, du US Department of Health and Human Services ou de TEPHINET.\nLicence d’utilisation Licence : Cette étude de cas est sous licence licence CC BY-NC-SA 4.0. Pour plus d’informations sur le partage et l’adaptation de cette étude de cas, voir le certificat associé.\nFinancement Cette étude de cas a été soutenue à 100 % par l’accord de coopération numéro NU2HGH000044 financé par le US Centers for Disease Control and Prevention (CDC)"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#scénario",
    "href": "pages/multidisease_surveillance.fr.html#scénario",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Vous êtes un épidémiologiste travaillant au bureau national de surveillance de Feveria, un tout petit pays tropical. Le pays compte trois districts :\n\nFeveria Central: une zone urbaine surpeuplée, avec des infrastructures d’eau et d’assainissement parfois peu fiables.\nLac Minara: une région lacustre dotée de bonnes infrastructures, mais avec une forte présence de moustiques pendant les mois les plus chauds de l’année.\nKasara: une zone suburbaine de l’autre côté de Feveria Central.\n\nCarte des districts du pays Feveria\n\nNous sommes en janvier 2025, et votre supérieure hiérarchique souhaite que vous transfériez le traitement de routine des données sur les maladies à déclaration obligatoire d’Excel à R, et d’effectuer quelques analyses sur ces données. Elle souhaite connaître au minimum:\n\nCombien de cas suspects des différentes maladies à déclaration obligatoire ont été signalés en 2024, et quelle était la plus représentée ?\nParmi eux, quel était le pourcentage de cas confirmés ?\nCombien de cas confirmés des différentes maladies à déclaration obligatoire ont été signalés en 2024, et quelle était la plus représentée ?\nComment se répartissaient géographiquement et temporellement les cas confirmés dans la région de Feveria ?\n\nElle vous demande d’écrire le code pour importer, nettoyer, joindre et analyser les listes linéaires suivantes :\n\nDonnées de surveillance 2024 des maladies à déclaration obligatoire : Appelées également “données de notification”, il s’agit de données de surveillance sur cinq maladies à déclaration obligatoire signalées par les cliniques de Feveria : la dengue, le paludisme, le choléra, la fièvre typhoïde et la fièvre jaune. Il s’agit de cas suspects, basés sur les symptômes des patients. Les cliniciens saisissent chaque notification dans un système en ligne tous les jours de la semaine.\nDonnées 2024 sur les résultats des tests de laboratoire : Ces données sont issues des résultats des tests de laboratoire effectués par trois grands laboratoires de Feveria. Ces résultats concernent des échantillons prélevés sur les cas suspects de maladies à déclaration obligatoire enregistrés dans la première base de données ci-dessus.\n\nAllons-y !"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#les-objectifs",
    "href": "pages/multidisease_surveillance.fr.html#les-objectifs",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Dans cette étude de cas, vous allez :\n\nUtiliser des fonctions essentielles de R pour nettoyer des données, remodeler des bases de données, fusionner différentes sources de données et créer de nouvelles colonnes à l’aide de conditions logiques pour préparer les données pour l’analyse.\nPasser en revue les données et effectuer des contrôles de leur qualité à plusieurs étapes du projet et comprendre l’importance de ces actions pour une analyse fiable.\nConduire des analyses descriptives de base pour comparer les tendances des maladies à partir de différentes sources de données, avant et après la jointure.\nInterpréter les différences de résultats selon les sources de données et comprendre comment elles reflètent la structure et la conception du système de surveillance dans son ensemble."
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-1.-mise-en-place",
    "href": "pages/multidisease_surveillance.fr.html#étape-1.-mise-en-place",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Commencez par la mise en place d’un flux de travail reproductible et bien organisé. Ce processus facilitera le renouvellement de votre analyse chaque fois que cela sera nécessaire.\nTâches :\n\nCréation d’un un projet RStudio\nCréation d’une structure claire de sous-dossiers dans lesquels vous placerez votre code, vos données et vos résultats / sorties.\nCréation d’un script R, ou d’un fichier R Markdown si vous préférez. Assurez-vous que que le but du script, la date et l’auteur sont écrits sous forme de commentaires en haut du script.\nAdditionnel : Assurez-vous que votre langue de travail dans RStudio est appropriée (par ex. le français pour cet exercice)\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\n\nCréez un dossier dans lequel vous placerez tous les travaux de cette étude de cas. Par exemple, créez un dossier “Analyse_multi_maladies” sur le bureau de votre ordinateur. Créez votre projet RStudio dans ce dossier.\nNous suggérons de créer les sous-dossiers suivants : scripts (pour votre code), donnees (pour vos données), et resultats (pour vos résultats d’analyse).\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nCréez un dossier (par exemple “Analyse_multi_maladies” sur votre bureau) pour cet exercice. Pour créer un projet Rstudio dans votre nouveau dossier, cliquez sur l’icône New Project en haut à gauche de votre fenêtre R Studio (ou sur File puis New Project), puis surExisting Directory puis Browse pour sélectionner votre nouveau dossier. Pour plus d’informations, consultez la section Projets R du Epi R Handbook.\nOuvrez un nouveau script R en cliquant sur l’icône New File en haut à gauche de votre écran R Studio (ou sur File puis New File), puis R Script. Sauvegardez-le immédiatement à un endroit approprié, par exemple, dans le sous-dossier scripts de votre dossier de projet R.\nAu début de votre nouveau script R, écrivez sous forme de commentaires quelques informations essentielles telles que votre nom, le but du fichier et la date.\nLes paramètres R “locale” déterminent la langue et les paramètres régionaux utilisés pour les scripts R comme les formats de date et les traductions. Si vos paramètres régionaux sont différents de la langue que vous souhaitez utiliser pour votre rapport (par exemple, les paramètres anglophones au lieu des paramètres francophones), vous pouvez les remplacer par les francophones en exécutant la commande Sys.setlocale(\"LC_ALL\", \"French\"). Incluez cette commande dans votre script si nécessaire, ou ignorez-la si vos paramètres sont appropriés. Ceci est expliqué plus en détail dans le Guide pratique.\n\n\n\n\n\n\nDans votre script R, vous devez maintenant installer et charger les packages R nécessaires. Cela permet de s’assurer que les fonctions nécessaires sont disponibles pour votre analyse.\nVous aurez besoin des packages suivants : {rio} (pour l’importation des données),{skimr} (pour l’examen des données), {janitor} (pour le nettoyage des données), {lubridate} (pour le nettoyage des dates), {epikit} (pour des tâches liées à l’épidémiologie), {gtsummary} (pour les statistiques descriptives / les tests et régressions), {apyramid} (pour les pyramides des âges et des sexes), {flextable} (pour des tableaux prêts à être présentés), {naniar} (pour l’analyse des données manquantes), et {tidyverse} (pour la manipulation générale des données et autres tâches scientifiques).\nVous aurez également besoin du package{remotes} pour télécharger les données - ce que nous expliquerons dans la section sur le téléchargement.\nAlors que vous commencez, votre collègue expérimenté vous glisse : “J’ai entendu parler du package {pacman} pour facilement gérer l’instalation et le chargement des packages dans R”.\nÀ vous de jouer !\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez la fonction p_load() de pacman pour cette tâche. Vous fournissez à la fonction une liste de packages que vous souhaitez utiliser. La fonction effectuera deux étapes pour chaque package :\n\nVérifier si le package est installé sur votre ordinateur, et l’installer si nécessaire, puis\nCharger le package pour qu’il pour qu’il puisse être utilisé pendant cette session R.\n\nSi vous n’avez pas encore installé pacman, vous devrez d’abord l’installer de manière “traditionnelle”, à l’aide de la fonction install.packages().\nNotez que l’ordre des packages dans votre fonction p_load peut être important. Si deux packages possèdent une fonction avec un nom identique (par exemple select() dans le package MASS et select() dans tidyverse qui réalisent des tâches différentes), alors R utilisera la fonction du dernier package chargé. Pour donner la priorité aux fonctions de tidyverse, qui sont couramment utilisées pour la manipulation et la visualisation des données, chargez tidyverse en dernier.\n\n# Pour s'assurer que le package \"pacman\" est installé\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Installation (si nécessaire) depuis le CRAN et chargement des packages à utiliser\npacman::p_load(\n  rio,        # importation de données  \n  skimr,      # aperçu des données\n  janitor,    # nettoyage des données et tableaux descriptifs\n  lubridate,  # manipulation des dates\n  epikit,     # pour créer des catégories d'âge\n  gtsummary,  # statistiques descriptives, tests et régressions \n  apyramid,   # tracé de pyramides des âges \n  flextable,  # tableaux prêts à être présentés\n  naniar,     # analyse des données manquantes\n  remotes,    # pour installer le package permettant de télécharger les données\n  tidyverse   # gestion et visualisation des données\n)"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-2.-télécharger-et-importer-les-données",
    "href": "pages/multidisease_surveillance.fr.html#étape-2.-télécharger-et-importer-les-données",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Votre bureau vous fournit deux fichiers pour votre analyse, tous deux contenant des données pour 2024 et mises à jour au 15 janvier 2025 :\n\nun ensemble de données de notification des maladies (“multi_maladies_notifications.xlsx”) avec l’information sur les cas de 5 centres de santé.\nUn ensemble de données au niveau des tests de laboratoire (“multi_maladies_tests.csv”) soumis par trois laboratoires effectuant des tests pour les cinq centres de santé.\n\nPour cette étude de cas, vous pouvez télécharger les données via le répertoire de données d’Applied Epi, auquel vous pouvez accéder grâce au package {appliedepidata}. Suivez les étapes suivantes :\n\nInstallez le package {appliedepidata} depuis GitHub à l’aide de la fonction install_github() du package {remotes} (que vous avez installé précédemment)\n\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nEnregistrez les deux ensembles de données dans un dossier spécifique à l’aide de la fonction save_data() de {appliedepidata} en exécutant le code ci-dessous. Dans l’exemple ci-dessous, les données sont enregistrées dans un sous-dossier donnees du dossier de projet RStudio. Notez que si vous ne spécifiez pas d’emplacement spécifique avec l’argument path de la fonction, une fenêtre s’ouvrira pour vous demander de sélectionner manuellement un dossier.\n\n\n# Téléchargement des deux fichiers de données en utilisant la fonction save_data()de appliedepidata\nappliedepidata::save_data(\"multi_maladies_tests\",\n                        path = \"donnees\")\n\nappliedepidata::save_data(\"multi_maladies_notifications\",\n                          path = \"donnees\")\n\n\n\n\nTrès bien ! Merci au bureau national et à Applied Epi ! Il est maintenant temps d’importer les données de ce dossier dans RStudio, afin de pouvoir les analyser.\n\n\nIdéalement, vous utiliserez la même fonction pour importer les deux ensembles de données, bien qu’un soit un fichier .csv et l’autre un fichier .xlsx. Notez qu’à l’avenir, nous dirons simplement “environnement” lorsque nous parlerons de la fenêtre environnement dans R Studio.\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nUtiliser la fonction import du package {rio}, qui peut reconnaître et importer différents types de fichiers. Elle remplace les fonctions d’importation qui sont spécifiques à un type de fichier, telles que read.csv() de {base} pour les fichiers .csv et read_excel() de {readxl} pour importer des fichiers .xlsx.\nPour en savoir plus sur les fonctions d’importation, lisez le chapitre Importer et exporter des données du Epi R Handbook.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nCi-dessous, nous utilisons la fonction d’importation pour importer les deux fichiers. Notez que nous assignons les données importées à deux objets, l’un appelé data_notif_brut et un autre appelé data_lab_brut. Nous ajoutons le suffixe “brut” pour distinguer ces données des versions nettoyées que nous créerons plus tard.\n\n# Importation des données\n\n# Données de notification\ndata_notif_brut &lt;- import(\"donnees/multi_maladies_notifications.xlsx\")\n\n# Données de labo\ndata_lab_brut &lt;- import(\"donnees/multi_maladies_tests.csv\")"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-3.-inspecter-les-données",
    "href": "pages/multidisease_surveillance.fr.html#étape-3.-inspecter-les-données",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Les données sont là, il est maintenant temps de voir ce qu’elles racontent. Jetez un premier coup d’oeil à vos deux ensembles de données brutes pour en vérifier le contenu et la qualité.\n\n\n\n\nUtilisez skim() du package {skimr} package, ainsi que names(), ncol() et nrow() pour inspecter votre ensemble de données.\nskim() vous donne de nombreuses informations sur la structure et le contenu des données, et names() vous fournira les différents noms de colonnes des données. Les fonctions ncol() et nrow() renvoient le nombre de colonnes ou de lignes dans les données. Savez-vous ce qu’il faut mettre entre les parenthèses ?\nLe plus simple est de regarder dans l’environnement. Rappelez-vous que l’objet de votre environnement contenant les données de notification s’appelle data_notif_brut.\nCliquez sur la solution sous l’encart de questions si vous avez besoin d’aide.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien y a-t-il de colonnes dans les données de notification?\n\n 10 11 12 13\n\nLaquelle de ces colonnes n’apparait PAS dans les données?\n\n Date d'apparition Date signalée par l'établissement de santé/la communauté Date du résultat Date de test Date de naissance\n\nQuel est le nom de la / des colonne(s) permettant d’identifier chaque notification de cas?\n\n ID de notification Test ID Code de l'établissement de santé Combinaison de ID de notification et Sexe\n\nCombien y a-t-il de lignes dans les données de notification?\n\n 987 1314 950 778\n\nA quel type d’information n’avez vous PAS accès dans les données de notification?\n\n Le résultat du test de laboratoire Le district de résidence La date de naissance et le sexe La structure de santé où a eu lieu la notification L'issue de la maladie\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez skim() du package {skimr} pour obtenir un résumé de l’ensemble des données, et View() pour consulter directement l’ensemble de la base de données sous forme de tableur :\n\nskim(data_notif_brut)\n\nVous pouvez également utiliser names() pour imprimer uniquement les noms des colonnes. Par l’intermédiaire de skim() et names() vous aurez accès à différents type d’information, notamment : l’établissement de santé du cas, la date de naissance, le sexe, un indicateur de grossesse, le district de résidence, la date d’apparition et la date rapportée par la clinique, ainsi que des informations sur l’issue de la maladie.\nIl y a également ID de notification qui semble être un identifiant unique pour un cas, mais nous devrions vérifier les doublons avant d’en être sûrs.\nNotez qu’il n’y a AUCUN résultat de test dans ces données, car ces notifications proviennent des cliniques qui notifient les maladies à déclaration obligatoire sur la base de définitions de cas cliniques.\n\nnames(data_notif_brut)\n\n [1] \"Nom de l'unite d'organisation\"                           \n [2] \"Code de l'etablissement de sante\"                        \n [3] \"ID de notification\"                                      \n [4] \"Date de naissance\"                                       \n [5] \"Sexe\"                                                    \n [6] \"Enceinte\"                                                \n [7] \"District residentiel\"                                    \n [8] \"Maladie notifiee\"                                        \n [9] \"Date d'apparition\"                                       \n[10] \"Date signalee par l'etablissement de sante/la communaute\"\n[11] \"Resultat\"                                                \n[12] \"Date du resultat\"                                        \n\n\nUtilisez ncol() et nrow() pour imprimer le nombre de colonnes et de lignes, comme ceci :\n\nncol(data_notif_brut)\nnrow(data_notif_brut)\n\nCeci imprimera le nombre de colonnes et de lignes dans votre console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nPar ailleurs, si l’on examine l’environnement, on constate que le nombre d’observations (qui sont les mêmes que les lignes) et de colonnes sont à côté du nom de la base de données.\n\n\n\n\n\n\nUtilisez skim() du package {skimr} ou class() pour explorer les classes des colonnes.\nVous souvenez-vous de la façon de spécifier la colonne qui vous intéresse à l’intérieur de la fonction class() ? Vous pouvez également explorer les classes depuis l’environnement.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de colonnes dans l’ensemble de données de notification sont reconnues par R comme étant de classe date ?\n\n 0 2 4\n\nQuelle est la classe de la plupart des colonnes dans les données brutes de notification?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez utiliser class comme dans l’exemple ci-dessous. Le $ est un opérateur utilisé pour sélectionner une colonne spécifique de l’ensemble de données data_notif_brut.\nNotez l’utilisation d’apostrophes inversées (`) autour de Date de naissance parce que le nom de la colonne contient des espaces.\n\nclass(data_notif_brut$`Date de naissance`)\n\nPour consulter la classe via l’environnement, cliquez sur la flèche bleue à côté du nom de l’ensemble de données. Les noms des colonnes apparaissent, avec la classe à côté (par exemple, “chr” indique la classe texte / caractères).\nVous pouvez voir qu’aucune des colonnes qui devraient être des dates n’est reconnue comme telle. Au lieu de cela, elles sont reconnues comme des valeurs texte.\n\n\n\n\n\n\nUtiliser la fonction tabyl() pour inspecter les valeurs dans les colonnes qualitatives/catégorielles en spécifiant le nom de la base de données comme premier argument, et le nom de la colonne comme second argument.\nPar exemple, ce code renvoie le contenu de la colonne Sexe. La sortie montre que masculin et féminin sont sont orthographiés de manière incohérente dans les données. Cette colonne devra faire l’objet d’un nettoyage avant de pouvoir être analysée.\n\ntabyl(data_notif_brut, Sexe)\n\n     Sexe   n    percent valid_percent\n        F  47 0.04761905    0.05452436\n  FEMININ 146 0.14792300    0.16937355\n        M  40 0.04052685    0.04640371\n MASCULIN 172 0.17426545    0.19953596\n        f 154 0.15602837    0.17865429\n  feminin  98 0.09929078    0.11368910\n        m 119 0.12056738    0.13805104\n masculin  86 0.08713273    0.09976798\n     &lt;NA&gt; 125 0.12664640            NA\n\n\nPour analyser les données manquantes, vous pouvez utiliser la fonction miss_var_summary() du package {naniar} :\n\nmiss_var_summary(data_notif_brut)\n\n# A tibble: 12 × 3\n   variable                                                 n_miss pct_miss\n   &lt;chr&gt;                                                     &lt;int&gt;    &lt;num&gt;\n 1 Date d'apparition                                           691     70.0\n 2 Enceinte                                                    510     51.7\n 3 Resultat                                                    197     20.0\n 4 Date du resultat                                            197     20.0\n 5 Date de naissance                                           168     17.0\n 6 Sexe                                                        125     12.7\n 7 Nom de l'unite d'organisation                                 0      0  \n 8 Code de l'etablissement de sante                              0      0  \n 9 ID de notification                                            0      0  \n10 District residentiel                                          0      0  \n11 Maladie notifiee                                              0      0  \n12 Date signalee par l'etablissement de sante/la communaute      0      0  \n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nLes valeurs dans la colonne District résidentiel sont-elles standardisées ?\n\n Non, elles doivent être nettoyées Elles sont standardisées et prêtes à être utilisées dans l'analyse\n\nLes valeurs dans la colonne Maladie notifiee sont-elles normalisées ?\n\n Non, elles doivent être nettoyées Elles sont standardisées et prêtes à être utilisées dans l'analyse\n\nQu’est-ce que R reconnait comme une valeur manquante?\n\n Soit une absence de valeur, ou juste un espace ou un point Pas de valeur dans la cellule, représenté par NA Les mots Inconnu et Indéterminé\n\nSelon l’analyse des données manquantes, est-ce que la colonne Date d'apparition vous paraît exploitable et utile?\n\n Oui, il y a peu de données manquantes, elle est donc utile Assez peu, au vu de la proportion de données manquantes\n\nPourquoi certaines colonnes des données de notification peuvent présenter des orthographes différentes et des catégories non standardisées ?\n\n Un bot brouille les données afin qu'elles soient moins identifiables Chaque clinique peut utiliser un logiciel configuré de manière légèrement différente, ou utiliser des entrées en texte libre, ce qui entraîne des variations orthographiques Le logiciel du système de surveillance utilisé par les établissements cliniques comporte de nombreux bugs\n\nWhy might some columns in the notification data have high missingness?\n\n The clinician does not ask the patient the question during their consultation The patient might not know or want to share the answer The clinician might not have time to prioritise filling in that field in the data, even if they know the information All of the above, and many more reasons\n\nPourquoi certaines colonnes de données de notification peuvent présenter une proportion élevée de données manquantes ?\n\n Le clinicien ne pose pas la question au patient pendant la consultation Le patient peut ne pas connaître la réponse ou ne pas vouloir la partager Le clinicien peut ne pas avoir le temps de remplir ce champ dans les données, même s'il connaît l'information Toutes les raisons ci-dessus, et bien d'autres encore\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez la fonction tabyl() le résumé des valeurs de la colonne District residentiel. Là encore, le premier argument est le nom de l’ensemble de données et le deuxième argument est le nom de la colonne.\n\ntabyl(data_notif_brut, `District residentiel`)\n\n District residentiel   n    percent\n       Au bord du lac 125 0.12664640\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n           LAC MINARA 185 0.18743668\n           Lac Minara  68 0.06889564\n\n\nVous pouvez constater que chacun des trois emplacements (Feveria Central, Lac Minara et Kasara) sont orthographiés de différentes manières et en lettres majuscules ou minuscules. Il faudra faire le ménage si l’on veut analyser la distribution géographique des maladies à déclaration obligatoire.\nDe même, utilisez tabyl() résumer les valeurs contenues dans la colonne Maladie notifiee. Vous pouvez voir qu’elles sont écrites en toutes lettres de manière appropriée et cohérente, de sorte que vous pouvez déjà voir la distribution des maladie sans nettoyage supplémentaire.\n\ntabyl(data_notif_brut, `Maladie notifiee`)\n\n Maladie notifiee   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n     fievre jaune 100 0.10131712\n        paludisme 533 0.54002026\n         typhoide  35 0.03546099\n\n\nUne autre façon d’analyser les données manquantes est de résumer la sortie de la fonction is.na(). Dans l’exemple ci-dessous, la fonction is.na() évalue chaque cellule de la colonne Date d'apparition et renvoie TRUE pour pour les valeurs manquantes et FAUX pour les valeurs présentes.\nAppliquer tabyl() à cette série de TRUE/FALSE vous permet d’obtenir rapidement les effectifs et proportions de données manquantes dans cette colonne. N’oubliez pas que les valeurs comme un espace ou les mots “Inconnu” ou “Manquant” ne seront pas reconnues par R comme manquantes. R ne reconnaîtra que les cellules vides comme données manquantes, représentées par NA.\nPour Date d'apparition, vous pouvez voir que 70 % des cas n’ont pas de valeur, ce qui suggère que cette colonne n’est pas particulièrement utile pour analyser des tendances de maladies au fil du temps.\n\ntabyl(is.na(data_notif_brut$`Date d'apparition`))\n\n is.na(data_notif_brut$`Date d'apparition`)   n   percent\n                                      FALSE 296 0.2998987\n                                       TRUE 691 0.7001013\n\n\nLes données manquantes ou non standardisées peuvent être dues à de nombreuses raisons, notamment:\n\nla conception de l’outil de collecte de données (par exemple, si les questions sont obligatoires ou si elles utilisent du texte libre plutôt que des listes déroulantes),\nles processus et les normes en place (par exemple, des champs que le personnel a pour instruction de prioriser), et\nles facteurs contextuels (par exemple, si le personnel dispose de suffisamment de temps pour collecter les informations).\n\n\n\n\n\n\n\n\n\n\nComme pour les données de surveillance, utilisez skim(), ncol() et nrow()ou inspecter l’environnement pour inspecter les données de laboratoire.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle liste linéaire comporte le plus de colonnes : les données de surveillance ou les données de laboratoire ?\n\n Les données de laboratoire Les données de surveillance Elles ont le même nombre de colonnes\n\nQuelle liste linéaire comporte le plus de lignes ?\n\n Les données de laboratoire Les données de surveillance Elles ont le même nombre de lignes\n\nInspectez les données de laboratoire avec View(). Pour quelle raison les données de laboratoire pourraient avoir plus d’enregistrements ?\n\n Il peut y avoir plusieurs tests ou cibles analysées par échantillon Il y a de nombreux résultats de tests d'étalonnage dans les données Toutes les notifications n'ont pas encore reçu de résultats de tests\n\nLaquelle de ces informations ne figure PAS dans les données de laboratoire ?\n\n ID de notification ID d'échantillon Type de test Date de naissance Résultat du test\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nComme dans la section 3.1, vous pouvez utiliser skim() du package {skimr} pour examiner l’ensemble de données de laboratoire avec les résultats des tests. Vous verrez également les différents noms de colonnes de données, montrant que les données de laboratoire ne contiennent que des informations sur le test et non sur le patient. Elles contiennent toutefois un identifiant de notification, comme les données de notification.\n\nskim(data_lab_brut)\n\nUtiliser ncol() et nrow() pour imprimer le nombre de colonnes et de lignes, comme ceci :\n\nncol(data_lab_brut)\nnrow(data_lab_brut)\n\nLes nombres de colonnes et de lignes s’afficheront dans votre console, vous montrant que les données de laboratoire ont plus de lignes que les données de notification que vous avez inspectées plus tôt.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nIl y a souvent plus d’enregistrements dans les données de laboratoire que dans les données cliniques. Si vous inspectez les données avec View(data_lab_brut) et que vous cliquez ensuite sur la flèche en haut de la colonne id_notification pour les trier par ordre alphabétique, vous verrez que plusieurs lignes partagent le même numéro de notification. Cela peut se produire lorsque plusieurs cibles sont testées à partir du même échantillon (même ID d’échantillon), ou lorsqu’un cas est retesté (ce qui donne un numéro d’identification d’échantillon différent).\n\nView(data_lab_brut)\n\n\n\nnom_laboratoireid_notificationid_echantillondate_testtestciblevaleurHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHopital general de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHopital general de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nComme ci-dessus, utilisez les fonctionc class(), skim() ou tabyl(), ou explorer l’environnement, pour examiner vos colonnes en détail.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de colonnes dans les données de laboratoire sont reconnues par R comme étant des colonnes de date ?\n\n 0 1 2\n\nCombien de colonnes des données de laboratoire n’ont aucune donnée manquante ?\n\n 1 3 7 (toutes!)\n\nQuel test détecte plusieurs cibles (et comporte donc plusieurs lignes par échantillon) ?\n\n Paludisme Dengue Fièvre jaune Choléra Fièvre typhoïde\n\nCombien de valeurs de résultats de test possibles y a-t-il dans la colonne valeur ?\n\n 5 3 4\n\nQuel résultat ne semble PAS être possible pour le test de culture des selles qui détecte la bactérie V.cholerae ?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nLes données du laboratoire ont une colonne de date, reconnue par R comme une classe “IDate”. Il s’agit d’une classe de date utilisée par import() de {rio} lors de l’importation de fichiers csv. Comme la classe Date native de R, elle permet de trier par date et d’analyser les tendances dans le temps.\n\nclass(data_lab_brut$date_test)\n\n[1] \"IDate\" \"Date\" \n\n\nEn utilisant la fonction miss_var_summary() du package {naniar}, on réalise que toutes les colonnes des données de laboratoire sont complètes. Cela peut s’expliquer par le fait que les laboratoires utilisent des processus automatisés et qu’il y a donc beaucoup moins de risques d’erreur humaine.\n(Point important : Notez que dans la vie réelle, les données de laboratoire présenteraient probablement des problèmes aussi !)\n\nmiss_var_summary(data_lab_brut)\n\n# A tibble: 7 × 3\n  variable        n_miss pct_miss\n  &lt;chr&gt;            &lt;int&gt;    &lt;num&gt;\n1 nom_laboratoire      0        0\n2 id_notification      0        0\n3 id_echantillon       0        0\n4 date_test            0        0\n5 test                 0        0\n6 cible                0        0\n7 valeur               0        0\n\n\nPour connaître le nombre de cibles détectées par chaque test, vous pouvez croiser les colonnes test et cible avec tabyl(). Ecrivez les noms des colonnes dans la fonction comme deux arguments distincts (et donc séparés par une virgule). Le résultat montre que chaque test correspond clairement à une ou plusieurs cibles, et que seul le test de la dengue détecte plus d’une cible (IgG, IgM et NS.1).\nConseil : Essayez de modifier l’ordre des noms de colonnes dans tabyl() pour voir l’impact sur le tableau.\n\ntabyl(data_lab_brut, cible, test)\n\n                 cible Culture de selles Dengue NS1/IgG/IgM Hemoculture\n    Bacteries S. Typhi                 0                  0          33\n Bacteries V. cholerae                45                  0           0\n            Dengue IgG                 0                215           0\n            Dengue IgM                 0                215           0\n           Dengue NS.1                 0                215           0\n      Fievre jaune IgM                 0                  0           0\n            Plasmodium                 0                  0           0\n IgM ELISA Microscopie du sang total\n         0                         0\n         0                         0\n         0                         0\n         0                         0\n         0                         0\n        88                         0\n         0                       503\n\n\nEnfin, vous pouvez examiner les différentes valeurs des résultats du test dans la colonne valeur toujours à l’aide de la fonction tabyl(). Vous pouvez voir qu’il y a six résultats possibles, dont N pour négatif, P pour positif et I pour indéterminé. Seul le choléra ne présente aucun P, mais est le seul à présenter P01 et P0139, ce qui correspond à un résultat positif pour les sérogroupes O1 ou O139.\n\ntabyl(data_lab_brut, test, valeur)\n\n                      test  I   N   P PO1 PO139\n         Culture de selles  5   2   0  22    16\n        Dengue NS1/IgG/IgM  0 354 291   0     0\n               Hemoculture  2  24   7   0     0\n                 IgM ELISA 10  45  33   0     0\n Microscopie du sang total 56 257 190   0     0"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-4.-nettoyer-et-décrire-les-données-de-notification",
    "href": "pages/multidisease_surveillance.fr.html#étape-4.-nettoyer-et-décrire-les-données-de-notification",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Vous savez maintenant que les données de notification (data_notif_brut) contiennent des des informations sur les cas suspects, ainsi que des données démographiques de base (âge, sexe, grossesse, district de résidence), et des informations sur la date d’apparition des symptômes, la date de notification par l’établissement de santé, et l’issue. Certaines colonnes doivent être nettoyées avant de poursuivre l’analyse, en raison des variations dans l’orthographe des valeurs catégorielles et de certaines colonnes non reconnues comme des dates.\nVous allez maintenant commencer à écrire de plus longs morceaux de code pour nettoyer les données, à l’aide de plusieurs fonctions {dplyr} reliées à l’aide d’opérateurs “pipe” (qui ressemblent à ceci : |&gt;).\nNOTE SUR LES ‘PIPES’ : Les “pipes” vous permettent d’effectuer plusieurs opérations en une seule commande fluide, en “enchaînant” différentes fonctions. La sortie d’une fonction devient l’entrée de la suivante. Si vous avez besoin de plus d’informations sur les pipes, veuillez vous référer au chapitre du Epi R Handbook.\nNotez que cet exercice utilise le pipe de base (|&gt;) plutôt que le pipe magrittr (%&gt;%), car il est plus rapide et ne nécessite pas l’installation de packages. Utilisez le pipe magrittr si vous préférez.\n\n\n\n\nPour des raisons de qualité et de stockage des données, votre équipe vous recommande de créer une liste linéaire propre qui ne contienne que des informations sur l’identifiant unique, la localisation du cas, la maladie et la date de notification au système de surveillance.\nÉcrivez une commande R pour produire une nouvelle base de données propre appelée data_notif, en appliquant les étapes de nettoyage suivantes:\n\nRenommer les colonnes pour qu’elles soient plus facilement lisibles par la machine (supprimer les espaces et les majuscules) en utilisant clean_names() du package {janitor}.\nUtiliser la fonction rename() de {dplyr} pour que:\n\nle nom de la colonne avec la date à laquelle le cas a été signalé soit remplacé par un nom plus concis date_notif.\nle nom de la colonne d’identifiant de la notification soit plus concis (id_notification).\n\nSélectionnez les colonnes pertinentes pour l’analyse à l’aide de la fonction select() du package {dplyr}.\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nCommencez votre code par le nom du nouvel ensemble de données, l’opérateur d’assignation et le nom de l’objet contenant les données brutes. Ainsi le résultat du traitement des données brutes sera assigné à un nouvel objet appelé data_notif.\n\ndata_notif &lt;- data_notif_brut\n\nIl faudra ensuite construire la commande de nettoyage en ajoutant des fonctions supplémentaires, liées à l’aide d’un pipe. Cela vous permet d’effectuer plusieurs opérations en une seule commande fluide. Tout d’abord, vous utiliserez clean_names() pour normaliser tous les noms de colonnes. Il remplace automatiquement les espaces et les caractères spéciaux par des traits de soulignement (underscore), supprime les accents et les apostrophes, et convertit tous les caractères en minuscules, ce qui rend les noms de colonnes plus facile à utiliser. Vous pouvez ensuite utiliser rename() pour donner à une colonne un nouveau nom. Rappelez-vous que lorsque vous utilisez rename(), la colonne aura déjà reçu le nom issu de clean_names().\n\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(NOUVEAU_NOM = ANCIEN_NOM) |&gt; \n  select(VAR_NAMES)\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code permettant de nettoyer les noms de colonnes et de sélectionner les bonnes colonnes pour l’analyse :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif)\n\n\n\n\n\n\n\nVous savez déjà, grâce à l’inspection des données, que les valeurs de district ne sont pas normalisées.\nAjouter un mutate() pour nettoyer la colonne district_residentiel, afin de:\n\nNormaliser l’utilisation d’écriture minuscule / majuscule dans la colonne\nRemplacer la colonne district_residentiel existante par une colonne qui ne contient que les valeurs pour les districts : “Lac Minara”, “Feveria Central” et “Kasara”.\n\nConsultez l’indice pour savoir quelles fonctions vous pourriez utiliser.\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nEssayez d’utiliser str_to_title() du package {stringr} de façon à ce que la première lettre de chaque mot soit en majuscule et que toutes les autres lettres soient en minuscule. Vous pouvez également utiliser case_match() pour spécifier différentes fautes de frappe spécifiques. Comme pour l’utilisation de rename() après clean_names(), prenez en compte que la fonction str_to_title() a modifié les valeurs des données fournies à la fonctioncase_match().\nUtilisez le panneau d’aide (“Help”) de RStudio pour savoir comment utiliser ces fonctions. Par exemple, tapez ?case_match dans votre console pour obtenir la page d’aide. NOTE sur case_match() : il s’agit d’une fonction très utile pour remplacer ou corriger des valeurs, qui remplace la fonction recode().\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVotre code de nettoyage devrait maintenant ressembler à ceci :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = str_to_title(district_residentiel)) |&gt; \n  mutate(district_residentiel = case_match(district_residentiel,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\"))\n\nVous pouvez également directement insérer la fonction str_to_title() dans la fonction case_match() pour un code plus court, comme suit :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\"))\n\n\n\n\n\n\n\nLa colonne de la date de notification doit être transformée de manière à ce qu’elle soit reconnue comme une date dans R. Cela vous permettra d’analyser les tendances au fil du temps, y compris en utilisant un décompte par semaine ou par mois.\nExaminez les valeurs de la colonne date_notif. Ajoutez ensuite une ligne à votre code de nettoyage pour modifier date_notif en une classe de date.\nConnaître le format de date d’origine vous permettra d’utiliser la bonne fonction pour convertir la colonne en classe de date. Nous vous recommandons d’utiliser l’une des fonctions du package {lubridate} : soit ymd() (pour convertir les dates écrites sous la forme année-mois-jour), mdy() (pour les dates mois-jour-année), ou dmy() (pour les dates jour-mois-année). Ces fonctions reconnaîtront n’importe quelle façon d’écrire la date, à condition qu’elle soit organisée dans cet ordre. Par exemple “21 août 2025” (oui! oui! même en français) et “21-08-2024” seraient toutes deux reconnues par dmy().\n\n\n\n\n\n\nQuestions\n\n\n\n\nComment les dates sont-elles actuellement formatées ?\n\n jour-mois-année année-mois-jour mois-jour-année année-jour-mois\n\nQuelle fonction mutate() devez-vous utiliser pour convertir la colonne date_notif en une classe de date ?\n\n mutate(date_notif = ymd(date_notif)) mutate(date_notif = dmy(date_notif)) mutate(date_notif = mdy(date_notif))\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez utiliser la fonction head() pour afficher les six premières lignes de données de la colonne date_notif. Vous pouvez voir qu’elles sont écrites avec d’abord l’année, puis le mois, puis le jour.\n\nhead(data_notif$date_notif)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nVous pouvez utiliser la fonction ymd() à l’intérieur de mutate() pour convertir la classe de la colonne date_notif. Vous pouvez vérifier que la classe est correcte en utilisant la fonction class() par la suite.\nVotre code de nettoyage devrait maintenant ressembler à ceci :\n\n# Données propres\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\")) |&gt; \n  mutate(date_notif = ymd(date_notif)) \n\nEt vous pouvez vérifier la classe comme ceci :\n\nclass(data_notif$date_notif)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nVos collègues vous disent que chaque id_notification représente un cas suspect unique. Vous souhaitez maintenant créer une table pour vérifier s’il existe des doublons de id_notification sur plusieurs lignes de vos données.\n\n\n\n\n\n\nQuestions\n\n\n\n\nUne ligne dans les données de notification correspond-elle à un cas ?\n\n Oui Non\n\nAvez-vous besoin de dédupliquer vos données pour l’analyse épidémiologique des cas ?\n\n Oui Non\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nIl existe de nombreuses façons de procéder, mais essayez d’utiliser la fonction count() de {dplyr}. Elle créera un tableau qui comptera le nombre de lignes par valeur unique de la colonne que vous spécifiez dans la fonction. Ensuite, utiliser tabyl() pour examiner la distribution de ces effectifs.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nTout d’abord, il faut faire passer les données de surveillance dans la fonction count() en spécifiant à la fonction id_notification comme seul argument. Cela crée un tableau qui compte le nombre de lignes par valeur unique de id_notification, dans une nouvelle colonne n. Vous pouvez voir par exemple dans les premières lignes qu’il n’y a qu’une seule ligne pour chacune de ces 6 id_notification.\n\ndata_notif |&gt; \n  count(id_notification) \n\n\n\n  id_notification n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nEnsuite décrivez la nouvelle colonne n avec tabyl(), qui montrera qu’il n’y a qu’une ligne par id_notification. Cela signifie qu’une ligne correspond à un cas, et qu’aucune autre déduplication n’est nécessaire.\n\ndata_notif |&gt; \n  count(id_notification) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nVous pouvez maintenant procéder à une analyse descriptive des cas, puisque vos données sont propres et que vous savez qu’une ligne équivaut à un cas. Utilisez la fonction tabyl() pour réaliser les tâches suivantes.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle maladie a été la plus fréquemment diagnostiquée par les cliniques de Feveria en 2024 ?\n\n Choléra Paludisme Dengue Fièvre typhoïde Fièvre jaune\n\nQuelle maladie a été la moins fréquemment diagnostiquée par les cliniques de Feveria en 2024 ?\n\n Choléra Paludisme Dengue Fièvre typhoïde Fièvre jaune\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir qu’il y a eu 533 cas suspects de paludisme à Feveria en 2024, et seulement 35 cas suspects de fièvre typhoïde.\n\ntabyl(data_notif, maladie_notifiee)\n\n maladie_notifiee   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n     fievre jaune 100 0.10131712\n        paludisme 533 0.54002026\n         typhoide  35 0.03546099\n\n\n\n\n\n\n\n\nUtilisez tabyl() pour croiser les colonnes maladie et district de résidence.\nComplétez votre tableau en ajoutant diverses fonctions adorn du package {janitor}, pour afficher la distribution en pourcentage. Par exemple adorn_percentages(), adorn_pct_formatting() et adorn_ns().\nTapez le nom de la fonction après un ? dans votre console (par ex. ?adorn_ns) pour afficher les pages d’aide correspondantes. Vous pouvez également consulter la section à propos de {janitor} dans le Epi R Handbook pour plus d’explications sur les fonctions adorn_xxx().\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel district a signalé le plus grand nombre de maladies vectorielles en 2024 (paludisme, dengue, fièvre jaune) ?\n\n Lac Minara Feveria Central Kasara\n\nQuel district a signalé le plus grand nombre de maladies diarrhéiques en 2024 (choléra, fièvre typhoïde) ?\n\n Lac Minara Feveria Central Kasara\n\nQuels facteurs contribuent à l’augmentation des maladies diarrhéiques dans ce district spécifique (sélectionné dans la question précédente) ?\n\n Infrastructures d'approvisionnement en eau et d'assainissement peu fiables Surpopulation de moustiques Nous ne savons pas\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nVoici du code pour vous aider à démarrer. Il croise maladie_notifiee et district_residentiel avec tabyl(), puis en ajoutant adorn_percentages() convertit ces nombres en proportions avec de nombreuses décimales. Vous devrez ensuite rajouter adorn_pct_formatting() avec un autre pipe, pour convertir les proportions en pourcentages, et enfin adorn_ns() pour ajouter à nouveau les effectifs entre parenthèses. Notez que les fonctions adorn_xxx() doivent être appliquées dans un ordre spécifique !\n\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages()\n\nPour les facteurs contribuant à l’augmentation des maladies diarrhéiques, revenez au début de l’étude de cas, à la partie présentant les districts!\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utlisant tabyl(), nous pouvons constater que la plupart des cas suspects de dengue, de paludisme et de fièvre jaune étaient localisés dans le district de Lac Minara - la zone lacustre avec une forte densité de moustiques et donc de maladies à transmission vectorielle. Dans le même temps, la majorité des cas de choléra et de fièvre typhoïde se trouvait à Feveria Central, la zone urbaine surpeuplée souffrant de problèmes d’infrastructures d’approvisionnement en eau et d’assainissement entraînant un risque accru d’inondation et de contamination de l’eau potable par temps de pluie.\n\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n maladie_notifiee Feveria Central      Kasara  Lac Minara\n          cholera      91.3% (42)  8.7%   (4)  0.0%   (0)\n           dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n     fievre jaune      11.0% (11) 21.0%  (21) 68.0%  (68)\n        paludisme      13.7% (73) 19.9% (106) 66.4% (354)\n         typhoide      68.6% (24) 31.4%  (11)  0.0%   (0)"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-5.-nettoyer-consolider-et-décrire-les-données-de-laboratoire",
    "href": "pages/multidisease_surveillance.fr.html#étape-5.-nettoyer-consolider-et-décrire-les-données-de-laboratoire",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Le travail effectué à l’étape 3 vous a permis de constater que les données de laboratoire ne contiennent que des données sur les tests et aucune information sur les patients. Les données sont déjà très propres, nous n’avons à standardiser qu’une seule colonne. Nous voudrons également traiter l’ensemble de données du laboratoire de manière à ce qu’il y ait une ligne par notification, afin de pouvoir le lier proprement à l’ensemble de données de notification.\n\n\n\n\nCréez un nouvel objet data_lab. Cela permettra une analyse et une interprétation des résultats plus simples.\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUtilisez case_match() pour transformer les différentes valeurs originales en “Positif”, “Négatif” ou “Indéterminé” :\n\ndata_lab &lt;- data_lab_brut |&gt; \n  mutate(valeur = case_match(valeur, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positif\",\n                            \"N\" ~ \"Négatif\",\n                            \"I\" ~ \"Indéterminé\"))\n\nVous pouvez ensuite vérifier que les nouvelles valeurs sont correctes en résumant et en comparant les valeurs de la base de données originale et de la base de données nettoyée. Assurez-vous d’avoir utilisé la lettre “O” et non le chiffre “0”!\n\ntabyl(data_lab_brut, valeur)\n\n valeur   n    percent\n      I  73 0.05555556\n      N 682 0.51902588\n      P 521 0.39649924\n    PO1  22 0.01674277\n  PO139  16 0.01217656\n\n\n\ntabyl(data_lab, valeur)\n\n      valeur   n    percent\n Indéterminé  73 0.05555556\n     Négatif 682 0.51902588\n     Positif 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nNous savons déjà que certains échantillons se retrouvent sur plusieurs lignes, et que c’est dû au test de la dengue qui a trois cibles, avec une ligne par pour le résultat de chaque cible.\nMaintenant, trouvez le nombre d’échantillons présentant plusieurs lignes.\nProcédez de la même manière que pour les données de notification, en utilisant l’objet data_lab: comptez d’abord le nombre de lignes par échantillon, puis créer un tableau montrant la distribution des nombres de lignes. Il faut garder à l’esprit que que chaque échantillon est identifié par un id_echantillon.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien d’échantillons (id_echantillon unique) sont répétés sur 3 lignes?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nTout d’abord, il faut faire passer (avec un pipe) les données du laboratoire à la fonction count() en donnant à la fonction id_echantillon comme seul argument. Cela crée un tableau qui compte le nombre de lignes par valeur unique de id_echantillon, affichée dans une nouvelle colonne n. Vous pouvez voir par exemple que le id_echantillon “000e8eee” est présent sur trois lignes, alors que le id_echantillon “001e1878” n’apparaît que sur une seule ligne.\n\ndata_lab |&gt; \n  count(id_echantillon) \n\n\n\n  id_echantillon n\n1       000e8eee 3\n2       001e1878 1\n3       005f39af 1\n4       00b30781 3\n5       00b56d18 1\n6       0110abcd 3\n\n\nPuis résumez la nouvelle colonne n avec tabyl().\n\ndata_lab |&gt; \n  count(id_echantillon) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nVous pouvez même vérifier que cela ne s’applique qu’au test de la dengue en en ajoutant la colonne test dans la commande. Vous pouvez voir que seul le test de la dengue comporte 3 lignes par échantillon.\n\ndata_lab |&gt; \n  count(test, id_echantillon) |&gt; \n  tabyl(test, n)\n\n                      test   1   3\n         Culture de selles  45   0\n        Dengue NS1/IgG/IgM   0 215\n               Hemoculture  33   0\n                 IgM ELISA  88   0\n Microscopie du sang total 503   0\n\n\n\n\n\n\n\n\nComme vous l’avez vu dans la section 3.2, votre test de dengue fournit des résultats pour trois cibles biologiques différentes : IgG, IgM et NS.1. Les résultats pour chacune de ces cibles peuvent être soit négatifs, soit positifs. Cependant, pour simplifier et consolider vos données, vous souhaitez attribuer une seule valeur “Négatif” ou “Positif” à chaque échantillon, pour indiquer si l’échantillon révélait une infection en cours.\n\n\ncibleNégatifPositifDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nVotre collègue Ben, qui travaille au laboratoire, vous conseille ce qui suit :\n\nUn échantillon peut être considéré comme positif si le NS.1 ou les IgM sont positifs (les deux pouvant représenter une infection aiguë).\nVous pouvez ignorer les IgG (parce qu’un résultat positif en l’absence de NS.1 ou d’IgM positifs indique une immunité après une infection passée résolue).\n\nVous devez maintenant consolider les résultats du test de la dengue en une ligne par test, avec une valeur unique de résultat. Utiliser filter(), arrange() et slice(), en veillant à ce que tout échantillon positif pour NS.1 ou IgM soit considéré comme positif pour la dengue. Créez un nouvel objet appelé data_lab_tests\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nEssayez d’appliquer ce qui suit pour consolider selon la recommandation de Ben :\n\nSupprimer les résultats IgG : filtrez les lignes où la cible est “IgG” à l’aide de filter() de {dplyr}.\nDonner la priorité aux résultats positifs pour les IgM/NS1 : Regroupez par id_echantillon et réorganisez les lignes avec arrange() afin que tout résultat “Positif” apparaisse en premier.\nFiltrer pour obtenir le résultat final : Ne conservez que la première ligne de chaque groupe en utilisant slice(1) pour obtenir le résultat global positif ou négatif de l’échantillon.\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour filtrer les résultats des IgG de la dengue, et ensuite consolider les résultats des tests à l’intérieur de chaque groupe de lignes ayant les mêmes id_echantillon, en donnant la priorité aux résultats positifs.\nVous devez utiliser desc à l’intérieur de arrange() car cela signifie que les résultats seront listés par ordre alphabétique DESCendant, ce qui signifie que “Positif” sera en haut pour chaque identifiant.\nAjoutez également la fonction ungroup() à la fin pour que les nouvelles données ne soient plus groupées, ce qui pourrait perturber les analyses ultérieures.\n\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(cible != \"Dengue IgG\") |&gt; \n  group_by(id_echantillon) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nVous pouvez alors vérifier que le nouvel objet data_lab_tests ne présente qu’une seule ligne par test, en utilisant la combinaison de count() et tabyl() comme vous l’avez fait pour la tâche A.\nCe tableau vous montre que tous les ID d’échantillons uniques ne sont présents que dans une seule ligne chacun :\n\ndata_lab_tests |&gt; \n  count(id_echantillon) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nMaintenant, vérifiez le nombre de tests par identifiant de notification dans vos nouvelles données consolidées.\nVous pouvez voir qu’il y a 26 lignes avec le même id_notification, mais seulement parmi les cas testés par microscopie du sang total pour le paludisme.\n\ndata_lab_tests |&gt; \n  count(test, id_notification) |&gt; \n  tabyl(test, n)\n\n                      test   1  2\n         Culture de selles  45  0\n        Dengue NS1/IgG/IgM 215  0\n               Hemoculture  33  0\n                 IgM ELISA  88  0\n Microscopie du sang total 451 26\n\n\nVous poursuivez vos recherches en examinant un exemple de cas avec le id_notification “043228”. Cela vous apprend que ce cas a été testé deux fois, avec deux échantillons différents, à une semaine d’intervalle. Le premier résultat était positif, et le second résultat était négatif.\n\ndata_lab_tests |&gt; \n  filter(id_notification == \"043228\")\n\n# A tibble: 2 × 7\n  nom_laboratoire   id_notification id_echantillon date_test  test  cible valeur\n  &lt;chr&gt;             &lt;chr&gt;           &lt;chr&gt;          &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; \n1 Hopital universi… 043228          27c37cd8       2024-06-18 Micr… Plas… Posit…\n2 Hopital universi… 043228          d2271be0       2024-06-25 Micr… Plas… Négat…\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle affirmation concernant les données de laboratoire est correcte ?\n\n Tous les cas des différentes maladies sont retestés Certains cas de paludisme sont retestés Tous les cas de paludisme sont retestés\n\nAurez-vous besoin de dédupliquer les données de laboratoire pour les relier aux données de notification ?\n\n Oui, nous avons besoin d'une unique ligne représentant le résultat de laboratoire par notification Non, les données sont suffisamment dédupliquées\n\n\n\n\nSi vous avez répondu que vous devez dédupliquer, vous avez raison !\nDédupliquez vos données afin d’avoir une ligne par id_notification, en priorisant les résultats positifs, afin de pouvoir établir un lien avec les données de notification.\nPour ce faire, suivez un processus similaire à celui de la tâche B, en utilisant la base de données produite par la tâche B :\n\nRegrouper par id_notification\nClasser par valeur du résultat du test de manière à ce que les valeurs commençant par P soient listées dans la première ligne, suivies des N (Négatif), puis des I (Indéterminé).\nConservez ensuite la première ligne de chaque groupe de id_notificationen utilisant slice().\nPour finir, assignez le résultat à un nouvel objet appelé data_lab_cas.\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour dédupliquer les lignes à l’intérieur de chaque groupe de lignes avec un même id_notification en donnant la priorité aux résultats positifs. Une fois de plus, vous devez utiliser desc à l’intérieur dearrange(). Cela fonctionne parfaitement car l’ordre de priorité souhaité pour les résultats - positifs, puis négatifs, puis indéterminés - correspond à l’ordre alphabétique inversé (P vient à avant N, qui vient avant I, dans l’ordre alphabétique inversé).\nSi votre ordre de priorité était plus complexe ou ne correspondait pas à l’ordre alphabétique (par exemple, si “indéterminé” devait être placé avant “négatif”), vous devriez convertir la colonne de résultats en un facteur et fournir explicitement l’ordre souhaité de ses niveaux. N’oubliez pas de dégrouper à nouveau à la fin.\n\ndata_lab_cas &lt;- data_lab_tests |&gt; \n  group_by(id_notification) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nVous pouvez alors vérifier que le nouvel objet data_lab_cas n’a qu’une seule ligne par identifiant de notification, en utilisant la combinaison de count() et tabyl() comme dans la tâche A. Ce tableau vous montre que tous id_notification uniques sont ne sont présents que dans une seule ligne chacun:\n\ndata_lab_cas |&gt; \n  count(id_notification) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nNous disposons maintenant de deux objets que nous pouvons utiliser pour l’analyse des données de laboratoire : data_lab_tests et data_lab_cas.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel objet devez-vous utiliser pour analyser les tests ?\n\n data_lab_tests data_lab_cas Aucun des deux\n\nCombien de tests ont été effectués pour dépister le paludisme (par microscopie du sang total) ?\n\n 215 503 88 190\n\nQuel pourcentage de tests de dépistage du choléra (par culture de selles) s’est révélé positif ?\n\n 21% 11% 84% 87%\n\nQuel test a donné le pourcentage le plus élevé de résultats indéterminés ?\n\n IgM ELISA (pour la détection de la fièvre jaune) Culture de selles (pour la détection du choléra) Hémoculture (pour la détection de la fièvre typhoïde)\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir le nombre de résultats positifs, négatifs et indéterminés par test. Vous pouvez ajouter une série de adorn() pour afficher les pourcentages et les totaux.\n\ntabyl(data_lab_tests, test, valeur) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                      test Indéterminé     Négatif     Positif        Total\n         Culture de selles  11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n        Dengue NS1/IgG/IgM   0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n               Hemoculture   6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                 IgM ELISA  11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopie du sang total  11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle base de données de laboratoire devez-vous utiliser pour compter le nombre de cas suspects testés ?\n\n data_lab_brut data_lab_cas data_lab_tests data_lab\n\nCombien de cas suspects ont été testés dans les données de laboratoire de 2024 ?\n\n 858 1314 884\n\nY a-t-il plus de cas suspects dans les données de notification ou dans les données de laboratoire ?\n\n Données de notification Données de laboratoire\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez simplement regarder le nombre de lignes dans le fichier data_lab_cas pour connaître le nombre de cas suspects qui ont été testés.\n\nnrow(data_lab_cas)\n\n[1] 858\n\n\nCe nombre est inférieur au nombre de cas suspects figurant dans la base de données des maladies à déclaration obligatoire (data_notif); ce qui suggère qu’une partie seulement des cas suspect notifié en 2024 avait été testée au moment où ces données étaient rendues disponibles.\n\nnrow(data_notif)\n\n[1] 987"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-6.-jonction-et-traitement-final",
    "href": "pages/multidisease_surveillance.fr.html#étape-6.-jonction-et-traitement-final",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Maintenant que les deux listes linéaires sont nettoyées et qu’elles comportent une ligne par cas suspect, vous pouvez les joindre pour permettre l’analyse complète demandée par votre patron.\n\n\n\n\nCréer un nouvel objet appelé data_jointes en utilisant une fonction xxx_join() de {dplyr}. Vous souhaitez conserver toutes les notifications, mais ajouter les résultats de tests lorsqu’ils sont disponibles pour chaque cas suspect.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle fonction permet la bonne approche si vous souhaitez conserver toutes les lignes de vos données de notification et intégrer les résultats de vos données de laboratoire ?\n\n left_join(data_notif, data_lab_cas… full_join(data_notif, data_lab_cas… right_join(data_notif, data_lab_cas…\n\nQuel identifiant doit être utilisé pour joindre les deux listes linéaires ?\n\n id_echantillon id_notification id_echantillon et date_notif id_notification et date_notif\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nReliez les données à l’aide de la fonction left_join() avec les données de notification comme ensemble de données principal à gauche. Toutes les lignes de cet ensemble de données seront conservées et seuls les résultats des tests provenant de l’ensemble de données de laboratoire renseigné à “droite” de la fonction seront ajoutés.\n\ndata_jointes &lt;- left_join(data_notif, data_lab_cas, \n                         by = \"id_notification\")\n\nVous créez la jointure avec la colonne id_notification qui est présente, complète et propre dans les deux base de données.\nNote: Vous avez de la chance de travailler avec un exemple de jointure aussi simple ! D’habitude, il faut vraiment nettoyer et vérifier la colonne d’identifiant, ou établir un lien avec d’autres colonnes comme le nom et la date de naissance. À Feveria, le personnel de la clinique est fantastique pour attribuer systématiquement des identifiants de notification à chaque patient, et de les renseigner sur les formulaires d’échantillon envoyés au laboratoire, et le personnel du laboratoire est tout aussi brillant pour enregistrer l’identifiant de notification dans leur système informatique afin que les résultats puissent être reliés au cas.\n\n\n\n\n\n\nVérifiez maintenant vos données et examinez quelques points.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de lignes contient votre nouvelle base de données data_jointes ?\n\n 987 884 858\n\nEt par rapport à vos données de notification d’origine ?\n\n plus de lignes que l'original même nombre de lignes moins de lignes\n\nQuel terme décrit le mieux la jointure que vous venez de réaliser?\n\n plusieurs-à-un un-à-un plusieurs-à-plusieurs\n\nCombien de résultats de laboratoire n’ont PAS été joints aux données de notification (indice : utilisez la fonction anti_join()) ?\n\n 30 19 0\n\nAvez-vous de la chance que votre jointure soit si réussi ?\n\n Quoi ? Toutes les jointures ne sont-ils pas aussi simples que cela ? Tout à fait ! En général, certains enregistrements ne trouvent pas de correspondance\n\nQuelles sont les raisons typiques pour lesquelles il n’y a pas de correspondance trouvé pour des données de laboratoire et des données sur les maladies à déclaration obligatoire ?\n\n Il y a des fautes de frappe dans les colonnes utilisées pour la correspondance, elles ne sont donc pas reconnues comme correspondant Les données de laboratoire peuvent contenir des cas supplémentaires provenant d'autres cliniques ou pays Les données de laboratoire peuvent inclure des échantillons de test Des notifications peuvent avoir été accidentellement omises dans les données de surveillance même si l'échantillon a été testé en laboratoire Toutes les réponses ci-dessus\n\nCombien de cas suspects n’ont pas de résultat ?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVérifiez le nombre de lignes dans chaque ensemble de données à l’aide de la fonction nrow() ou en vérifiant les informations relatives à l’objet dans votre environnement. Vous pouvez constater l’opération était une jointure un-à-un, car chaque ligne avait un id_notification unique, de sorte qu’une ligne dans les données de notification était directement liée à une ligne dans les données de laboratoire.\nNombre de lignes dans les données de notification\n\nnrow(data_notif)\n\n[1] 987\n\n\nNombre de lignes dans les données jointes\n\nnrow(data_jointes)\n\n[1] 987\n\n\nPour vérifier si des résultats de laboratoire n’ont pas été reliés à des données de notification, vous pouvez utiliser la fonction anti_join(). Cette fois, data_lab_cas est à gauche, car la fonction évalue le nombre de lignes de l’objet de gauche qui n’ont pas été trouvées dans l’ensemble de données de droite, en les faisant correspondre par id_notification. Ici, il n’est pas nécessaire de créer un nouvel objet, vous pouvez simplement faire passer le résultat à nrow() avec un pipe pour compter le nombre de lignes. Le résultat est 0, ce qui montre qu’il n’y a pas eu de résultats de labo non reliés - incroyable !\n\nanti_join(data_lab_cas, data_notif, \n          by = \"id_notification\") |&gt; nrow()\n\n[1] 0\n\n\nEnfin, pour vérifier le nombre de notifications sans résultat, vous pouvez soit réaliser un anti_join() en mettant data_notif d’abord :\n\nanti_join(data_notif, data_lab_cas, \n          by = \"id_notification\") |&gt; nrow()\n\n[1] 129\n\n\nOu vous pouvez aussi simplement évaluer le nombre de valeurs manquantes dans la colonne valeur dans data_jointes (puisque valeur provient des données de laboratoire).\n\ntabyl(is.na(data_jointes$valeur)) \n\n is.na(data_jointes$valeur)   n   percent\n                      FALSE 858 0.8693009\n                       TRUE 129 0.1306991\n\n\nCes deux approches montrent que 129 cas suspects ne présentent pas de résultat de laboratoire.\n\n\n\n\n\n\n\n\n\nUtiliser mutate() pour créer une nouvelle colonne cas_categorie, afin de mettre à jour le status de cas suspect en fonction de leurs résultats de laboratoire. Les catégories devraient être les suivantes :\n\nSi le résultat est positif : Confirmé\nSi le résultat est négatif : Ecarté\nSi le résultat est indéterminé ou manquant : Suspect\n\nCela signifie que tous les cas figurant dans les données de notification sont d’abord “Suspect” lorsqu’ils sont déclarés, puis restent “Suspect” en l’absence d’un résultat de test concluant.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle est la fonction la plus appropriée pour créer cette nouvelle colonne?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous devez utiliser case_when() pour créer la nouvelle colonne. Cette fonction est idéale pour appliquer plusieurs conditions logiques afin d’attribuer de multiples valeurs différentes, alors que case_match() est plus adapté pour remplacer des valeurs spécifiques, et if_else() est préférable s’il n’y a que deux valeurs possibles.\n\ndata_jointes &lt;- data_jointes |&gt; \n  mutate(cas_categorie = case_when(valeur==\"Positif\" ~ \"Confirmé\",\n                                   valeur==\"Négatif\" ~ \"Ecarté\",\n                                   valeur==\"Indéterminé\" | is.na(valeur) ~ \"Suspect\"))\n\n\n\n\n\n\n\n\n\n\nUtilisez tabyl() directement, et aussi en croisant avec les maladies pour répondre aux questions ci-dessous.\n\n\n\n\n\n\nQuestions\n\n\n\n\nCombien de cas dans les données de notification jointes n’ont pas de résultat positif ou négatif ?\n\n 202 347 250\n\nQuel pourcentage de cas dans les données de notification ONT un résultat positif ou négatif ?\n\n 60,1 % 79,5 % 92,2 %\n\nPourquoi y a-t-il plus de cas suspects restants que de notifications sans résultat de laboratoire relié?\n\n Les cas suspects comprennent les notifications sans résultat de laboratoire et avec un résultat de laboratoire indéterminé Il y a des cas suspects supplémentaires provenant du laboratoire Il y a un problème avec les données\n\nQuelle maladie présentait le pourcentage le plus élevé de cas restés suspects après la jointure?\n\n Choléra Paludisme Dengue Fièvre jaune\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nUne fois de plus, vous pouvez utiliser tabyl() pour voir la répartition des catégories de cas entre les notifications. Le nombre total de cas suspects, c’est-à-dire ceux pour lesquels aucun résultat de laboratoire n’a été obtenu ou pour lesquels le résultat est indéterminé, est de 202. Cela signifie que 785 cas, soit 79,5 %, ont obtenu un résultat de laboratoire définitif.\n\ntabyl(data_jointes, cas_categorie) \n\n cas_categorie   n   percent\n      Confirmé 438 0.4437690\n        Ecarté 347 0.3515704\n       Suspect 202 0.2046606\n\n\nVous pouvez également croiser les résultats originaux (indéterminé/négatif/positif) de valeur avec la nouvelle colonne cas_categorie, pour vérifier que votre logique a fonctionné et pour voir comment les valeurs originales correspondent aux valeurs de la nouvelle colonne. Cela montre qu’en plus des 129 notifications qui n’ont pas été reliées à un résultat de test (avec NA dans la colonne valeur), 73 avaient des résultats indéterminés et ont donc été classées dans la catégorie des cas suspects.\n\ntabyl(data_jointes, cas_categorie, valeur) \n\n cas_categorie Indéterminé Négatif Positif NA_\n      Confirmé           0       0     438   0\n        Ecarté           0     347       0   0\n       Suspect          73       0       0 129\n\n\nEnfin, vous pouvez également croiser les catégories avec les noms de maladie pour voir les catégories de cas par maladie. Ajoutez des fonctions adorn_xxx() pour ajouter et mettre en forme des pourcentages. Le tableau montre ainsi que 22 % des cas de fièvre jaune sont restés suspects, ce qui représente le pourcentage le plus élevé par rapport aux autres maladies.\n\ntabyl(data_jointes, maladie_notifiee, cas_categorie) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n maladie_notifiee    Confirmé      Ecarté     Suspect        Total\n          cholera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n           dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n     fievre jaune 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n        paludisme 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n         typhoide 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n            Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilisez tabyl() à nouveau, en examinant les résultats par maladie. Réfléchissez au dénominateur adéquat !\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuel pourcentage de cas suspects notifié en 2024 étaient de vrais cas selon leurs résultats de test?\n\n 44% 56% 59%\n\nQuel pourcentage de cas supects de paludisme étaient effectivement atteint de paludisme?\n\n 86% 41% 23%\n\nQuel pourcentage de cas supects de dengue étaient effectivement atteint de dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nCliquez pour lire un indice\n\n\n\n\n\nDiviser le nombre de cas confirmés (c’est-à-dire ceux dont le résultat est positif) par le nombre de cas confirmés plus les cas écartés (c’est-à-dire ceux dont le résultat est soit positif, soit négatif). On obtient ainsi un taux de positivité, qui correspond approximativement au pourcentage de cas suspects qui étaient réellement des cas. Les résultats indéterminés sont exclus du dénominateur car ils ne fournissent pas de résultat clair et fausseraient le taux de positivité.\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nFiltrez les cas toujours suspects, puis réalisez un tableau croisé pour connaître le pourcentage de cas initialement suspectés qui ont été ou confirmés ou écartés, parmi ceux dont les résultats de test sont valides.\nAvec la ligne de totaux, vous pouvez voir que 56 % des cas suspects ont été confirmés parmi ceux dont les résultats étaient valides. Vous pouvez également voir que 41 % et 87 % des cas de paludisme et de dengue, respectivement, ont été confirmés.\n\ndata_jointes |&gt; \n  filter(cas_categorie != \"Suspect\") |&gt; \n  tabyl(maladie_notifiee, cas_categorie) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n maladie_notifiee    Confirmé      Ecarté        Total\n          cholera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n           dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n     fievre jaune 42.3%  (33) 57.7%  (45) 100.0%  (78)\n        paludisme 41.3% (174) 58.7% (247) 100.0% (421)\n         typhoide 22.6%   (7) 77.4%  (24) 100.0%  (31)\n            Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTâche A : Créer une nouvelle liste linéaire appelée data_jointes_confirme.\nC’est ce que vous utiliserez dans les rapports de surveillance officiels.\n\n\n\n\n\n\nQuestions\n\n\n\n\nPourquoi choisissons-nous de ne signaler que les cas confirmés dans nos données de surveillance ?\n\n La déclaration des cas confirmés peut être plus fiable et précise lorsque le pourcentage de tests positifs est faible et que les tests en laboratoire sont systématiques, ce qui permet d'éviter une surestimation de la morbidité La déclaration des cas confirmés est plus lente, ce qui nous donne plus de temps pour nous assurer de l'exactitude de nos déclarations Parce que nous voulons cacher le nombre réel de cas\n\nQuelle fonction est importante pour créer la nouvelle liste linéaire ?\n\n filter() arrange() mutate()\n\nCombien de lignes contient ce nouvel ensemble de données ?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVotre équipe de surveillance souhaite se concentrer sur les cas confirmés dans ses rapports. En effet, les tests de laboratoire sont intégrés dans les activités de routine à Feveria, et la déclaration des cas suspects serait inutilement imprécise, un pourcentage élevé de cas suspects étant écartés.\nLa décision de publier les cas suspects peut être différente dans dans d’autres contextes. Par exemple, si le taux de positivité est élevé (la plupart des cas sont des cas réels s’ils sont testés) et que le test lui-même n’est pas courant, ou que le test prend beaucoup de temps et entraînerait un retard dans le rapportage, cela suggérerait que les tendances des cas suspects sont suffisamment précises et également plus opportunes que l’attente d’une confirmation en laboratoire.\nCréez la nouvelle liste linéaire à l’aide de la fonction filter() :\ndata_jointes_confirme &lt;- data_jointes |&gt; \n  filter(cas_categorie==\"Confirmé\")\nEt vérifiez le nombre de lignes en consultant les informations dans votre environnement, ou avec nrow():\nnrow(data_jointes_confirme)\n[1] 438"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#étape-7.-analyse-descriptive-des-cas-confirmés",
    "href": "pages/multidisease_surveillance.fr.html#étape-7.-analyse-descriptive-des-cas-confirmés",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Maintenant que vous disposez de la liste des cas confirmés de maladies à déclaration obligatoire signalés à Feveria en 2024, vous êtes prêt à effectuer la dernière partie de votre analyse de surveillance ! Il s’agit de décrire les cinq maladies à déclaration obligatoire par zone géographique et par période.\nConseil: L’analyse des données de surveillance comprend généralement une analyse par personne. Vous pourriez développer cette étude de cas en procédant à une analyse selon les variables démographiques.\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuelle maladie à déclaration obligatoire a été la plus souvent notifiée en 2024, en se limitant aux seuls cas confirmés ?\n\n Dengue Paludisme Fièvre jaune\n\nPourquoi la maladie la plus fréquemment signalée diffère-t-elle entre les cas confirmés et les cas suspects ?\n\n La sensibilité et la spécificité du diagnostic clinique peuvent varier selon la maladie Les performances des tests utilisés en laboratoire peuvent varier selon la maladie Il peut y avoir des biais de notification Toutes les réponses ci-dessus !\n\nQuel district a signalé le plus grand nombre de cas confirmés de choléra en 2024 ?\n\n Lac Minara Feveria Central Kasara\n\nCombien de cas confirmés de choléra signalés en 2024 concernaient des résidents de Feveria Central ?\n\n 35 42 4\n\nQuel district a signalé le plus grand nombre de cas confirmés de paludisme en 2024 ?\n\n Lac Minara Feveria Central Kasara\n\nCes données confirment-elles que la dengue est la maladie infectieuse la plus courante à Feveria ?\n\n Non, une autre maladie peut être sous-déclarée et/ou non systématiquement notifiée Oui, si c'est la maladie la plus notifiée, c'est qu'elle doit être la plus courante\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nEn utilisant tabyl() nous pouvons voir que la dengue était la maladie la plus fréquemment notifiée à Feveria en 2024, en se limitant aux cas confirmés, avec 186 cas.\n\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee) \n\n maladie_notifiee   n    percent\n          cholera  38 0.08675799\n           dengue 186 0.42465753\n     fievre jaune  33 0.07534247\n        paludisme 174 0.39726027\n         typhoide   7 0.01598174\n\n\nNotez que cela diffère des cas suspects, où le paludisme a été le plus notifié (avec 533 cas suspects) ! Il y avait déjà des indices, avec un taux de positivité pour les cas suspects de dengue plus élevé que pour les cas suspects de paludisme. Cela peut s’expliquer par différentes raisons, par exemple la méthode de diagnostic clinique utilisée pour le paludisme peut être moins spécifique (de nombreux cas suspects sont en fait d’autres maladies), ou le test utilisé pour la dengue peut être plus sensible.\nCroisez les données avec celles du district résidentiel, puis ajoutez les fonctions adorn_xxx() pertinentes.\n\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee, district_residentiel) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n maladie_notifiee Feveria Central     Kasara  Lac Minara        Total\n          cholera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n           dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n     fievre jaune       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n        paludisme      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n         typhoide      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n            Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nComme pour les cas suspects, on constate que la plupart des cas confirmés de dengue, de paludisme et de fièvre jaune se situent à Lac Minara, zone lacustre où la densité de moustiques et donc de maladies à transmission vectorielle est la plus élevée. La majorité des cas confirmés de choléra et de fièvre typhoïde se trouvaient à Feveria Central, sujet à des problèmes d’eau et d’assainissement.\nLes données suggèrent que les maladies à transmission vectorielle (dengue et paludisme) sont particulièrement préoccupantes dans ce pays tropical. Cependant, nous ne savons pas avec certitude quelle est la maladie la plus fréquente et quels sont les schémas sous-jacents - seules cinq maladies sont à déclaration obligatoire et les cas notifiés ne représentent généralement qu’une fraction des cas réels au sein de la communauté.\n\n\n\n\n\n\n\nVous allez travailler à la réalisation de cette courbe épidémique, à travers les tâches ci-dessous.\n\n\n\n\n\n\n\n\n\n\n\nVeillez à spécifier l’argument binwidth=7 afin que chaque barre de l’histogramme représente le nombre de cas sur une période de 7 jours.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuand a été notifié le premier cas de fièvre typhoïde de 2024 à Feveria?\n\n Janvier 2024 Mai 2024 Octobre 2024\n\nD’après ce graphique, quel a été le plus grand nombre de cas de dengue notifiés en une seule semaine en 2024?\n\n 10 20 30 Difficile à dire avec ce graphique empilé!\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici un code simple pour produire la courbe épidémique. Notez que vous ne contrôlez pas encore les couleurs, ni ne spécifiez le jour de la semaine où commence chaque période de 7 jours.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = maladie_notifiee)), binwidth=7)\n\n\n\n\n\n\n\n\nReportez-vous au chapitre sur les dates du Epi R Handbook si vous souhaitez réaliser un formatage plus spécifique des dates, par exemple pour que chaque barre représente une semaine du lundi au dimanche, ou que l’axe des x indique le numéro de la semaine épidémiologique (semaines 1 à 52).\nIl est important de noter qu’il n’est pas facile de voir les tendances par maladie lorsqu’elles sont empilées de cette manière ! Pour analyser ces tendances temporelles, vous devez produire un histogramme par maladie.\n\n\n\n\n\n\nUtilisez facet_wrap() pour créer facilement plusieurs mini-graphiques, un par maladie. Pour en savoir plus, vous pouvez consulter le chapitre sur les facettes avec ggplot2 du Epi R Handbook\n\n\n\n\n\n\nQuestions\n\n\n\n\nD’après ce graphique stratifié, quel a été le nombre le plus élevé de cas de dengue signalés en une seule semaine en 2024 ?\n\n 11 15 29 Je ne peux toujours rien en dire!\n\nParmi les cas de dengue signalés cette semaine-là, dans quels districts vivaient les personnes concernées ?\n\n Les trois districts Feveria Central Kasara Lac Minara Ce graphique ne montre pas cette information\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez maintenant admirer une courbe épidémique par maladie ! Et vous pouvez voir qu’au cours d’une semaine de juillet, 15 cas de dengue ont été signalés. Cependant, ce graphique ne contient pas encore d’informations géographiques.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif)), binwidth=7) + \n  facet_wrap(.~maladie_notifiee)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nDans quel(s) district(s) vivaient les 15 cas de dengue notifiés en une semaine en juillet 2024?\n\n Les trois districts Feveria Central Kasara Lac Minara\n\nDans quel district vivait le premier cas de fièvre typhoïde notifié en 2024?\n\n Kasara Feveria Central Lac Minara Je ne peux pas encore le savoir!\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVous pouvez maintenant observer une épicurve par maladie, avec des couleurs reflétant le district dans lequel le cas résidait.\nVous pouvez voir que les 15 cas de dengue signalés au cours d’une seule semaine résidaient dans trois districts différents. Vous pouvez également voir que le premier cas de typhoïde a été signalé à Feveria Central.\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) + \n  facet_wrap(.~maladie_notifiee)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nVous pouvez ajouter, préciser ou modifier :\n\nLe thème/l’apparence de l’ensemble du graphique (par exemple, la couleur d’arrière-plan ou l’apparence des lignes de la grille)\nLe titre, sous-titre… et les étiquettes des axes\nLes couleurs des barres (avec scale_fill_manual())\nLe formatage et l’espacement des dates le long de l’axe des x (avec scale_x_date)\nBeaucoup d’autres choses !\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nLe choléra et la fièvre typhoïde semblent-ils endémiques ?\n\n Non, les données suggèrent des épidémies occasionnelles de faible ampleur Oui, ils sont tous deux endémiques\n\nY a-t-il une période particulière de l’année où le paludisme a atteint un pic en 2024 ?\n\n Oui, vers novembre/décembre Oui, vers juillet/août (été) Non, le nombre de cas est constamment élevée\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nVoici le code pour un formatage complet. Notez que d’autres changements ont été apportés, notamment la spécification que nous ne voulons que deux colonnes de mini-graphiques dans facet_wrap() et que l’étiquette de la date le long de l’axe des x ne doit indiquer que le jour et le mois (et non l’année, puisque tous les cas sont en 2024 de toute façon).\n\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) +\n  facet_wrap(.~maladie_notifiee, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District de résidence\",\n       x = \"Date de notification par la clinique\",\n       y = \"Nombre\",\n       subtitle = \"Nombres de cas confirmés de choléra, de dengue, de paludisme de fièvre typhoïde et de fièvre jaune par semaine à Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nLes courbes épidémiques montrent également que le choléra et la typhoïde semblent se manifester sous la forme de flambées isolées, plutôt que de présenter un caractère endémique. Le paludisme et la dengue ont par contre présenté une circulation à Feveria tout au long de l’année, le paludisme atteignant un pic assez net pendant les mois d’été.\n\n\n\n\n\n\nCette fois, utilisez group_by() et summarize() pour produire un tableau par district indiquant les dates de notifications les plus anciennes et les plus récentes.\nA l’aide d’une fontion filter(), vous pourrez générer ce tableau pour un district à la fois.\n\n\n\n\n\n\nQuestions\n\n\n\n\nQuand le premier cas de dengue a-t-il été signalé à Feveria en 2024 ?\n\n 18 janvier 2024 17 janvier 2024 12 février 2024\n\nQuand le dernier cas de dengue a-t-il été signalé à Feveria Central en 2024 ?\n\n 22 août 2024 18 novembre 2024 25 décembre 2024\n\n\n\n\n\n\n\n\n\n\nCliquez pour voir la solution (essayez d’abord par vous-même !)\n\n\n\n\n\nRegroupez les données par maladie, puis, dans une fonction summarize(), définissez la première et la dernière date pour obtenir la chronologie globale de chaque maladie à Feveria.\n\ndata_jointes_confirme |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  maladie_notifiee prem_notif der_notif \n  &lt;chr&gt;            &lt;date&gt;     &lt;date&gt;    \n1 cholera          2024-06-03 2024-09-23\n2 dengue           2024-01-17 2024-11-18\n3 fievre jaune     2024-03-08 2024-08-23\n4 paludisme        2024-01-08 2024-12-25\n5 typhoide         2024-05-02 2024-11-07\n\n\nAjouter un filter() au code pour consulter les dates de la première notification et de la notification la plus récente pour le district qui vous intéresse.\n\ndata_jointes_confirme |&gt; \n  filter(district_residentiel == \"Feveria Central\") |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  maladie_notifiee prem_notif der_notif \n  &lt;chr&gt;            &lt;date&gt;     &lt;date&gt;    \n1 cholera          2024-06-03 2024-09-23\n2 dengue           2024-01-29 2024-08-22\n3 paludisme        2024-01-29 2024-12-17\n4 typhoide         2024-05-02 2024-11-07"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#conclusion",
    "href": "pages/multidisease_surveillance.fr.html#conclusion",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Superbe ! Conformément aux objectifs de cette étude de cas, vous avez fait ce qui suit :\n\nVous avez utilisé des fonctions clés de R pour nettoyer, remodeler et joindre des ensembles de données, et vous avez créé de nouvelles colonnes à l’aide de conditions logiques.\nPour obtenir des informations sur le traitement des données, vous avez procédé à des analyses exploratoires et à des vérifications des données tout au long du processus.\nVous avez effectué une analyse descriptive approfondie pour comprendre les données de laboratoire et de notification, avant et après la jointure. En réponse aux quatre questions initiales de votre superviseur, vous pouvez dire :\n\nCombien de cas suspects des différentes maladies à déclaration obligatoire ont été signalés en 2024, et lesquels étaient les plus fréquents ? Le paludisme était la maladie à déclaration obligatoire la plus courante à Feveria en 2024. Selon le système de surveillance des maladies à déclaration obligatoire : Il y a eu 533 cas suspects de paludisme, 273 cas suspects de dengue, 100 cas de fièvre jaune, 46 cas de choléra et 35 cas de typhoïde.\nQuel pourcentage de ces cas a été confirmé ? Près de 80 % des cas à déclaration obligatoire signalés en 2024 avaient donné lieu à un résultat de test de laboratoire au moment de la jointure des données, avec quelques variations selon les maladies. Au total, 56 % des cas notifiés ont finalement été confirmés, mais ce pourcentage variait de 23 % seulement pour la fièvre typhoïde (7 cas confirmés sur 31 cas suspects avec résultats de tests) à 95 % pour le choléra (38 cas confirmés sur 40 cas suspects avec résultats de tests). En outre, le taux de positivité était plus élevé pour les cas présumés de dengue que pour les cas présumés de paludisme (87 % contre 41 %).\nCombien de cas confirmés de différentes maladies à déclaration obligatoire ont été signalés en 2024, et laquelle était la plus fréquente ? Les cas confirmés ont suivi une tendance légèrement différente de celle des cas suspects : l’infection la plus fréquemment signalée était la dengue avec 186 cas, suivie du paludisme (174), puis du choléra (38), de la fièvre jaune (33) et de la fièvre typhoïde (7).\nComment les cas confirmés se répartissent-ils géographiquement et temporellement dans la région de Feveria ? Feveria a connu une transmission de la dengue et du paludisme tout au long de l’année, avec un pic en été, et concentrée dans le district de Lac Minara. Feveria a également connu de petites et rares épidémies de maladies diarrhéiques, telles que le choléra et la fièvre typhoïde, en particulier dans la zone urbaine de Feveria Central, où l’eau et l’assainissement peuvent poser problème.\n\nEnfin, vous avez pu réfléchir à la manière dont les processus des systèmes de surveillance des maladies à déclaration obligatoire et ceux des tests de diagnostique de laboratoire, par exemple le transfert des données entre les cliniques et les laboratoires, peuvent affecter la qualité et l’exhaustivité des données, et donc vos résultats.\n\nIl reste encore beaucoup de possibilités. Vous pouvez explorer les distributions des maladies par âge ou par sexe, calculer des taux d’incidence ou de prévalence des maladies à l’aide de données démographiques et même analyser les délais de déclaration en examinant les différentes dates de vos ensembles de données.\nVous avez acquis de solides bases et vous êtes bien équipé pour passer à l’étape suivante de votre analyse. Continuez, des découvertes passionnantes vous attendent !\nPour en savoir plus, consultez les autres études de cas ou plongez dans le Epi R Handbook."
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#code-de-nettoyage-et-danalyse-des-données",
    "href": "pages/multidisease_surveillance.fr.html#code-de-nettoyage-et-danalyse-des-données",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Vous trouverez ci-dessous un script de toutes les étapes de nettoyage des données et des analyses descriptives. Notez que les analyses sont combinées à la fin plutôt qu’intercalées entre les étapes de nettoyage. Il s’agit d’une façon plus ordonnée d’organiser votre script.\nPar souci de concision, le code ci-dessous n’inclut pas toutes les inspections et vérifications effectuées en cours de route, mais vous pouvez décider de créer des sections avec de telles vérifications.\nLe début de votre script doit également contenir des informations pour aider le lecteur à comprendre à quoi sert le script, ainsi que des commentaires tout au long du script. Vous vous remercierez plus tard d’avoir ajouté ces commentaires !\n\n\n\n\n\n\nCode pour nettoyer et analyser les données de notification et les données de laboratoire de Feveria, 2024\n\n\n\n\n\n\n# Code pour nettoyer et analyser les données de notification et les données de laboratoire de Feveria, 2024\n# Date:\n# Author:\n\n# Installation des packages --------------------------------\n# Pour s'assurer que le package \"pacman\" est installé\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# Installation (si nécessaire) depuis le CRAN et chargement des packages à utiliser\npacman::p_load(\n  rio,        # importation de données  \n  skimr,      # aperçu des données\n  janitor,    # nettoyage des données et tableaux descriptifs\n  lubridate,  # manipulation des dates\n  epikit,     # pour créer des catégories d'âge\n  gtsummary,  # statistiques descriptives, tests et régressions \n  apyramid,   # tracé de pyramides des âges \n  flextable,  # tableaux prêts à être présentés\n  naniar,     # analyse des données manquantes\n  remotes,    # pour installer le package permettant de télécharger les données\n  tidyverse   # gestion et visualisation des données\n)\n\n# Importation des données --------------------------------------------\n\n# Données de notification\ndata_notif_brut &lt;- import(\"donnees/multi_maladies_notifications.xlsx\")\n\n# Données de labo\ndata_lab_brut &lt;- import(\"donnees/multi_maladies_tests.csv\")\n\n# Nettoyage des données de notification --------------------------------\ndata_notif &lt;- data_notif_brut |&gt; \n  clean_names() |&gt; \n  rename(date_notif = date_signalee_par_letablissement_de_sante_la_communaute,\n         id_notification = id_de_notification) |&gt; \n  select(id_notification, district_residentiel, maladie_notifiee, date_notif) |&gt; \n  mutate(district_residentiel = case_match(str_to_title(district_residentiel),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lac Minara\", \"Au Bord Du Lac\") ~ \"Lac Minara\")) |&gt; \n  mutate(date_notif = ymd(date_notif)) \n\n\n# Nettoyage et consolidation des données de labo -----------------------\n# Nettoyage des valeurs\ndata_lab &lt;- data_lab_brut |&gt; \n  mutate(valeur = case_match(valeur, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positif\",\n                            \"N\" ~ \"Négatif\",\n                            \"I\" ~ \"Indéterminé\"))\n\n# Création de la base de données de labo orientée tests\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(cible != \"Dengue IgG\") |&gt; \n  group_by(id_echantillon) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Création de la base de données de labo orientée cas\ndata_lab_cas &lt;- data_lab_tests |&gt; \n  group_by(id_notification) |&gt; \n  arrange(desc(valeur)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Jointure des données de notification et de labo -----------------\ndata_jointes &lt;- left_join(data_notif, data_lab_cas, by = \"id_notification\")\n\n# Nettoyage des données jointes -----------------------------------\ndata_jointes &lt;- data_jointes |&gt; \n  mutate(cas_categorie = case_when(valeur==\"Positif\" ~ \"Confirmé\",\n                                   valeur==\"Négatif\" ~ \"Ecarté\",\n                                   valeur==\"Indéterminé\" | is.na(valeur) ~ \"Suspect\"))\n\ndata_jointes_confirme &lt;- data_jointes |&gt; \n  filter(cas_categorie==\"Confirmé\")\n\n# ANALYSE ---------------------------------------------------------\n# Nombre de cas suspects à Feveria\ntabyl(data_notif, maladie_notifiee)\n\n# Distribution des cas suspects par district\ntabyl(data_notif, maladie_notifiee, district_residentiel) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribution des résultats de test par type de test\ntabyl(data_lab_tests, test, valeur) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des catégories de cas dans les données jointes\ntabyl(data_jointes, cas_categorie) \n\n# Distribution des catégories de cas par maladie dans les données jointes\ntabyl(data_jointes, maladie_notifiee, cas_categorie) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des catégories de cas par maladie dans les données jointes, uniquement pour les cas avec un résultat de test valide\ndata_jointes |&gt; \n    filter(cas_categorie != \"Suspect\") |&gt; \n    tabyl(maladie_notifiee, cas_categorie) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution des cas confirmés par district\ndata_jointes_confirme |&gt; \n  tabyl(maladie_notifiee, district_residentiel) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualisation de l'évolution temporelle de le nombre de cas confirmé par district\ndata_jointes_confirme |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_notif, fill = district_residentiel)), binwidth=7) +\n  facet_wrap(.~maladie_notifiee, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District de résidence\",\n       x = \"Date de notification par la clinique\",\n       y = \"Nombre\",\n       subtitle = \"Nombres de cas confirmés de choléra, de dengue, de paludisme de fièvre typhoïde et de fièvre jaune par semaine à Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# Première et dernière date de notification de cas confirmé par maladie\ndata_jointes_confirme |&gt; \n  group_by(maladie_notifiee) |&gt; \n  summarize(prem_notif = min(date_notif), \n            der_notif = max(date_notif)) |&gt;\n  ungroup()"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#informations-sur-létude-de-cas",
    "href": "pages/multidisease_surveillance.fr.html#informations-sur-létude-de-cas",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Auteurs originaux Paula Blomquist et Alanah Jansen, avec le soutien technique du CDC Global Surveillance, Laboratory, and Data Systems Branch en collaboration avec TEPHINET.\nSource des données Données fictives fournies par Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nModifications apportées\nVersion\nAuteur\n\n\n\n\nJuillet 2025\nPremière version\n1\nPaula Blomquist et Alanah Jansen, Applied Epi, avec le soutien technique du CDC Global Surveillance, Laboratory, and Data Systems Branch en collaboration avec TEPHINET.\n\n\nAoût 2025\nTraduction française\n1\nLaurent LeHot et Olivia Boyd"
  },
  {
    "objectID": "pages/multidisease_surveillance.fr.html#conditions-dutilisation",
    "href": "pages/multidisease_surveillance.fr.html#conditions-dutilisation",
    "title": "Jonction et analyse des données de notification et des données de laboratoire dans R",
    "section": "",
    "text": "Clause de non-responsabilité Les informations présentées dans cet exercice et les fichiers de données associés ont été développés pour aider les apprenants à atteindre les objectifs d’apprentissage prévus. Le contenu est celui de l’auteur ou des auteurs et ne représente pas nécessairement les opinions officielles du CDC, du US Department of Health and Human Services ou de TEPHINET.\nLicence d’utilisation Licence : Cette étude de cas est sous licence licence CC BY-NC-SA 4.0. Pour plus d’informations sur le partage et l’adaptation de cette étude de cas, voir le certificat associé.\nFinancement Cette étude de cas a été soutenue à 100 % par l’accord de coopération numéro NU2HGH000044 financé par le US Centers for Disease Control and Prevention (CDC)"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html",
    "href": "pages/multidisease_surveillance.es.html",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Herramienta: R Complejidad técnica: Intermedia Complejidad metodológica: Básica\nConocimientos previos necesarios: Fundamentos de R - uso de Rstudio, paquetes de R, funciones y argumentos, uso de tuberías - así como funciones clave de tidyverse y ggplot2.\nFuente: Applied Epi, con el apoyo técnico de la Subdivisión de Vigilancia Mundial, Laboratorios y Sistemas de Datos de los CDC, en colaboración con TEPHINET.\nDuración estimada: 4 horas\n\n\n\nPara obtener instrucciones sobre cómo utilizar nuestros estudios de caso, consulte la guía práctica. Puede enviar sus comentarios y sugerencias a contact@appliedepi.org. También puede debatir el caso práctico o los conceptos relacionados en la Comunidad de Epi Aplicada.\n\n\nUsted es epidemiologo o epidemióloga en la oficina nacional de vigilancia de Feveria, un pequeño país tropical compuesto por tres distritos:\n\nFeveria Central: zona urbana densamente poblada, con infraestructuras de agua y saneamiento a veces poco fiables.\nLago Minara: zona lacustre con buena infraestructura, pero con gran abundancia de mosquitos durante los meses más cálidos del año.\nKasara: zona suburbana situada al otro lado de Feveria Central.\n\nMapa de los distritos de Feveria\n\nEs enero 2025, y su supervisor quiere que transfiera la rutina de procesamiento de enfermedades de declaración obligatoria de Excel a R, y que realice algunos análisis de datos. Como mínimo, quiere saber:\n\n¿Cuántos casos sospechosos de las diferentes enfermedades de declaración obligatoria se notificaron en 2024, y cuál fue la más frecuente?\n¿Qué porcentaje de ellos fue confirmado?\n¿Cuántos casos confirmados de las diferentes enfermedades de declaración obligatoria se notificaron en 2024, y cuál fue la más frecuente?\n¿Cómo se distribuyeron geográfica y temporalmente los casos confirmados en Feveria?\n\nSu supervisor le pide que escriba código para importar, limpiar, combinar y analizar las siguientes listas:\n\nDatos de vigilancia de enfermedades de declaración obligatoria de 2024: también denominados “datos de notificación”, se trata de datos de vigilancia sobre cinco enfermedades de declaración obligatoria notificadas por las clínicas de Feveria: dengue, paludismo, cólera, fiebre tifoidea y fiebre amarilla. Estos corresponden a casos sospechosos, basados en los síntomas de los pacientes. Los clínicos introducen cada notificación en un sistema en línea todos los días de la semana.\nDatos de resultados de pruebas de laboratorio de 2024: procedentes de tres grandes laboratorios de Feveria. Estos resultados corresponden a muestras tomadas de los casos sospechosos de las enfermedades de declaración obligatoria mencionadas anteriormente.\n\n¡Vamos!\n\n\n\nEn este caso práctico deberá:\n\nUtilizar funciones clave de R para limpiar datos, remodelar bases de datos, combinar fuentes de datos y crear nuevas columnas mediante condiciones lógicas, con el fin de preparar los datos para el análisis.\nRealizar inspecciones de datos y comprobaciones de calidad en diferentes fases del proyecto, comprendiendo su importancia para garantizar un análisis fiable.\nLlevar a cabo análisis descriptivos básicos para comparar las tendencias de las enfermedades entre distintas fuentes de datos, tanto antes como después de la vinculación.\nInterpretar las diferencias en los resultados de las distintas fuentes de datos y comprender cómo éstas reflejan la estructura y el diseño del sistema de vigilancia.\n\n\n\n\n\n\nEmpiece por establecer un flujo de trabajo reproducible y bien organizado. Esto le facilitará repetir el análisis siempre que sea necesario.\nTareas:\n\nConfigurar un proyecto en RStudio.\nEstablecer subcarpetas claras para su código, datos y resultados.\nCrear un script en R, o un archivo R Markdown si lo prefiere. Asegúrese de que el propósito del script, la fecha y el autor figuren como comentarios en la parte superior del archivo.\nExtra: compruebe que el idioma de trabajo en RStudio sea el adecuado (por ejemplo, español para este ejercicio).\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\n\nCree una carpeta donde fuardará todo el trabajo de este caso práctico. Por ejemplo, puede llamarla ‘multienfermedad_lab’ y crearla en el escritorio de su ordenador. En esta carpeta debe crear su proyecto de RStudio.\nLe sugerimos crear las siguientes subcarpeta: scripts (para su código), datos (para sus datos), y resultados (para sus resultados analíticos).\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nCree una carpeta (por ejemplo: ‘multienfermedad_lab’ en su escritorio) para su trabajo. Para crear un proyecto de Rstudio en su nueva carpeta, haga clic en la esquina superior izquierda de R Studio y seleccione la opción New Project..., luego seleccione Existing Directory y, a continuación, en Browse para seleccionar su nueva carpeta. Para obtener más información, consulte la sección proyectos en R del Manual de R para Epis.\nInicie un nuevo script de R haciendo clic en New File en la parte superior izquierda de RStudio y, a continuación, seleccione R Script. Guárdelo de inmediato en la ubicación apropiada, por ejemplo, en la subcarpeta scripts de su proyecto.\nEn la parte superior de su nuevo script de R, escriba información esencial como su nombre, el propósito del archivo y la fecha.\nTenga en cuenta que su configuración regional en R determina el idioma y la localización que se utilizarán para aspectos como los formatos de fecha o las traducciones. Si su configuración regional es distinta del idioma que desea para su informe (por ejemplo, configuración regional en español frente a un informe en inglés), puede cambiarla al inglés ejecutando: Sys.setlocale(\"LC_ALL\", \"English\").\nIncluya esta línea en su script si fuera necesario, o bien omítala si su configuración regional ya es la adecuada. Esto se explica con más detalle en la Guía práctica.\n\n\n\n\n\n\nA continuación, en su script de R, debe instalar y cargar los paquetes necesarios. Esto garantiza que las funciones que necesita estén disponibles para realizar su análisis.\nNecesitará los siguientes paquetes:\n{rio} (para importar datos) {skimr} (para revisar datos) {janitor} (para limpiar datos) {lubridate} (para la gestión de fechas y tiempos) {epikit} (para tareas relacionadas con epidemiología) {gtsummary} (para estadísticas descriptivas, pruebas y regresión) {apyramid} (para pirámides de edad y sexo) {flextable} (para generar tablas listas para su presentación) {naniar} (para evaluar datos faltantes) {tidyverse} (para tareas generales de manipulación y análisis de datos)\nAdemás, necesitará {remotes} para descargar datos, algo que se explicará en la sección correspondiente a descargas.\nMientras empieza, su colega de confianza le da un codazo y le susurra: “He oído que una forma estupenda de gestionar sus paquetes… es con el paquete {pacman}”.\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice la función p_load() del paquete {pacman} para esta tarea. Es suficiente con proporcionarle una lista de los paquetes que desee utilizar. La función realiza dos pasos por cada paquete:\n\nComprueba si el paquete está instalado en su ordenador y, si no lo está, lo instala automáticamente.\nCarga el paquete para que pueda usarse durante la sesión de R.\n\nSi aún no tiene instalado {pacman}, deberá hacerlo a la manera tradicional, con install.packages().\nTenga en cuenta que el orden de los paquetes en p_load() puede ser importante. Si dos paquetes contienen funciones con el mismo nombre (por ejemplo, select() en {MASS} y select() en {tidyverse}), R utilizará la versión del paquete cargado más recientemente. Por ello, se recomienda cargar {tidyverse} en último lugar para priorizar sus funciones, muy utilizadas en la manipulación y visualización de datos.\n\n# Asegurarse de que el paquete \"pacman\" está instalado\nif (!require(\"pacman\")) { install.packages(\"pacman\") }\n\n# Instalar (si es necesario) desde CRAN y cargar los paquetes a utilizar\npacman::p_load(\n  rio,        # importar datos  \n  skimr,      # revisar datos de forma rápida\n  janitor,    # limpieza de datos y tablas\n  lubridate,  # manejo de fechas\n  epikit,     # crear categorías de edad\n  gtsummary,  # estadísticas descriptivas, pruebas y regresión \n  apyramid,   # crear pirámides de edad y sexo \n  flextable,  # tablas listas para presentación\n  naniar,     # explorar datos faltantes\n  remotes,    # instalar paquetes para descarga de datos\n  tidyverse   # manipulación y visualización de datos (último, para priorizar sus funciones)\n)\n\n\n\n\n\n\n\n\n\n\nSu oficina le proporciona dos archivos para su análisis, ambos correspondientes al año 2024 y actualizados al 15 de enero de 2025:\n\nUna base de datos de notificación de enfermedades (“notificaciones_multienfermedad.xlsx”) con los casos procedentes de 5 centros de salud.\nUna base de datos de pruebas de laboratorio (“pruebas_multienfermedad.csv”) enviada por tres laboratorios que realizan pruebas para los mismos 5 centros de salud.\n\nPara este estudio de caso, puede descargar los datos desde la página web de Applied Epi mediante el paquete {appliedepidata}. Siga estos pasos:\n\nInstale el paquete {appliedepidata} desde GitHub utilizando el comando install_github() del paquete {remotes} (que ya instaló anteriormente):\n\n\n# Usar la función install_github de remotes para instalar {appliedepidata}\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nGuarde las dos bases de datos en una carpeta específica utilizando la función save_data() del paquete {appliedepidata}. Este código guardará los archivos en la subcarpeta datos dentro de la carpeta de su proyecto en RStudio. Tenga en cuenta que, si no especifica ninguna ubicación en el argumento path, aparecerá una ventana para que seleccione manualmente la carpeta.\n\n\n# Guardar los dos archivos de datos usando la función save_data() de appliedepidata\nappliedepidata::save_data(\"pruebas_multienfermedad\",\n                          path = \"datos\")\n\nappliedepidata::save_data(\"notificaciones_multienfermedad\",\n                          path = \"datos\")\n\n\n\n\n¡Gracias a la oficina nacional y a Applied Epi! Ahora es el momento de importar los datos desde la carpeta a RStudio, para poder analizarlos.\n\n\nLo ideal es que utilice la misma función para importar ambas bases de datos al Entorno, aunque uno sea un archivo .csv y el otro un .xlsx. A partir de ahora, cuando hablemos de Entorno, nos referiremos al panel Environment (Entorno en español) de RStudio.\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nUtilice la función import() del paquete {rio}, que reconoce e importa distintos tipos de archivos. De esta manera no tendrá que usar funciones específicas según el formato, como read.csv() de {base} para archivos .csv o read_excel() de {readxl} para archivos .xlsx.\nSi quiere más información sobre la importanción de datos, puede consultar la sección Importar y exportar de nuestro manual de R.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nA continuación se muestra cómo importar los dos archivos utilizando la función import(). Los datos se guardan en dos objetos:\n\ndata_notif_crudos para los datos de notificaciones,\ndata_lab_crudos para los datos de laboratorio.\n\nEl sufijo *_crudos* le servirá para distinguirlos de las versiones depuradas que creará más adelante.\n\n# Importar datos\n\n# Datos de notificación\ndatos_notif_crudos &lt;- import(\"datos/notificaciones_multienfermedad.xlsx\")\n\n# Datos de laboratorio\ndatos_lab_crudos &lt;- import(\"datos/pruebas_multienfermedad.csv\")\n\n\n\n\n\n\n\n\n\nYa tiene los datos, y ahora es el momento de ver qué historia cuentan. Tómese un momento para comprobar su contenido y su calidad.\n\n\n\n\nUtilice las siguients funciones para explorar sus datos: skim() del paquete {skimr}, names(), col() y nrow().\nskim() le proporciona información muy completa sobre la estructura y el contenido de los datos. names() le mostrará los nombres de las columnas. ncol() y nrow() cuentan, respectivamente, el número de columnas y de filas de su base de datos.\nPiense: ¿qué debe poner dentro de los paréntesis de cada función?\nLas pista más sencilla está en su Entorno. Recuerde que el objeto que contiene los datos de notificación se llama: datos_notif_crudos.\nSi necesita ayuda, haga click en el cuadro de soluciones situado debajo de las preguntas.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas hay en los datos de notificación?\n\n 10 11 12 13\n\n¿Cuál de estas columnas NO aparece en los datos?\n\n Fecha de inicio Fecha notificada por el centro de salud/la comunidad Fecha del resultado Fecha de la prueba Fecha de nacimiento\n\n¿Cuál es el nombre de la columna en los datos de notificación que identifica cada notificación?\n\n ID de notificacion ID prueba Codigo del centro de salud Combinación de ID de notificacion y Sexo\n\n¿Cuántas filas hay en los datos de notificación?\n\n 987 1314 950 778\n\n¿Qué tipo de información NO se encuentra en los datos de notificación?\n\n Resultados de pruebas de laboratorio Distrito de residencia Fecha de nacimiento y sexo Centro de salud donde se diagnosticó el caso Resultado\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice skim() del paquete {skimr} para ver un resumen de toda la base de datos, y View() para visualizar directamente los datos completos:\n\nskim(datos_notif_crudos)\n\nTambién puede emplear names() para imprimir únicamente los nombres de las columnas. Tanto con skim() como con names() podrá observar los tipos de información incluidos: el centro sanitario del caso, la fecha de nacimiento, el sexo, un indicador de embarazo, el distrito de residencia, la fecha de inicio de síntomas y la fecha notificada por la clínica, así como información sobre el desenlace.\nAdemás, encontrará una columna ID de notificacion que parece ser un identificador único para cada caso, aunque conviene comprobar posibles duplicados antes de confirmarlo.\nTenga en cuenta que en estos datos no hay resultados de laboratorio, ya que las notificaciones proceden de las clínicas, que notifican enfermedades de declaración obligatoria en base a criterios clínicos.\n\nnames(datos_notif_crudos)\n\n [1] \"Nombre de la unidad organizativa\"                    \n [2] \"Codigo del centro de salud\"                          \n [3] \"ID de notificacion\"                                  \n [4] \"Fecha de nacimiento\"                                 \n [5] \"Sexo\"                                                \n [6] \"Embarazada\"                                          \n [7] \"Distrito residencial\"                                \n [8] \"Enfermedad notificada\"                               \n [9] \"Fecha de inicio\"                                     \n[10] \"Fecha notificada por el centro de salud/la comunidad\"\n[11] \"Resultado\"                                           \n[12] \"Fecha del resultado\"                                 \n\n\nPara obtener el número de columnas y de filas puede utilizar:\n\nncol(datos_notif_crudos)\nnrow(datos_notif_crudos)\n\nEsto imprimirá en la consola el número de columnas y de filas de la base de datos.\n\n\n[1] 12\n\n\n[1] 987\n\n\nOtra manera rápida es mirar el Entorno en RStudio, donde verá, junto al nombre de la base de datos, el número de observaciones (filas) y de variables (columnas).\n\n\n\n\n\n\nUtilice skim() del paquete {skimr} o la función class() para comprobar las clases de las columnas.\n¿Recuerda cómo indicar la columna de interés dentro de la función class()? Alternativamente, puede observar el panel de Entorno en RStudio, donde aparece la clase de cada columna junto a su nombre.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas de la base de datos de notificación reconoce R como columnas de tipo fecha?\n\n 0 2 4\n\n¿Cuál es la clase de la mayoría de las columnas en la base de datos de notificación en bruto?\n\n character (texto) numeric (numérico) factor\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPuede usar class() como en el ejemplo siguiente. El operador $ sirve para seleccionar una columna concreta de la base de datos datos_notif_crudos. Fíjese en que se usan comillas invertidas (`) alrededor de Fecha de nacimiento porque el nombre de la columna contiene espacios.\n\nclass(datos_notif_crudos$`Fecha de nacimiento`)\n\nPara ver la clase desde el panel Entorno, haga click en la flecha azul junto con el nombre de la base de datos: aparececerán los nombres de las columnas con su clase al lado (por ejemplo, “chr” para indicar clase character o nominal)\nVerá que ninguna de las columnas que deberían ser fechas está reconocida como tal; en su lugar, R las interpreta como texto (character).\n\n\n\n\n\n\nUtilice tabyl() para inspeccionar los valores dentro de las columnas categóricas, especificando en el primer argumento la base de datos y en el segundo el nombre de la columna.\nPor ejemplo, este código tabula los valores de la columna Sexo. La salida muestra que los valores “masculino” y “femenino” están escritos de manera incoherente, por lo que esta columna necesitaría limpieza antes del análisis:\n\ntabyl(datos_notif_crudos, Sexo)\n\n      Sexo   n    percent valid_percent\n         F  47 0.04761905    0.05452436\n  FEMENINO 146 0.14792300    0.16937355\n         M  40 0.04052685    0.04640371\n MASCULINO 172 0.17426545    0.19953596\n         f 154 0.15602837    0.17865429\n  femenino  98 0.09929078    0.11368910\n         m 119 0.12056738    0.13805104\n masculino  86 0.08713273    0.09976798\n      &lt;NA&gt; 125 0.12664640            NA\n\n\nPara inspeccionar los valores faltantes (o perdidos), puede usar la función miss_var_summary() del paquete {naniar}:\n\nmiss_var_summary(datos_notif_crudos)\n\n# A tibble: 12 × 3\n   variable                                             n_miss pct_miss\n   &lt;chr&gt;                                                 &lt;int&gt;    &lt;num&gt;\n 1 Fecha de inicio                                         691     70.0\n 2 Embarazada                                              510     51.7\n 3 Resultado                                               197     20.0\n 4 Fecha del resultado                                     197     20.0\n 5 Fecha de nacimiento                                     168     17.0\n 6 Sexo                                                    125     12.7\n 7 Nombre de la unidad organizativa                          0      0  \n 8 Codigo del centro de salud                                0      0  \n 9 ID de notificacion                                        0      0  \n10 Distrito residencial                                      0      0  \n11 Enfermedad notificada                                     0      0  \n12 Fecha notificada por el centro de salud/la comunidad      0      0  \n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Los valores de la columna Distrito residencial están estandarizados?\n\n No: necesitan limpieza Sí: están estandarizados y listos para usarse en el análisis\n\n¿Los valores de la columna Enfermedad notificada están estandarizados?\n\n No: necesitan limpieza Sí: están estandarizados y listos para usarse en el análisis\n\n¿Qué reconoce R como un valor faltante?\n\n Sin valor, o solo un espacio, o solo un punto Sin valor en una celda, representado como NA Las palabras 'desconocido' e 'incierto'\n\nSegún los valores faltantes, ¿es útil la columna Fecha de inicio?\n\n Sí, la cantidad de valores faltantes es baja y esta columna es útil No demasiado: la ausencia es muy alta\n\n¿Por qué algunas columnas en los datos de notificación pueden tener grafías diferentes y categorías no estandarizadas?\n\n Un bot revuelve los datos para que sean menos identificables Cada clínica puede usar software configurado de forma diferente, o permitir entradas de texto libre, lo que genera variaciones en la ortografía El software de vigilancia usado en las clínicas tiene muchos errores en el código\n\n¿Por qué algunas columnas en los datos de notificación pueden tener una alta proporción de valores faltantes?\n\n El personal sanitario no pregunta al paciente durante la consulta El paciente no sabe o no quiere dar la respuesta El personal sanitario no tiene tiempo de completar ese campo, aunque sepa la información Todas las anteriores, y muchas más razones\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUse tabyl() para tabular los valores de la columna Distrito residencial. De nuevo, el primer argumento es el nombre de la base de datos y el segundo el nombre de la columna:\n\ntabyl(datos_notif_crudos, `Distrito residencial`)\n\n Distrito residencial   n    percent\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n          LAGO MINARA 185 0.18743668\n          Lago Minara  68 0.06889564\n             Lakeside 125 0.12664640\n\n\nVerá que cada una de las tres ubicaciones (Feveria Central, Lago Minara y Kasara) aparece escrita de distintas maneras y con diferentes mayúsculas. Esto deberá limpiarse si se quiere analizar la distribución geográfica de las enfermedades de declaración obligatoria.\nDe forma similar, utilice tabyl() para tabular los valores de la columna Enfermedad notificada. En este caso, verá que están escritos de forma adecuada y coherente, de modo que se puede analizar la distribución de los casos por enfermedad sin necesidad de más limpieza:\n\ntabyl(datos_notif_crudos, `Enfermedad notificada`)\n\n Enfermedad notificada   n    percent\n                colera  46 0.04660588\n                dengue 273 0.27659574\n       fiebre amarilla 100 0.10131712\n       fiebre tifoidea  35 0.03546099\n             paludismo 533 0.54002026\n\n\nPara comprobar los valores faltantes también puede usar is.na(). En el ejemplo siguiente, la función evalúa cada celda de la columna Fecha de inicio, devolviendo TRUE si falta el valor y FALSE si está presente. Si aplica tabyl() a este resultado, obtendrá de inmediato un recuento y un porcentaje claros de valores faltantes y no faltantes en esa columna.\nRecuerde: valores como un espacio vacío o las palabras “Desconocido” o “Faltante” no son reconocidos por R como NA. Solo los valores realmente en blanco, representados con NA, se consideran ausentes.\nEn el caso de Fecha de inicio, puede comprobar que aproximadamente un 70 % de las filas carecen de fecha de inicio, lo que hace que esta columna sea poco útil para analizar tendencias temporales.\n\ntabyl(is.na(datos_notif_crudos$`Fecha de inicio`))\n\n is.na(datos_notif_crudos$`Fecha de inicio`)   n   percent\n                                       FALSE 296 0.2998987\n                                        TRUE 691 0.7001013\n\n\nLos valores faltantes o las categorías no estandarizadas pueden deberse a muchas razones:\n\nEl diseño de la herramienta de recogida de datos (por ejemplo, si un campo es obligatorio o si se permite texto libre en lugar de listas desplegables),\nLos procesos y normas vigentes (por ejemplo, qué campos prioriza el personal),\nFactores contextuales (como la carga de trabajo o el tiempo disponible para recopilar la información).\n\n\n\n\n\n\n\n\n\n\nIgual que con los datos de vigilancia, utilice skim(), ncol() y nrow() o consulte el panel Entorno para inspeccionar los datos de laboratorio.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué base de datos tiene más columnas: la de notificación o la de laboratorio?\n\n Datos de laboratorio Datos de notificación Tienen el mismo número de columnas\n\n¿Qué base de datos tiene más filas: la de notificación o la de laboratorio?\n\n Datos de laboratorio Datos de notificación Tienen el mismo número de filas\n\nInspeccione los datos de laboratorio con View(). ¿Por qué podría haber más registros en la base de datos de laboratorio?\n\n Puede haber varias pruebas u objetivos por muestra Hay muchos resultados de pruebas de ensayo en los datos No todas las notificaciones tienen resultados de laboratorio todavía\n\n¿Cuál de estas columnas NO está en la base de datos de laboratorio?\n\n ID de notificacion ID de muestra Prueba Fecha de nacimiento Valor\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl igual que en la sección 3.1, puede utilizar skim() del paquete {skimr} para visualizar toda la base de datos del laboratorio con los resultados de las pruebas. Esto también le mostrará los distintos nombres de las columnas, poniendo de manifiesto que la base de datos del laboratorio solo contiene información sobre la prueba y no sobre el paciente. No obstante, también incluye un identificador de notificación similar, similar a los datos de notificación.\n\nskim(datos_lab_crudos)\n\nUtilice ncol() y nrow() para imprimir el número de columnas y filas, de la siguiente forma:\n\nncol(datos_lab_crudos)\nnrow(datos_lab_crudos)\n\nEsto mostrará en su consola el número de columnas y de filas, de manera que podrá comprobar que la base de datos de laboratorio tiene más filas que la base de datos de notificación que inspeccionó anteriormente.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nA menudo hay más registros en la base de datos de laboratorio que en los datos clínicos. Si inspecciona los datos con View(datos_lab_crudos) y luego hace clic en la flecha de la parte superior de la columna ID de notificacion para ordenarla alfabéticamente, verá que varias filas comparten el mismo ID de notificacion. Esto puede suceder cuando se analizan varios objetivos de la misma muestra (mismo identificador de muestra), o cuando se repite el análisis de un caso (lo que da lugar a un identificador de muestra diferente).\n\nView(datos_lab_crudos)\n\n\n\nnombre_laboratorioid_notificacionid_muestrafecha_pruebapruebaobjetivovalorHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nAl igual que en el caso anterior, utilice las funciones class(), skim()o tabyl(), o inspeccione el Entorno, para observar las columnas con más detalle.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas de la base de datos de laboratorio reconoce R como columnas de tipo fecha?\n\n 0 1 2\n\n¿Cuántas columnas de la base de datos de laboratorio tienen datos completos?\n\n 1 3 7 (Todas)\n\n¿Qué prueba detecta múltiples objetivos (y, por lo tanto, tiene varias filas por muestra)?\n\n Paludismo Dengue Fiebre Amarilla Cólera Fiebre tifoidea\n\n¿Cuántos valores posibles de resultado de prueba hay en la columna valor?\n\n 5 3 4\n\n¿Cuál de estos NO es un posible resultado en la prueba de cultivo de heces que detecta la bacteria V. cholerae?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nLos datos de laboratorio tienen una columna de fecha reconocida por R con la clase “IDate”. Se trata de una clase de fecha que suele aparecer al importar CSV con la función import() de {rio}. Igual que la clase “Date” de R base, permite ordenar por fecha y analizar tendencias en el tiempo.\n\nclass(datos_lab_crudos$fecha_prueba)\n\n[1] \"IDate\" \"Date\" \n\n\nEl uso de la función miss_var_summary() del paquete {naniar} muestra que todas las columnas de los datos de laboratorio están completas. Esto puede deberse a que los sistemas de laboratorio utilizan procesos automatizados, por lo que es menos probable que se produzcan errores humanos.\n(Punto importante: Tenga en cuenta que, en la vida real, los datos de laboratorio también presentarían probablemente algunos problemas).\n\nmiss_var_summary(datos_lab_crudos)\n\n# A tibble: 7 × 3\n  variable           n_miss pct_miss\n  &lt;chr&gt;               &lt;int&gt;    &lt;num&gt;\n1 nombre_laboratorio      0        0\n2 id_notificacion         0        0\n3 id_muestra              0        0\n4 fecha_prueba            0        0\n5 prueba                  0        0\n6 objetivo                0        0\n7 valor                   0        0\n\n\nPara ver cuántos objetivos se detectan en cada prueba, puede realizar una tabulación cruzada de las columnas prueba y objetivo con tabyl(). Escriba los nombres de las columnas en la función como dos argumentos separados. La salida muestra que cada prueba se alinea claramente con uno o más objetivos, y solo la prueba de dengue detecta más de un objetivo (IgG, IgM y NS1).\nConsejo: Pruebe a cambiar el orden de los nombres de las columnas en la función para ver el impacto en la tabla.\n\ntabyl(datos_lab_crudos, objetivo, prueba)\n\n             objetivo Cultivo de heces Dengue NS1/IgG/IgM Hemocultivo IgM ELISA\n Bacteria V. cholerae               45                  0           0         0\n   Bacterias S. Typhi                0                  0          33         0\n           Dengue IgG                0                215           0         0\n           Dengue IgM                0                215           0         0\n          Dengue NS.1                0                215           0         0\n  Fiebre amarilla IgM                0                  0           0        88\n           Plasmodium                0                  0           0         0\n Microscopía de sangre total\n                           0\n                           0\n                           0\n                           0\n                           0\n                           0\n                         503\n\n\nPor último, puede inspeccionar los distintos valores de los resultados de las pruebas en la columna valor utilizando de nuevo tabyl(). Verá que hay seis resultados posibles, incluidos N (negativo), P (positivo) e I (indeterminado). En el caso del cólera no aparece P, pero sí pueden aparecer P01 y P0139, que en este ejemplo representan positividad para los serogrupos O1 u O139.\n\ntabyl(datos_lab_crudos, prueba, valor)\n\n                      prueba  I   N   P PO1 PO139\n            Cultivo de heces  5   2   0  22    16\n          Dengue NS1/IgG/IgM  0 354 291   0     0\n                 Hemocultivo  2  24   7   0     0\n                   IgM ELISA 10  45  33   0     0\n Microscopía de sangre total 56 257 190   0     0\n\n\n\n\n\n\n\n\n\n\nLos datos de notificación (datos_notif_crudos) contienen información sobre casos sospechosos, junto con datos demográficos básicos (edad, sexo, embarazo, distrito de residencia), e información sobre su fecha de inicio, fecha reportada por el centro de salud, y resultado. Algunas columnas deben limpiarse antes de continuar con el análisis, debido a variaciones en la ortografía de los valores categóricos y a que algunas no se reconocen como fechas.\nAhora comenzará a redactar fragmentos más extensos de código para realizar limpieza de datos, utilizando diversas funciones de {dplyr} encadenadas mediante pipes (que se representan de la siguiente manera: |&gt;).\nNOTA SOBRE PIPES: Los pipes permiten ejecutar varias operaciones en una secuencia continua, “encadenando” diferentes funciones. La salida de una función se convierte en la entrada de la siguiente.\nPara obtener más información sobre el uso de pipes, consultar el Manual de R para Epis.\nCabe destacar que este ejercicio utiliza el pipe de base (|&gt;) en lugar del pipe de magrittr (%&gt;%), ya que resulta más rápido y no requiere instalación de paquetes. Si prefiere, puede utilizar el pipe de magrittr.\n\n\n\n\nDebido a problemas de calidad y de almacenamiento de datos, se recomienda elaborar una lista depurada (linelist) que contenga únicamente la información sobre el identificador único, la ubicación del caso, la enfermedad y la fecha en que la notificación fue reportada al sistema de vigilancia.\nEscribir código en R para generar una nueva base de datos limpio denominado datos_notif, aplicando las siguientes tareas de limpieza:\n\nRenombrar las columnas para que resulten más legibles por las máquinas (eliminando espacios y mayúsculas) mediante la función clean_names() del paquete {janitor}.\nUtilizar la función rename() de {dplyr} para que:\n\nel nombre de la columna con la fecha en la que se notificó el caso se sustituya por un nombre más conciso fecha_notificada.\nel nombre de la columna del identificador de la notificación sea más conciso (id_notificacion).\n\nSeleccionar las columnas relevantes para el análisis con la función select() del paquete {dplyr}.\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nIniciar el código con el nombre de la nueva base de datos, la flecha de asignación y el nombre del objeto de datos en bruto. Esto indica que el resultado del procesamiento de los datos en bruto será asignado a un nuevo objeto denominado datos_notif.\n\ndatos_notif &lt;- datos_notif_crudos\n\nA continuación, construya sobre este código añadiendo funciones adicionales, encadenadas mediante un pipe. Esto permite realizar varias operaciones en una secuencia continua. Primero, utilice clean_names() para estandarizar todos los nombres de columnas. Esta función reemplaza automáticamente los espacios y caracteres especiales por guiones bajos y convierte todo a minúsculas, lo que facilita el manejo de los nombres. Después, utilice rename() para asignar un nombre nuevo a una columna. Recordar que, al usar rename(), la columna ya tendrá la versión transformada por clean_names().\n\n# datos_notif &lt;- datos_notif_crudos |&gt; \n#   clean_names() |&gt; \n#   rename(NOMBRE_NUEVO = NOMBRE_ANTERIOR) |&gt; \n#   select(NOMBRES_VARIABLES)\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAquí está el código para limpiar los nombres de las columnas y seleccionar las columnas adecuadas para análisis:\n\n# Limpiar datos \ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada)\n\n\n\n\n\n\n\nA partir de la inspección de los datos, ya sabe que los valores de la columna distrito_residencial no están estandarizados.\nAgregar una función mutate() para limpiar la columna distrito_residencial, con el fin de:\n\nEstandarizar la capitalización de la columna.\n\nReemplazar la columna existente distrito_residencial por una columna depurada que contenga únicamente los siguientes valores de distrito: “Lago Minara”, “Feveria Central” y “Kasara”.\n\nConsultar la pista para ver qué funciones se pueden utilizar.\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nPrueba a utilizar str_to_title() del paquete {stringr} para que la primera letra de cada palabra sea mayúscula y todas las demás letras sean minúsculas. También puede utilizar case_match() para especificar distintas erratas concretas.\nUtilice la función ‘help’ de RStudio para ver cómo utilizar las funciones. Por ejemplo, escriba ?case_match en su consola para obtener la página de ayuda de la función. NOTA en case_match() - se trata de una función muy útil para sustituir o corregir valores, y sustituye a recode().\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSu código de limpieza debería tener ahora este aspecto:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = str_to_title(distrito_residencial)) |&gt; \n  mutate(distrito_residencial = case_match(distrito_residencial,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\nTambién puede envolver str_to_title en la función case_match() para acortar el código, como se indica a continuación:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt; \n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(str_to_title(distrito_residencial),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\n\n\n\n\n\n\nLa columna correspondiente a la fecha de notificación necesita ser transformada para que sea reconocida como una fecha en R. Esto permitirá analizar tendencias a lo largo del tiempo, incluyendo semanas y meses.\nRevisar los valores dentro de la columna fecha_notificada. Luego, agregar una línea al código de limpieza para convertir fecha_notificada en una clase de fecha.\nConocer la estructura de la columna permitirá utilizar la función adecuada para transformarla en clase de fecha. Se recomienda emplear alguna de las funciones del paquete {lubridate}: ymd() (para fechas escritas como año-mes-día), mdy() (para fechas escritas como mes-día-año) o dmy() (para fechas escritas como día-mes-año). Estas funciones reconocerán cualquier formato de escritura de fecha siempre que el orden sea correcto; por ejemplo, “21st August 2025” y “21-08-2024” serían reconocidos por dmy().\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cómo están formateadas actualmente las fechas?\n\n día-mes-año año-mes-día mes-día-año año-día-mes\n\n¿Qué función de mutate() deberías usar para convertir la columna fecha_notificada en una clase de fecha?\n\n mutate(fecha_notificada = ymd(fecha_notificada)) mutate(fecha_notificada = dmy(fecha_notificada)) mutate(fecha_notificada = mdy(fecha_notificada))\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSe puede utilizar la función head() para visualizar las primeras seis filas de datos de la columna fecha_notificada. Al observarlas, se identifica que están escritas con el año en primer lugar, seguido del mes y, posteriormente, del día.\n\nhead(datos_notif$fecha_notificada)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nSe puede utilizar la función ymd() dentro de mutate() para convertir la clase de la columna fecha_notificada. Es posible verificar que la clase sea la correcta ejecutando posteriormente la función class().\nEl código de limpieza debería ahora tener el siguiente aspecto:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(str_to_title(distrito_residencial),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(fecha_notificada = ymd(fecha_notificada)) \n\nY se puede volver a comprobar la clase con esto:\n\nclass(datos_notif$fecha_notificada)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nLos colegas indican que cada id_notificacion representa un caso sospechoso. Ahora se desea crear una tabla para verificar si id_notificacion se encuentra duplicado en las filas de los datos.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Equivale una fila en los datos de notificación a un caso?\n\n Sí No\n\n¿Necesita depurar (eliminar duplicados) sus datos para el análisis epidemiológico de casos?\n\n Sí No\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nExisten varias formas de realizar esta verificación, pero se sugiere utilizar la función count() de {dplyr}. Esta función creará una tabla que contabiliza el número de filas por cada valor único de la columna que se especifique dentro de la función. Posteriormente, emplear tabyl() para observar la distribución de estos conteos.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPrimero, encadenar los datos de vigilancia mediante un pipe hacia la función count(), indicando la columna id_notificacion como el único argumento. Esto generará una tabla que contabiliza el número de filas por cada valor único de id_notificacion, mostrando el resultado en una nueva columna denominada n. En este extracto se puede observar, por ejemplo, que existe solo una fila para cada uno de estos seis valores de id_notificacion.\n\ndatos_notif |&gt; \n  count(id_notificacion) \n\n\n\n  id_notificacion n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nA continuación, tabular la nueva columna n con la función tabyl(), lo que demuestra que existe únicamente una fila por cada id_notificacion único. Esto significa que una fila equivale a un caso y que no se requiere realizar una deduplicación adicional.\n\ndatos_notif |&gt; \n  count(id_notificacion) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nAhora puede proceder cómodamente al análisis descriptivo de los casos, ya que sus datos están limpios y sabe que una fila equivale a un caso. Utilice la función tabyl() para las siguientes tareas.\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué enfermedad fue diagnosticada con mayor frecuencia por las clínicas en Feveria en 2024?\n\n Cólera Paludismo Dengue Fiebre tifoidea Fiebre amarilla\n\n¿Qué enfermedad fue diagnosticada con menor frecuencia por las clínicas en Feveria en 2024?\n\n Cólera Paludismo Dengue Fiebre tifoidea Fiebre amarilla\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que había 533 casos sospechosos de paludismo en Feveria en 2024, y sólo 35 casos sospechosos de fiebre tifoidea.\n\ntabyl(datos_notif, enfermedad_notificada)\n\n enfermedad_notificada   n    percent\n                colera  46 0.04660588\n                dengue 273 0.27659574\n       fiebre amarilla 100 0.10131712\n       fiebre tifoidea  35 0.03546099\n             paludismo 533 0.54002026\n\n\n\n\n\n\n\n\nUtilice tabyl() para cruzar las columnas de enfermedad y distrito de residencia.\nComplete la tabla incorporando diversas funciones adorn del paquete {janitor}, con el fin de visualizar distribuciones porcentuales, por ejemplo: adorn_percentages(), adorn_pct_formatting() y adorn_ns().\nEscribir el nombre de la función precedido de un signo de interrogación en la consola (por ejemplo, ?adorn_ns) para consultar las páginas de ayuda correspondientes. También se puede revisar la sección sobre {janitor} en el manual de R para Epis para obtener una explicación más detallada sobre las funciones adorn_xxx().\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué distrito notificó la mayor cantidad de enfermedades transmitidas por vectores en 2024 (paludismo, dengue, fiebre amarilla)?\n\n Lago Minara Feveria Central Kasara\n\n¿Qué distrito notificó la mayor cantidad de enfermedades diarreicas en 2024 (cólera, fiebre tifoidea)?\n\n Lago Minara Feveria Central Kasara\n\n¿Qué factores contribuyen al aumento de enfermedades diarreicas en este distrito específico (seleccionado en la pregunta anterior)?\n\n Infraestructura deficiente de agua y saneamiento Hacinamiento de mosquitos No lo sabemos\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nAquí se presenta código para comenzar. Primero, se realiza una tabla de contingencia entre enfermedad_notificada y distrito_residencial con tabyl(). Luego, al agregar adorn_percentages(), estos valores se convierten en porcentajes con muchos decimales. A continuación, encadenar mediante pipes hacia adorn_pct_formatting() para aplicar un formato porcentual adecuado y, posteriormente, hacia adorn_ns() para reincorporar los números entre paréntesis.\nTener en cuenta que las funciones adorn_xxx() deben aplicarse en un orden específico.\n\ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages()\n\nPara conocer los factores que contribuyen a un mayor número de diarreas, desplácese hasta el principio del estudio de caso, cuando se presentaron por primera vez los distritos.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl utilizar tabyl(), se observa que la mayoría de los casos sospechosos de dengue, paludismo y fiebre amarilla se localizaron en Lago Minara, el área lacustre con mayor densidad de mosquitos y, por lo tanto, con enfermedades transmitidas por vectores. Mientras tanto, la mayoría de los casos de cólera y fiebre tifoidea se concentraron en Feveria Central, el área urbana sobrepoblada con problemas en la infraestructura de agua y saneamiento que generan un mayor riesgo de inundaciones y de contaminación del agua potable durante la temporada de lluvias.\n\ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n enfermedad_notificada Feveria Central      Kasara Lago Minara\n                colera      91.3% (42)  8.7%   (4)  0.0%   (0)\n                dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n       fiebre amarilla      11.0% (11) 21.0%  (21) 68.0%  (68)\n       fiebre tifoidea      68.6% (24) 31.4%  (11)  0.0%   (0)\n             paludismo      13.7% (73) 19.9% (106) 66.4% (354)\n\n\n\n\n\n\n\n\n\n\nA partir del trabajo realizado anteriormente en el paso 3, se identificó que los datos de laboratorio contienen únicamente información de pruebas y no incluyen datos de pacientes. Los datos ya se encuentran muy depurados, por lo que únicamente es necesario estandarizar una columna. Asimismo, se debe procesar el marco de datos de laboratorio para que contenga una fila por cada notificación, de manera que pueda unirse de forma ordenada con la base de datos de notificación.\n\n\n\n\nCrear un nuevo objeto denominado datos_lab. Esto permitirá un análisis y una interpretación de resultados más directos.\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice case_match() para convertir los distintos valores originales en “Positivo”, “Negativo” o “Indeterminado”:\n\ndatos_lab &lt;- datos_lab_crudos |&gt; \n  mutate(valor = case_match(valor, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\nPosteriormente, se puede verificar que los nuevos valores sean correctos mediante la tabulación y la comparación de los valores en la base de datos original y en el depurado. Asegurarse de haber utilizado la letra ‘O’ y no el número ‘0’.\n\ntabyl(datos_lab_crudos, valor)\n\n valor   n    percent\n     I  73 0.05555556\n     N 682 0.51902588\n     P 521 0.39649924\n   PO1  22 0.01674277\n PO139  16 0.01217656\n\n\n\ntabyl(datos_lab, valor)\n\n         valor   n    percent\n Indeterminado  73 0.05555556\n      Negativo 682 0.51902588\n      Positivo 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nYa se sabe que algunas muestras tienen varias filas, y que esto se debe a que el ensayo de dengue posee tres objetivos, con un resultado por fila para cada uno de ellos.\nAhora, determinar el número de muestras con varias filas.\nPara ello, proceder de la misma manera que con los datos de notificación, utilizando el objeto datos_lab: primero contar el número de filas por muestra y luego crear una tabla que muestre la distribución de la cantidad de filas. Tener en cuenta que cada muestra se identifica mediante un identificador de muestra (id_muestra).\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas muestras (identificadores únicos id_muestra) están repetidas en tres filas?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPrimero, encadenar los datos de laboratorio mediante un pipe hacia la función count(), indicando la columna id_muestra como el único argumento. Esto generará una tabla que contabiliza el número de filas por cada valor único de id_muestra, mostrando el resultado en una nueva columna denominada n. Por ejemplo, se puede observar que el id_muestra “000e8eee” tiene tres filas, mientras que el id_muestra “001e1878” aparece únicamente en una fila.\n\ndatos_lab |&gt; \n  count(id_muestra) \n\n\n\n  id_muestra n\n1   000e8eee 3\n2   001e1878 1\n3   005f39af 1\n4   00b30781 3\n5   00b56d18 1\n6   0110abcd 3\n\n\nA continuación, tabular la nueva columna n utilizando la función tabyl().\n\ndatos_lab |&gt; \n  count(id_muestra) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nIncluso se puede verificar que esto aplica únicamente al ensayo de dengue añadiendo la columna prueba al cálculo. De esta manera, se observa que solo la prueba de dengue presenta tres filas por muestra.\n\ndatos_lab |&gt; \n  count(prueba, id_muestra) |&gt; \n  tabyl(prueba, n)\n\n                      prueba   1   3\n            Cultivo de heces  45   0\n          Dengue NS1/IgG/IgM   0 215\n                 Hemocultivo  33   0\n                   IgM ELISA  88   0\n Microscopía de sangre total 503   0\n\n\n\n\n\n\n\n\nComo se observó en la sección 3.2, la prueba de dengue proporciona resultados para tres objetivos diferentes: IgG, IgM y NS.1. Los resultados de cada uno de estos objetivos pueden ser negativos o positivos. Sin embargo, para simplificar y consolidar los datos, se desea asignar una sola etiqueta (negativa o positiva) a cada muestra, con el fin de indicar si la muestra representa una infección activa.\n\n\nobjetivoNegativoPositivoDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nSu colega Ben, quien trabaja en el laboratorio, recomienda lo siguiente para la depuración:\n\nConsiderar una muestra como positiva si NS.1 o IgM son positivos (ambos pueden representar una infección aguda).\n\nIgnorar IgG (porque un resultado positivo en ausencia de NS.1 o IgM positivos es indicativo de inmunidad tras una infección pasada resuelta).\n\nAhora, consolidar los resultados de la prueba de dengue en una fila por prueba, con un único valor de resultado. Utilizar filter(), arrange() y slice(), asegurándose de que cualquier muestra positiva para NS.1 o IgM se considere positiva para dengue.\nCrear un nuevo objeto denominado datos_lab_pruebas.\n\n\n\n\n\n\nHaz clic para leer una pista\n\n\n\n\n\nIntentar aplicar lo siguiente para consolidar conforme a la recomendación de Ben:\n\nEliminar resultados de IgG: filtrar las filas donde el objetivo sea “IgG” utilizando filter() de {dplyr}.\n\nPriorizar resultados positivos de IgM/NS1: agrupar por id_muestra y ordenar las filas con arrange() de modo que cualquier resultado ‘P’ (positivo) aparezca primero.\n\nFiltrar al estado final: conservar únicamente la primera fila utilizando slice(1) para obtener el resultado positivo o negativo de la muestra.\n\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nA continuación se presenta el código para filtrar los resultados de IgG del dengue y, posteriormente, consolidar el resultado de la prueba dentro de cada grupo de filas con el mismo id_muestra, priorizando los resultados positivos. Es necesario especificar desc dentro de arrange(), ya que este ordena en orden alfabético inverso, colocando la letra P en la parte superior. Además, agregar la función ungroup() al final para que la nueva base de datos no quede agrupada, lo cual podría generar confusión en análisis posteriores.\n\ndatos_lab_pruebas &lt;- datos_lab |&gt; \n  filter(objetivo != \"Dengue IgG\") |&gt; \n  group_by(id_muestra) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nPosteriormente, se puede verificar que el nuevo objeto datos_lab_pruebas contenga una sola fila por prueba utilizando la combinación de count() y tabyl(), tal como se hizo en la Tarea A. Esta tabla muestra que todos los identificadores de muestra únicos aparecen únicamente en una fila cada uno:\n\ndatos_lab_pruebas |&gt; \n  count(id_muestra) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nA continuación, verificar el número de pruebas por identificador de notificación en los datos consolidados.\nSe observa que existen 26 filas con el mismo identificador de notificación que otra fila, pero únicamente en los casos analizados mediante microscopía de sangre total para paludismo.\n\ndatos_lab_pruebas |&gt; \n  count(prueba, id_notificacion) |&gt; \n  tabyl(prueba, n)\n\n                      prueba   1  2\n            Cultivo de heces  45  0\n          Dengue NS1/IgG/IgM 215  0\n                 Hemocultivo  33  0\n                   IgM ELISA  88  0\n Microscopía de sangre total 451 26\n\n\nSe procede a investigar con mayor detalle, examinando un caso de ejemplo con id_notificacion “043228”. Esto muestra que dicho caso fue analizado en dos ocasiones, con dos muestras diferentes tomadas con una semana de diferencia. El primer resultado fue positivo y el segundo resultado fue negativo.\n\ndatos_lab_pruebas |&gt; \n  filter(id_notificacion == \"043228\")\n\n# A tibble: 2 × 7\n  nombre_laboratorio     id_notificacion id_muestra fecha_prueba prueba objetivo\n  &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;      &lt;IDate&gt;      &lt;chr&gt;  &lt;chr&gt;   \n1 Hospital Universitari… 043228          27c37cd8   2024-06-18   Micro… Plasmod…\n2 Hospital Universitari… 043228          d2271be0   2024-06-25   Micro… Plasmod…\n# ℹ 1 more variable: valor &lt;chr&gt;\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuál afirmación sobre los datos de laboratorio es correcta?\n\n Todos los casos de diferentes enfermedades se vuelven a analizar Algunos casos de paludismo se vuelven a analizar Todos los casos de paludismo se vuelven a analizar\n\n¿Será necesario depurar (eliminar duplicados) los datos de laboratorio para unirlos con los datos de notificación?\n\n Sí - necesitamos una fila que represente el resultado de laboratorio por notificación No - los datos ya están suficientemente depurados\n\n\n\n\n¡Si la respuesta fue que es necesario deduplicar, es correcto!\nDeduplicar los datos para tener una sola fila por id_notificacion, priorizando los resultados positivos, de modo que puedan unirse con los datos de notificación.\nPara ello, seguir un proceso similar al de la Tarea B, utilizando el cuadro de datos generado en dicha tarea:\n\nAgrupar por id_notificacion.\n\nOrdenar por el valor del resultado de la prueba, de manera que los valores que comienzan con P tengan prioridad en la primera fila, seguidos por N (negativo) y luego I (indeterminado).\n\nConservar únicamente la primera fila dentro de cada grupo de id_notificacion, utilizando slice().\n\nAl realizar esto, crear un nuevo objeto denominado datos_lab_casos.\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nA continuación se presenta el código para deduplicar las filas dentro de cada grupo con el mismo id_notificacion, priorizando los resultados positivos. Una vez más, es necesario especificar desc dentro de arrange(). Esto funciona perfectamente porque el orden de prioridad deseado para los resultados —positivo, luego negativo y finalmente indeterminado— coincide con el orden alfabético inverso (P aparece antes que N, que aparece antes que I, al ordenar de forma descendente).\nSi el orden de prioridad fuera más complejo o no coincidiera con el orden alfabético (por ejemplo, si “indeterminado” debiera colocarse antes que “negativo”), sería necesario convertir la columna de resultados en un factor y definir explícitamente el orden deseado de sus niveles. No olvidar desagrupar nuevamente al final.\n\ndatos_lab_casos &lt;- datos_lab_pruebas |&gt; \n  group_by(id_notificacion) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nA continuación, puede volver a comprobar que el nuevo objeto datos_lab_casos sólo tiene una fila por prueba, utilizando la combinación de count() y tabyl() como que hizo en la Tarea A. Esta tabla le muestra que todos los ID de muestra únicos son sólo están presentes en una fila cada uno:\n\ndatos_lab_casos |&gt; \n  count(id_notificacion) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nAhora tenemos dos objetos que podemos utilizar para el análisis de los datos de laboratorio: datos_lab_pruebas y datos_lab_casos.\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué objeto debería usar para analizar las pruebas?\n\n datos_lab_pruebas datos_lab_casos ninguno\n\n¿Cuántas pruebas se realizaron para detectar paludismo (mediante microscopía de sangre completa)?\n\n 215 503 88 190\n\n¿Qué porcentaje de las pruebas para cólera (mediante cultivo de heces) resultaron positivas?\n\n 21% 11% 84% 87%\n\n¿Qué prueba tuvo el mayor porcentaje de resultados indeterminados?\n\n ELISA IgM (para la detección de fiebre amarilla) Cultivo de heces (para la detección de cólera) Hemocultivo (para la detección de fiebre tifoidea)\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl utilizar tabyl() se puede ver el número de positivos, negativos y resultados indeterminados por prueba. Se puede añadir una serie de funciones de adorn() para mostrar porcentajes y totales.\n\ntabyl(datos_lab_pruebas, prueba, valor) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                      prueba Indeterminado    Negativo    Positivo        Total\n            Cultivo de heces    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n          Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n                 Hemocultivo     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                   IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopía de sangre total    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué base de datos de laboratorio debería usar para contar el número de casos sospechosos analizados?\n\n datos_lab_crudos datos_lab_casos datos_lab_pruebas datos_lab\n\n¿Cuántos casos sospechosos fueron analizados en los datos de laboratorio de 2024?\n\n 858 1314 884\n\n¿Hay más casos sospechosos en los datos de notificación o en los datos de laboratorio?\n\n Datos de notificación Datos de laboratorio\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSe puede consultar el número de filas en la base de datos datos_lab_casos para observar la cantidad de casos sospechosos que fueron analizados.\n\nnrow(datos_lab_casos)\n\n[1] 858\n\n\nEste número es menor al de los casos sospechosos registrados en los datos depurados de vigilancia de enfermedades de notificación obligatoria (datos_notif), lo que sugiere que no todos los casos sospechosos en 2024 fueron analizados al momento en que estos datos estuvieron disponibles.\n\nnrow(datos_notif)\n\n[1] 987\n\n\n\n\n\n\n\n\n\n\nAhora que ambas linelists están depuradas y cuentan con una sola fila por caso sospechoso, es posible unirlos para habilitar el análisis completo solicitado por la jefatura.\n\n\n\n\nCrear un nuevo objeto denominado datos_unidos, utilizando una función xxx_join() de {dplyr}. Conservar todas las notificaciones y añadir los resultados de laboratorio cuando estén disponibles para cada caso sospechoso.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué función es la correcta si desea conservar todas las filas de sus datos de notificación e incorporar los resultados de sus datos de laboratorio?\n\n left_join(datos_notif, datos_lab_casos… full_join(datos_notif, datos_lab_casos… right_join(datos_notif, datos_lab_casos…\n\n¿Qué identificador debería usarse para enlazar las dos listas línea?\n\n id_muestra id_notificacion id_muestra y fecha_notificada id_notificacion y fecha_notificada\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nUnir los datos utilizando la función left_join(), colocando los datos de notificación como la base de datos principal a la izquierda. Esto permitirá conservar todas las filas de dicha base de datos e incorporar únicamente los resultados de laboratorio provenientes de la base de datos especificado a la derecha de la función.\n\ndatos_unidos &lt;- left_join(datos_notif, datos_lab_casos, \n                         by = \"id_notificacion\")\n\nLa unión se realiza mediante la columna id_notificacion, la cual está presente, completa y depurada en ambas linelists.\nNota: En este caso resulta afortunado contar con un ejemplo tan sencillo de unión. Normalmente sería necesario depurar y verificar exhaustivamente la columna de identificadores, o bien realizar la unión a través de otras variables como el nombre y la fecha de nacimiento. En Feveria, el personal de las clínicas es excelente asignando de manera consistente los identificadores de notificación a cada paciente, incluso en los formularios de muestra enviados al laboratorio; a su vez, el personal de laboratorio es igualmente destacado registrando el identificador de notificación en sus sistemas, lo que permite que los resultados se unan adecuadamente con cada caso.\n\n\n\n\n\n\nAhora comprueba tus datos y revisa.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas filas hay en su nueva base de datos datos_unidos?\n\n 987 884 858\n\n¿Cómo se compara esto con sus datos originales de notificación?\n\n más filas que el original el mismo número de filas menos filas\n\n¿Qué término describe mejor la unión que acaba de realizar?\n\n muchos-a-uno uno-a-uno muchos-a-muchos\n\n¿Cuántos resultados de laboratorio NO se unieron (pista: usar anti_join())?\n\n 30 19 0\n\n¿Qué tan afortunado es de que su unión haya sido tan exitosa?\n\n ¿Qué? ¿Acaso no toda unión es así de simple?? ¡Muy afortunado! Usualmente algunos registros no coinciden\n\n¿Cuáles son las razones típicas por las que los datos de laboratorio no coinciden con los datos de enfermedades de notificación obligatoria?\n\n Hay errores tipográficos en las columnas usadas para la unión, por lo que no se reconocen como coincidentes Los datos de laboratorio pueden contener casos adicionales de otras clínicas o países Los datos de laboratorio pueden incluir muestras de prueba Las notificaciones pueden haberse omitido accidentalmente en los datos de vigilancia aunque la muestra haya sido analizada en el laboratorio Todas las anteriores\n\n¿Cuántos casos sospechosos no tienen un resultado?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nVerificar el número de filas en cada marco de datos con la función nrow(), o consultando la información del objeto en el Entorno. Se puede observar que esta fue simplemente una unión uno-a-uno, ya que cada fila tenía un id_notificacion único; por lo tanto, una fila en los datos de notificación se unió directamente con una fila en los datos de laboratorio.\nNúmero de filas en los datos de notificación\n\nnrow(datos_notif)\n\n[1] 987\n\n\nNúmero de filas en los datos enlazados\n\nnrow(datos_unidos)\n\n[1] 987\n\n\nPara comprobar si existió algún resultado de laboratorio que no se unirá con los datos de notificación, se puede utilizar anti_join(). En este caso, el objeto datos_lab_casos se coloca a la izquierda, ya que la función evalúa cuántas filas de la base de datos de la izquierda no se encuentran en la base de datos de la derecha, haciendo la coincidencia por id_notificacion.\nEn esta ocasión no es necesario generar una nueva base de datos; simplemente se puede encadenar con un nrow() para contar el número de filas. El resultado es 0, lo que demuestra que no hubo resultados no unidos, ¡excelente!\n\nanti_join(datos_lab_casos, datos_notif, \n          by = \"id_notificacion\") |&gt; nrow()\n\n[1] 0\n\n\nPor último, para comprobar el número de notificaciones sin resultado, puede realizar un anti_join en putting datos_notif primero:\n\nanti_join(datos_notif, datos_lab_casos, \n          by = \"id_notificacion\") |&gt; nrow()\n\n[1] 129\n\n\nO bien, puede simplemente tabular el número de valores que faltan en el columna valor en datos_unidos (como la columna valor procede de los datos del laboratorio).\n\ntabyl(is.na(datos_unidos$valor)) \n\n is.na(datos_unidos$valor)   n   percent\n                     FALSE 858 0.8693009\n                      TRUE 129 0.1306991\n\n\nAmbos enfoques muestran que 129 casos sospechosos no tienen un resultado de laboratorio.\n\n\n\n\n\n\n\n\n\nUtilizar mutate() para crear una nueva columna denominada categoria_casos, actualizando la categoría de los casos sospechosos de acuerdo con su resultado de laboratorio. Las categorías deben definirse de la siguiente manera:\n\nSi el resultado fue positivo: Confirmado\n\nSi el resultado fue negativo: Descartado\n\nSi el resultado fue indeterminado o faltante: Sospechoso\n\nEsto implica que todos los casos en los datos de notificación se consideran inicialmente sospechosos al momento de ser reportados, y permanecen como sospechosos si no existe un resultado de prueba concluyente.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuál es la función más apropiada para crear esta nueva columna?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nDebe utilizar case_when() para crear la nueva columna. Esta función es ideal para aplicar múltiples condiciones lógicas para crear múltiples valores, mientras que case_match() es mejor para sustituir valores específicos, y if_else() es mejor si sólo hay dos valores posibles.\n\ndatos_unidos &lt;- datos_unidos |&gt; \n  mutate(categoria_casos = case_when(valor==\"Positivo\" ~ \"Confirmado\",\n                                   valor==\"Negativo\" ~ \"Descartado\",\n                                   valor==\"Indeterminado\" | is.na(valor) ~ \"Sospechoso\"))\n\n\n\n\n\n\n\n\n\n\nUtilizar tabyl() en general, y también la tabulación cruzada por enfermedad para responder a las siguientes preguntas.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántos casos en los datos de notificación unidos no tenían un resultado positivo ni negativo?\n\n 202 347 250\n\n¿Qué porcentaje de casos en los datos de notificación SÍ tenían un resultado positivo o negativo?\n\n 60.1% 79.5% 92.2%\n\n¿Por qué hay más casos sospechosos restantes que notificaciones no enlazadas?\n\n Los casos sospechosos incluyen notificaciones sin resultado de laboratorio y con un resultado de laboratorio indeterminado Se están incorporando casos sospechosos adicionales desde el laboratorio Hay un problema con los datos\n\n¿Qué enfermedad tuvo el mayor porcentaje de casos que permanecieron como sospechosos después de la unión?\n\n Cólera Paludismo Dengue Fiebre amarilla\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nUna vez más se puede utilizar tabyl() para observar la distribución de las categorías de casos en las notificaciones. El número total de casos sospechosos, es decir, aquellos sin resultado de laboratorio o con un resultado indeterminado, es de 202. Esto significa que 785 casos, es decir, el 79.5%, sí contaron con un resultado de laboratorio concluyente.\n\ntabyl(datos_unidos, categoria_casos) \n\n categoria_casos   n   percent\n      Confirmado 438 0.4437690\n      Descartado 347 0.3515704\n      Sospechoso 202 0.2046606\n\n\nTambién se puede realizar una tabla de contingencia entre los resultados originales (indeterminado/negativo/positivo) en la columna valor y la nueva columna categoria_casos, primero para comprobar que la lógica haya funcionado correctamente y, además, para visualizar cómo se asignaron los valores originales a las nuevas categorías. Esto muestra que, además de las 129 notificaciones que no fueron unidas (con NA en la columna valor), 73 tuvieron resultados indeterminados, por lo que fueron clasificadas como casos sospechosos.\n\ntabyl(datos_unidos, categoria_casos, valor) \n\n categoria_casos Indeterminado Negativo Positivo NA_\n      Confirmado             0        0      438   0\n      Descartado             0      347        0   0\n      Sospechoso            73        0        0 129\n\n\nFinalmente, también se puede realizar una tabla de contingencia con el nombre de la enfermedad para observar las categorías de caso por enfermedad. Es posible añadir funciones adicionales adorn_xxx() para aplicar un formato porcentual. La tabla muestra que el 22% de los casos de fiebre amarilla permanecieron como sospechosos, lo cual representó el porcentaje más alto en comparación con las demás enfermedades.\n\ntabyl(datos_unidos, enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n enfermedad_notificada  Confirmado  Descartado  Sospechoso        Total\n                colera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n                dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n       fiebre amarilla 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n       fiebre tifoidea 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n             paludismo 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n                 Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilice tabyl() para ello una vez más, observando los resultados por enfermedad. ¡Piense en el denominador correcto!\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué porcentaje de los casos sospechosos notificados en 2024 fueron casos verdaderos, según sus resultados de laboratorio?\n\n 44% 56% 59%\n\n¿Qué porcentaje de los casos sospechosos de paludismo fueron realmente paludismo?\n\n 86% 41% 23%\n\n¿Qué porcentaje de los casos sospechosos de dengue fueron realmente dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nDividir el número de casos confirmados (es decir, aquellos con un resultado positivo) entre el número de casos confirmados más los descartados (es decir, aquellos con resultado positivo o negativo). Esto genera una tasa de positividad, que aproxima el porcentaje de casos sospechosos que realmente fueron casos. Los resultados indeterminados se excluyen porque no aportan un desenlace claro y distorsionarían la tasa de positividad.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nFiltrar los casos sospechosos y luego realizar una tabla de contingencia, para observar el porcentaje de casos inicialmente sospechosos que se convierten en confirmados o descartados, entre aquellos con resultados válidos.\nDado que existe una fila de totales, se puede ver que, en general, el 56% de los casos sospechosos terminaron confirmados, entre aquellos con resultado válido. También se observa que el 41% de los casos de paludismo y el 87% de los casos de dengue fueron confirmados.\n\ndatos_unidos |&gt; \n  filter(categoria_casos != \"Sospechoso\") |&gt; \n  tabyl(enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n enfermedad_notificada  Confirmado  Descartado        Total\n                colera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n                dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n       fiebre amarilla 42.3%  (33) 57.7%  (45) 100.0%  (78)\n       fiebre tifoidea 22.6%   (7) 77.4%  (24) 100.0%  (31)\n             paludismo 41.3% (174) 58.7% (247) 100.0% (421)\n                 Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTarea A: Crear una nueva linelist llamada datos_unidos_confirmados.\nEsto es lo que se utilizará en los informes oficiales de vigilancia.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Por qué estamos optando por reportar solo casos confirmados en nuestros datos de vigilancia?\n\n Reportar casos confirmados puede ser más confiable y preciso cuando el porcentaje de pruebas positivas es bajo y las pruebas de laboratorio son rutinarias, ayudando así a prevenir la sobreestimación de la carga de enfermedad Reportar casos confirmados es más lento, lo que nos da más tiempo para estar seguros de lo que estamos reportando Porque queremos ocultar el número real de casos\n\n¿Qué función es importante para crear la nueva lista de casos (linelist)?\n\n filter() arrange() mutate()\n\n¿Cuántas filas hay en esta nueva base de datos?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nLa unidad de vigilancia desea centrarse en los casos confirmados en los informes. Esto se debe a que las pruebas de laboratorio son de rutina en Feveria y, por lo tanto, informar los casos sospechosos sería innecesariamente inexacto, ya que un alto porcentaje de estos terminan siendo descartados.\nLa decisión de publicar casos sospechosos puede ser diferente en otros contextos. Por ejemplo, si la tasa de positividad es alta (la mayoría de los casos resultan ser verdaderos al realizar la prueba), y las pruebas no son frecuentes o tardan mucho en realizarse, lo que retrasaría la notificación, se recomendaría que las tendencias de casos sospechosos fueran suficientemente precisas y más oportunas que esperar la confirmación de laboratorio.\nCrear la nueva linelist con la función filter():\ndatos_unidos_confirmados &lt;- datos_unidos |&gt; \n  filter(categoria_casos==\"Confirmado\")\nY compruebe el número de filas consultando la información de su Entorno, o con nrow():\nnrow(datos_unidos_confirmados)\n[1] 438\n\n\n\n\n\n\n\nAhora que ya tiene la lista de casos confirmados de enfermedades de notificación obligatoria reportados en Feveria en 2024, está listo o lista para llevar a cabo la parte final de su análisis de vigilancia. Se trata de resumir las cinco enfermedades de notificación obligatoria por zonas geográficas y por épocas.\nSugerencia Normalmente, el análisis de vigilancia también incluye el análisis por persona. Podría ampliar este estudio de caso analizando también los casos por variables demográficas.\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué enfermedad de notificación obligatoria se reportó con mayor frecuencia en 2024, al restringirse solo a los casos confirmados?\n\n Dengue Paludismo Fiebre amarilla\n\n¿Por qué la enfermedad más reportada es diferente al comparar los casos confirmados con los sospechosos?\n\n La sensibilidad y especificidad del diagnóstico clínico pueden variar según la enfermedad El desempeño de las pruebas utilizadas en el laboratorio puede variar según la enfermedad Puede haber sesgos en la notificación ¡Todas las anteriores!\n\n¿Qué distrito reportó el mayor número de casos confirmados de cólera en 2024?\n\n Lago Minara Feveria Central Kasara\n\n¿Cuántos casos confirmados de cólera reportados en 2024 correspondieron a residentes de Feveria Central?\n\n 35 42 4\n\n¿Qué distrito reportó el mayor número de casos confirmados de paludismo en 2024?\n\n Lago Minara Feveria Central Kasara\n\n¿Confirman estos datos que el dengue es la enfermedad infecciosa más común en Feveria?\n\n No - otra enfermedad puede estar subnotificada o no ser de notificación obligatoria Sí - si es la más reportada entonces debe ser la más común\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que el dengue fue la enfermedad más reportada en Feveria en 2024 cuando se restringe a casos confirmados, con 186 casos.\n\ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada) \n\n enfermedad_notificada   n    percent\n                colera  38 0.08675799\n                dengue 186 0.42465753\n       fiebre amarilla  33 0.07534247\n       fiebre tifoidea   7 0.01598174\n             paludismo 174 0.39726027\n\n\nNótese que esto es diferente a los casos sospechosos, ¡donde el paludismo fue la enfermedad más reportada (con 533 casos sospechosos)! Esto ya se insinuó anteriormente, cuando observamos que la tasa de positividad de los casos sospechosos de dengue era mayor que la de los casos sospechosos de paludismo. Esto puede deberse a diferentes razones, por ejemplo, el método de diagnóstico clínico utilizado para el paludismo puede ser menos específico (lo que podría significar que muchos de los casos sospechosos en realidad se deban a otras enfermedades), o bien la prueba utilizada para el dengue puede ser más sensible.\nPara realizar una tabulación cruzada con el distrito residencial, añada las funciones adorn_xxx().\n\ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada, distrito_residencial) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n enfermedad_notificada Feveria Central     Kasara Lago Minara        Total\n                colera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n                dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n       fiebre amarilla       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n       fiebre tifoidea      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n             paludismo      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n                 Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nAl igual que con los casos sospechosos, podemos ver que la mayoría de los casos confirmados de dengue, paludismo y fiebre amarilla se localizaron en el Lago Minara, la zona lacustre con mayor densidad de mosquitos y, por lo tanto, de enfermedades transmitidas por vectores. La mayoría de los casos confirmados de cólera y fiebre tifoidea se observaron en Feveria Central, donde hay problemas de agua y saneamiento.\nLos datos sugieren que las enfermedades transmitidas por vectores (dengue y paludismo) son especialmente preocupantes en este país tropical. Sin embargo, no sabemos con certeza cuál es la enfermedad más común ni cuáles son los patrones subyacentes: sólo cinco enfermedades son de notificación obligatoria, y normalmente los casos notificados sólo representan una fracción de los casos reales en la comunidad.\n\n\n\n\n\n\n\nProducirá esta curva epidémica en las siguientes tareas distintas.\n\n\n\n\n\n\n\n\n\n\n\nAsegúrese de especificar el argumento binwidth=7 para que cada barra del histograma represente el número de casos en un periodo de 7 días.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuándo se reportó el primer caso de fiebre tifoidea en Feveria en 2024?\n\n Enero 2024 Mayo 2024 Octubre 2024\n\nSegún este gráfico, ¿cuál fue el mayor número de casos de dengue reportados en una sola semana en 2024?\n\n 10 20 30 ¡Es muy difícil saberlo según este gráfico apilado!\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nEste es un código sencillo para producir la curva epidémica. Tenga en cuenta que aún no especificamos los colores ni en qué día de la semana comienza cada período de 7 días.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = enfermedad_notificada)), binwidth=7)\n\n\n\n\n\n\n\n\nConsulte el capítulo de Trabajando con Fechas en el Manual de R para Epis si desea un formato de fecha más específico o que el eje x indique el número de semana (semanas 1 a 52).\nImportante: ¡no es fácil ver las tendencias por enfermedad cuando se grafican apiladas de esta forma! Para visualizar estas tendencias temporales, debe producir un histograma para cada enfermedad.\n\n\n\n\n\n\nUtilice facet_wrap() para crear fácilmente pequeños gráficos multiples, uno por enfermedad. Para entender mejor la función, puede consultar la página Facetas del capítulo sobre ggplot2 en el Manual de R para Epis.\n\n\n\n\n\n\nPreguntas\n\n\n\n\nSegún este gráfico facetado, ¿cuál fue el mayor número de casos notificados de dengue en una sola semana en 2024?\n\n 11 15 29 ¡Todavía no lo puedo determinar!\n\n¿En qué distritos residían los casos de dengue notificados en esa semana?\n\n Los tres distritos Feveria Central Kasara Lago Minara Este gráfico no muestra esa información\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAhora puede ver una curva epidémica por enfermedad. Y puede ver que durante una semana de julio se notificaron 15 casos de dengue. Sin embargo, este gráfico aún no muestra ninguna información geográfica.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada)), binwidth=7) + \n  facet_wrap(.~enfermedad_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿En qué distrito residían los 15 casos de dengue notificados en una semana de julio de 2024?\n\n Los tres distritos Feveria Central Kasara Lago Minara\n\n¿En qué distrito se notificó el primer caso de fiebre tifoidea en 2024?\n\n Kasara Feveria Central Lago Minara ¡Todavía no lo puedo determinar!\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAhora puede ver una curva epidémica por enfermedad, con la coloración que refleja el distrito en el que reside el caso.\nSe puede ver que los 15 casos notificados de dengue en una sola semana vivían en tres distritos diferentes. También puede ver que el primer caso de fiebre tifoidea se registró en Feveria Central.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = distrito_residencial)), binwidth=7) + \n  facet_wrap(.~enfermedad_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPuede especificar:\n\nEl tema o diseño predeterminado del gráfico general (por ejemplo, color de fondo, aspecto de las líneas de la cuadrícula)\nEl título y las etiquetas\nLos colores de las barras (con scale_fill_manual())\nEl formato y espaciado de las fechas a lo largo del eje x (con scale_x_date)\n¡Muchas otras cosas!\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿El cólera y la fiebre tifoidea parecen endémicas?\n\n No - los datos sugieren brotes pequeños y ocasionales Sí los dos son endémicos\n\n¿Hubo un periodo particular del año en que el paludismo alcanzó su pico en 2024?\n\n Sí - alrededor de noviembre/diciembre Sí - alrededor de julio/agosto (verano) No, se mantuvo constantemente alto\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAquí está el código completo. Puede ver que este ejemplo contiene modificaciones adicionales. Por un lado, dentro de facet_wrap() se ha especificado que el panel tenga dos columnas. Por el otro, dentro de scale_x_date() se ha especificado que se muestre solo el día y el mes en el eje x.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = distrito_residencial)), binwidth=7) +\n  facet_wrap(.~enfermedad_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito residencial\",\n       x = \"Fecha notificada por el centro de salud\",\n       y = \"Recuento\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, paludismo, fiebre tifoidea, y fiebre amarilla por semana en Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nTambién podemos observar en la curva epidémica que el cólera y la fiebre tifoidea parecen presentarse como brotes aislados, en lugar de mostrar endemicidad. El paludismo y el dengue, sin embargo, estuvieron presentes en Feveria durante todo el año, con un pico de paludismo más evidente en los meses de verano.\n\n\n\n\n\n\nEsta vez, utilice group_by() y summarize() para producir una tabla por distrito que muestre las fechas más tempranas y más tardías de las notificaciones.\nPuede ajustar la tabla con filter() para crearla para un distrito a la vez.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuándo se notificó el primer caso de dengue en Feveria en 2024?\n\n 18 de enero 2024 17 de enero 2024 12 de febrero 2024\n\n¿Cuándo se notificó el último caso de dengue en Feveria Central en 2024?\n\n 22 de agosto 2024 18 de noviembre 2024 25 de diciembre 2024\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAgrupe los datos por enfermedad y luego extraiga la primera y la última fecha para ver la cronología general de cada enfermedad en Feveria.\n\ndatos_unidos_confirmados |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            ultimo_reporte = max(fecha_notificada)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  enfermedad_notificada primer_reporte ultimo_reporte\n  &lt;chr&gt;                 &lt;date&gt;         &lt;date&gt;        \n1 colera                2024-06-03     2024-09-23    \n2 dengue                2024-01-17     2024-11-18    \n3 fiebre amarilla       2024-03-08     2024-08-23    \n4 fiebre tifoidea       2024-05-02     2024-11-07    \n5 paludismo             2024-01-08     2024-12-25    \n\n\nAñada filter() al código para obtener las fechas de “Feveria Central”.\n\ndatos_unidos_confirmados |&gt; \n  filter(distrito_residencial == \"Feveria Central\") |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            recent_reported = max(fecha_notificada)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  enfermedad_notificada primer_reporte recent_reported\n  &lt;chr&gt;                 &lt;date&gt;         &lt;date&gt;         \n1 colera                2024-06-03     2024-09-23     \n2 dengue                2024-01-29     2024-08-22     \n3 fiebre tifoidea       2024-05-02     2024-11-07     \n4 paludismo             2024-01-29     2024-12-17     \n\n\n\n\n\n\n\n\n\n\n¡Vaya! De acuerdo con los objetivos de este estudio de caso, usted ha hecho lo siguiente:\n\nHa utilizado funciones clave de R para limpiar, procesar y unir bases de datos, además de crear nuevas columnas utilizando condiciones lógicas.\nPara tomar decisiones sobre el procesamiento de datos, ha realizado inspecciones y comprobaciones de los datos.\nRealizó un análisis descriptivo exhaustivo para comprender las notificaciones y los datos de laboratorio, antes y después de unirlos. En relación a las cuatro preguntas originales de su supervisor, puede decir:\n\n¿Cuántos casos sospechosos de las diferentes enfermedades de notificación obligatoria se reportaron en 2024, y cuál fue la más frecuente? Según los registros del sistema de vigilancia de enfermedades de notificación obligatoria, el paludismo fue la enfermedad más común en Feveria en 2024: 533 casos sospechosos de paludismo, 273 casos sospechosos de dengue, 100 de fiebre amarilla, 46 de cólera y 35 de fiebre tifoidea.\n¿Qué porcentaje de ellos acabo confirmándose? Casi el 80% de los casos de notificación obligatoria reportados en 2024 tenían un resultado de pruebas de laboratorio en el momento en que se creó la base de datos, con algunas variaciones según la enfermedad. En total, el 56% de los casos notificados acabaron confirmándose, pero este porcentaje osciló entre sólo el 23% en el caso de la fiebre tifoidea (7 casos confirmados de 31 sospechosos) y el 95% en el caso del cólera (38 casos confirmados de 40 sospechosos). Además, la tasa de positividad fue mayor en los casos sospechosos de dengue que en los de paludismo (87% frente a 41%).\n¿Cuántos casos confirmados de las diferentes enfermedades de notificación obligatoria se reportaron en 2024, y cuál fue la más frecuente? Los casos confirmados siguieron una tendencia ligeramente diferente a la de los casos sospechosos: la infección notificada con más frecuencia fue el dengue, con 186 casos, seguido por el paludismo (174), el cólera (38), la fiebre amarilla (33) y la fiebre tifoidea (7).\n¿Cómo se distribuyeron geográfica y temporalmente los casos confirmados en Feveria? Feveria experimentó transmisión de dengue y paludismo durante todo el año, con un pico en verano, y se concentró en el distrito de Lago Minara. También se registraron brotes pequeños y poco frecuentes de enfermedades diarreicas, como el cólera y la fiebre tifoidea, sobre todo en la zona urbana de Feveria Central, donde podrían existir problemas de agua y saneamiento.\n\nPor último, ha reflexionado sobre cómo la calidad y exhaustividad de los datos están determinados por procesos inherentes a la transferencia de los mismos entre los sistemas de vigilancia y los laboratorios.\n\nTiene un gran potencial por delante. Puede utilizar datos de vigilancia para explorar patrones por edad o sexo, calcular tasas con datos poblacionales e incluso analizar retrasos en la notificación al comparar las diferentes fechas en su base de datos.\nHa construido una base sólida y tiene las herramientas óptimas para llevar su análisis al siguiente nivel. Siga adelante: ¡le esperan descubrimientos emocionantes!\nPara profundizar, consulte los demás estudios de casos o explore el Manual de R para Epis.\n\n\n\nA continuación encontrará un script con todos los pasos para la limpieza de datos y el análisis descriptivo. Observe cómo los análisis se incluyen al final, en vez de intercalarse entre los pasos de limpieza. Esta es una forma más ordenada de organizar el script.\nPor motivos de brevedad, el código que aparece a continuación no incluye todas las inspecciones y comprobaciones realizadas durante el proceso, pero si desea puede crear una sección con dichas comprobaciones.\nLa parte superior de su script también debería contener información para ayudar al lector a entender cuál es el propósito del script, así como comentarios a lo largo del mismo. Más adelante se agradecerá haber añadido estos comentarios.\n\n\n\n\n\n\nCódigo para limpiar y analizar los datos de notificación y los datos de laboratorio de Feveria, 2024\n\n\n\n\n\n\n# Código para limpiar y analizar los datos de notificación y de laboratorio de Feveria, 2024\n# Fecha:\n# Elaborado por:\n\n# Instalar paquetes -------------------------------------------------\n# Asegurarse que el paquete \"pacman\" está instalado\nif (!require(\"pacman\")) {\n  install.packages(\"pacman\") }\n\n# Instalar (si es necesario) desde CRAN y cargar los paquetes necesarios\npacman::p_load(\n  rio,        # para importar datos  \n  skimr,      # para revisar los datos\n  janitor,    # para limpieza de datos y crear tablas \n  lubridate,  # para limpieza de fechas\n  epikit,     # para crear grupos de edad \n  gtsummary,  # para generar resúmenes estadísticos, pruebas y regresiones\n  apyramid,   # para graficar pirámides de edad  \n  flextable,  # para crear tablas listas para presentar \n  naniar,     # para evaluar los datos faltantes\n  remotes,    # para instalar paquetes necesarios para descargar datos \n  tidyverse   # para gestión y visualización de datos \n)\n\n# Importar datos --------------------------------------------\n\n# Datos de notificación \ndatos_notif_crudos &lt;- import(\"datos/notificaciones_multienfermedad.xlsx\")\n\n# Datos de laboratorio\ndatos_lab_crudos &lt;- import(\"datos/pruebas_multienfermedad.csv\")\n\n# Limpiar datos de notificación --------------------------------\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; names()\n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(\n    str_to_title(distrito_residencial),\n    c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n    c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n    c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(fecha_notificada = ymd(fecha_notificada)) \n\n\n# Limpiar datos de laboratorio ---------------------------------\n# Limpiar los valores\ndatos_lab &lt;- datos_lab_crudos |&gt; \n  mutate(valor = case_match(valor, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\n# Crear datos de laboratorio a nivel de prueba \ndatos_lab_pruebas &lt;- datos_lab |&gt; \n  filter(objetivo != \"Dengue IgG\") |&gt; \n  group_by(id_muestra) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Crear datos de laboratorio a nivel de caso\ndatos_lab_casos &lt;- datos_lab_pruebas |&gt; \n  group_by(id_notificacion) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Unir datos de notificación y de laboratorio  ----------------------------\ndatos_unidos &lt;- left_join(datos_notif, datos_lab_casos, by = \"id_notificacion\")\n\n# Limpiar base de datos unificada -----------------------------------------\ndatos_unidos &lt;- datos_unidos |&gt; \n  mutate(categoria_casos = case_when(\n    valor==\"Positivo\" ~ \"Confirmado\",\n    valor==\"Negativo\" ~ \"Descartado\",\n    valor==\"Indeterminado\" | is.na(valor) ~ \"Sospechoso\"))\n\ndatos_unidos_confirmados &lt;- datos_unidos |&gt; \n  filter(categoria_casos==\"Confirmado\")\n\n# ANÁLISIS ---------------------------------------------------------\n# Número de casos sospechosos en Feveria \ntabyl(datos_notif, enfermedad_notificada)\n\n# Distribución de casos sospechosos por distrito \ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribución de los resultados por prueba especifíca de cada enfermedad \ntabyl(datos_lab_pruebas, prueba, valor) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de la categoria de caso, en la base de datos unificada \ntabyl(datos_unidos, categoria_casos) \n\n# Distribución de la categoria de caso por enfermedad, en la base de datos unificada\ntabyl(datos_unidos, enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de la categoria de caso por enfermedad, en la base de datos unificada: \n# solo casos con un resultado válido\ndatos_unidos |&gt; \n  filter(categoria_casos != \"Sospechoso\") |&gt; \n  tabyl(enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de casos confirmados por distrito \ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada, distrito_residencial) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n# Visualizar casos confirmados a lo largo del tiempo \ndatos_unidos_confirmados |&gt; \n  ggplot() +\n  geom_histogram(\n    aes(x = fecha_notificada, fill = distrito_residencial), \n    binwidth=7\n  ) +\n  facet_wrap(.~enfermedad_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito residencial\",\n       x = \"Fecha notificada por el centro de salud\",\n       y = \"Recuento\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, paludismo, fiebre tifoidea, y fiebre amarilla por semana en Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n# Primera y última fecha de notificación por enfermedad \ndatos_unidos_confirmados |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            ultimo_reporte = max(fecha_notificada)) |&gt;\n  ungroup()\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutores originales Paula Blomquist y Alanah Jansen, con el apoyo técnico de la Subdivisión de Vigilancia Mundial, Laboratorios y Sistemas de Datos de los CDC, en colaboración con TEPHINET.\nFuente de datos Datos ficticios proporcionados por Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nFecha\nCambios realizados\nVersión\nAutor\n\n\n\n\nJulio 2025\nPrimer borrador\n1\nPaula Blomquist y Alanah Jansen, Applied Epi, con el apoyo técnico de la Subdivisión de Vigilancia Mundial, Laboratorios y Sistemas de Datos de los CDC, en colaboración con TEPHINET.\n\n\nAgosto 2025\nVersión en español\n1\nLuis Quezada, Martin Lotto y Shazia Ruybal\n\n\n\n\n\n\nDescargo de responsabilidad La información presentada en este ejercicio y los archivos de datos asociados se han elaborado para ayudar al alumnado a alcanzar los objetivos de aprendizaje previstos. El contenido es responsabilidad de los autores y no refleja necesariamente la opinión oficial de los CDC, del Departamento de Salud y Servicios Humanos de EE. UU. o de TEPHINET.\nLicencia: Este estudio de caso está bajo una licencia CC BY-NC-SA 4.0. Para obtener más información sobre cómo compartir y adaptar este estudio de caso, consulte la página escritura asociada.\nFinanciación Este estudio de caso fue financiado al 100% por el Acuerdo de Cooperación número NU2HGH000044 financiado por los Centros para el Control y la Prevención de Enfermedades (CDC) de EE.UU."
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#escenario",
    "href": "pages/multidisease_surveillance.es.html#escenario",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Usted es epidemiologo o epidemióloga en la oficina nacional de vigilancia de Feveria, un pequeño país tropical compuesto por tres distritos:\n\nFeveria Central: zona urbana densamente poblada, con infraestructuras de agua y saneamiento a veces poco fiables.\nLago Minara: zona lacustre con buena infraestructura, pero con gran abundancia de mosquitos durante los meses más cálidos del año.\nKasara: zona suburbana situada al otro lado de Feveria Central.\n\nMapa de los distritos de Feveria\n\nEs enero 2025, y su supervisor quiere que transfiera la rutina de procesamiento de enfermedades de declaración obligatoria de Excel a R, y que realice algunos análisis de datos. Como mínimo, quiere saber:\n\n¿Cuántos casos sospechosos de las diferentes enfermedades de declaración obligatoria se notificaron en 2024, y cuál fue la más frecuente?\n¿Qué porcentaje de ellos fue confirmado?\n¿Cuántos casos confirmados de las diferentes enfermedades de declaración obligatoria se notificaron en 2024, y cuál fue la más frecuente?\n¿Cómo se distribuyeron geográfica y temporalmente los casos confirmados en Feveria?\n\nSu supervisor le pide que escriba código para importar, limpiar, combinar y analizar las siguientes listas:\n\nDatos de vigilancia de enfermedades de declaración obligatoria de 2024: también denominados “datos de notificación”, se trata de datos de vigilancia sobre cinco enfermedades de declaración obligatoria notificadas por las clínicas de Feveria: dengue, paludismo, cólera, fiebre tifoidea y fiebre amarilla. Estos corresponden a casos sospechosos, basados en los síntomas de los pacientes. Los clínicos introducen cada notificación en un sistema en línea todos los días de la semana.\nDatos de resultados de pruebas de laboratorio de 2024: procedentes de tres grandes laboratorios de Feveria. Estos resultados corresponden a muestras tomadas de los casos sospechosos de las enfermedades de declaración obligatoria mencionadas anteriormente.\n\n¡Vamos!"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#objetivos",
    "href": "pages/multidisease_surveillance.es.html#objetivos",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "En este caso práctico deberá:\n\nUtilizar funciones clave de R para limpiar datos, remodelar bases de datos, combinar fuentes de datos y crear nuevas columnas mediante condiciones lógicas, con el fin de preparar los datos para el análisis.\nRealizar inspecciones de datos y comprobaciones de calidad en diferentes fases del proyecto, comprendiendo su importancia para garantizar un análisis fiable.\nLlevar a cabo análisis descriptivos básicos para comparar las tendencias de las enfermedades entre distintas fuentes de datos, tanto antes como después de la vinculación.\nInterpretar las diferencias en los resultados de las distintas fuentes de datos y comprender cómo éstas reflejan la estructura y el diseño del sistema de vigilancia."
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#etapa-1.-instalación",
    "href": "pages/multidisease_surveillance.es.html#etapa-1.-instalación",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Empiece por establecer un flujo de trabajo reproducible y bien organizado. Esto le facilitará repetir el análisis siempre que sea necesario.\nTareas:\n\nConfigurar un proyecto en RStudio.\nEstablecer subcarpetas claras para su código, datos y resultados.\nCrear un script en R, o un archivo R Markdown si lo prefiere. Asegúrese de que el propósito del script, la fecha y el autor figuren como comentarios en la parte superior del archivo.\nExtra: compruebe que el idioma de trabajo en RStudio sea el adecuado (por ejemplo, español para este ejercicio).\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\n\nCree una carpeta donde fuardará todo el trabajo de este caso práctico. Por ejemplo, puede llamarla ‘multienfermedad_lab’ y crearla en el escritorio de su ordenador. En esta carpeta debe crear su proyecto de RStudio.\nLe sugerimos crear las siguientes subcarpeta: scripts (para su código), datos (para sus datos), y resultados (para sus resultados analíticos).\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nCree una carpeta (por ejemplo: ‘multienfermedad_lab’ en su escritorio) para su trabajo. Para crear un proyecto de Rstudio en su nueva carpeta, haga clic en la esquina superior izquierda de R Studio y seleccione la opción New Project..., luego seleccione Existing Directory y, a continuación, en Browse para seleccionar su nueva carpeta. Para obtener más información, consulte la sección proyectos en R del Manual de R para Epis.\nInicie un nuevo script de R haciendo clic en New File en la parte superior izquierda de RStudio y, a continuación, seleccione R Script. Guárdelo de inmediato en la ubicación apropiada, por ejemplo, en la subcarpeta scripts de su proyecto.\nEn la parte superior de su nuevo script de R, escriba información esencial como su nombre, el propósito del archivo y la fecha.\nTenga en cuenta que su configuración regional en R determina el idioma y la localización que se utilizarán para aspectos como los formatos de fecha o las traducciones. Si su configuración regional es distinta del idioma que desea para su informe (por ejemplo, configuración regional en español frente a un informe en inglés), puede cambiarla al inglés ejecutando: Sys.setlocale(\"LC_ALL\", \"English\").\nIncluya esta línea en su script si fuera necesario, o bien omítala si su configuración regional ya es la adecuada. Esto se explica con más detalle en la Guía práctica.\n\n\n\n\n\n\nA continuación, en su script de R, debe instalar y cargar los paquetes necesarios. Esto garantiza que las funciones que necesita estén disponibles para realizar su análisis.\nNecesitará los siguientes paquetes:\n{rio} (para importar datos) {skimr} (para revisar datos) {janitor} (para limpiar datos) {lubridate} (para la gestión de fechas y tiempos) {epikit} (para tareas relacionadas con epidemiología) {gtsummary} (para estadísticas descriptivas, pruebas y regresión) {apyramid} (para pirámides de edad y sexo) {flextable} (para generar tablas listas para su presentación) {naniar} (para evaluar datos faltantes) {tidyverse} (para tareas generales de manipulación y análisis de datos)\nAdemás, necesitará {remotes} para descargar datos, algo que se explicará en la sección correspondiente a descargas.\nMientras empieza, su colega de confianza le da un codazo y le susurra: “He oído que una forma estupenda de gestionar sus paquetes… es con el paquete {pacman}”.\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice la función p_load() del paquete {pacman} para esta tarea. Es suficiente con proporcionarle una lista de los paquetes que desee utilizar. La función realiza dos pasos por cada paquete:\n\nComprueba si el paquete está instalado en su ordenador y, si no lo está, lo instala automáticamente.\nCarga el paquete para que pueda usarse durante la sesión de R.\n\nSi aún no tiene instalado {pacman}, deberá hacerlo a la manera tradicional, con install.packages().\nTenga en cuenta que el orden de los paquetes en p_load() puede ser importante. Si dos paquetes contienen funciones con el mismo nombre (por ejemplo, select() en {MASS} y select() en {tidyverse}), R utilizará la versión del paquete cargado más recientemente. Por ello, se recomienda cargar {tidyverse} en último lugar para priorizar sus funciones, muy utilizadas en la manipulación y visualización de datos.\n\n# Asegurarse de que el paquete \"pacman\" está instalado\nif (!require(\"pacman\")) { install.packages(\"pacman\") }\n\n# Instalar (si es necesario) desde CRAN y cargar los paquetes a utilizar\npacman::p_load(\n  rio,        # importar datos  \n  skimr,      # revisar datos de forma rápida\n  janitor,    # limpieza de datos y tablas\n  lubridate,  # manejo de fechas\n  epikit,     # crear categorías de edad\n  gtsummary,  # estadísticas descriptivas, pruebas y regresión \n  apyramid,   # crear pirámides de edad y sexo \n  flextable,  # tablas listas para presentación\n  naniar,     # explorar datos faltantes\n  remotes,    # instalar paquetes para descarga de datos\n  tidyverse   # manipulación y visualización de datos (último, para priorizar sus funciones)\n)"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-2.-descargar-e-importar-los-datos",
    "href": "pages/multidisease_surveillance.es.html#paso-2.-descargar-e-importar-los-datos",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Su oficina le proporciona dos archivos para su análisis, ambos correspondientes al año 2024 y actualizados al 15 de enero de 2025:\n\nUna base de datos de notificación de enfermedades (“notificaciones_multienfermedad.xlsx”) con los casos procedentes de 5 centros de salud.\nUna base de datos de pruebas de laboratorio (“pruebas_multienfermedad.csv”) enviada por tres laboratorios que realizan pruebas para los mismos 5 centros de salud.\n\nPara este estudio de caso, puede descargar los datos desde la página web de Applied Epi mediante el paquete {appliedepidata}. Siga estos pasos:\n\nInstale el paquete {appliedepidata} desde GitHub utilizando el comando install_github() del paquete {remotes} (que ya instaló anteriormente):\n\n\n# Usar la función install_github de remotes para instalar {appliedepidata}\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nGuarde las dos bases de datos en una carpeta específica utilizando la función save_data() del paquete {appliedepidata}. Este código guardará los archivos en la subcarpeta datos dentro de la carpeta de su proyecto en RStudio. Tenga en cuenta que, si no especifica ninguna ubicación en el argumento path, aparecerá una ventana para que seleccione manualmente la carpeta.\n\n\n# Guardar los dos archivos de datos usando la función save_data() de appliedepidata\nappliedepidata::save_data(\"pruebas_multienfermedad\",\n                          path = \"datos\")\n\nappliedepidata::save_data(\"notificaciones_multienfermedad\",\n                          path = \"datos\")\n\n\n\n\n¡Gracias a la oficina nacional y a Applied Epi! Ahora es el momento de importar los datos desde la carpeta a RStudio, para poder analizarlos.\n\n\nLo ideal es que utilice la misma función para importar ambas bases de datos al Entorno, aunque uno sea un archivo .csv y el otro un .xlsx. A partir de ahora, cuando hablemos de Entorno, nos referiremos al panel Environment (Entorno en español) de RStudio.\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nUtilice la función import() del paquete {rio}, que reconoce e importa distintos tipos de archivos. De esta manera no tendrá que usar funciones específicas según el formato, como read.csv() de {base} para archivos .csv o read_excel() de {readxl} para archivos .xlsx.\nSi quiere más información sobre la importanción de datos, puede consultar la sección Importar y exportar de nuestro manual de R.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nA continuación se muestra cómo importar los dos archivos utilizando la función import(). Los datos se guardan en dos objetos:\n\ndata_notif_crudos para los datos de notificaciones,\ndata_lab_crudos para los datos de laboratorio.\n\nEl sufijo *_crudos* le servirá para distinguirlos de las versiones depuradas que creará más adelante.\n\n# Importar datos\n\n# Datos de notificación\ndatos_notif_crudos &lt;- import(\"datos/notificaciones_multienfermedad.xlsx\")\n\n# Datos de laboratorio\ndatos_lab_crudos &lt;- import(\"datos/pruebas_multienfermedad.csv\")"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-3.-inspeccionar-los-datos",
    "href": "pages/multidisease_surveillance.es.html#paso-3.-inspeccionar-los-datos",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Ya tiene los datos, y ahora es el momento de ver qué historia cuentan. Tómese un momento para comprobar su contenido y su calidad.\n\n\n\n\nUtilice las siguients funciones para explorar sus datos: skim() del paquete {skimr}, names(), col() y nrow().\nskim() le proporciona información muy completa sobre la estructura y el contenido de los datos. names() le mostrará los nombres de las columnas. ncol() y nrow() cuentan, respectivamente, el número de columnas y de filas de su base de datos.\nPiense: ¿qué debe poner dentro de los paréntesis de cada función?\nLas pista más sencilla está en su Entorno. Recuerde que el objeto que contiene los datos de notificación se llama: datos_notif_crudos.\nSi necesita ayuda, haga click en el cuadro de soluciones situado debajo de las preguntas.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas hay en los datos de notificación?\n\n 10 11 12 13\n\n¿Cuál de estas columnas NO aparece en los datos?\n\n Fecha de inicio Fecha notificada por el centro de salud/la comunidad Fecha del resultado Fecha de la prueba Fecha de nacimiento\n\n¿Cuál es el nombre de la columna en los datos de notificación que identifica cada notificación?\n\n ID de notificacion ID prueba Codigo del centro de salud Combinación de ID de notificacion y Sexo\n\n¿Cuántas filas hay en los datos de notificación?\n\n 987 1314 950 778\n\n¿Qué tipo de información NO se encuentra en los datos de notificación?\n\n Resultados de pruebas de laboratorio Distrito de residencia Fecha de nacimiento y sexo Centro de salud donde se diagnosticó el caso Resultado\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice skim() del paquete {skimr} para ver un resumen de toda la base de datos, y View() para visualizar directamente los datos completos:\n\nskim(datos_notif_crudos)\n\nTambién puede emplear names() para imprimir únicamente los nombres de las columnas. Tanto con skim() como con names() podrá observar los tipos de información incluidos: el centro sanitario del caso, la fecha de nacimiento, el sexo, un indicador de embarazo, el distrito de residencia, la fecha de inicio de síntomas y la fecha notificada por la clínica, así como información sobre el desenlace.\nAdemás, encontrará una columna ID de notificacion que parece ser un identificador único para cada caso, aunque conviene comprobar posibles duplicados antes de confirmarlo.\nTenga en cuenta que en estos datos no hay resultados de laboratorio, ya que las notificaciones proceden de las clínicas, que notifican enfermedades de declaración obligatoria en base a criterios clínicos.\n\nnames(datos_notif_crudos)\n\n [1] \"Nombre de la unidad organizativa\"                    \n [2] \"Codigo del centro de salud\"                          \n [3] \"ID de notificacion\"                                  \n [4] \"Fecha de nacimiento\"                                 \n [5] \"Sexo\"                                                \n [6] \"Embarazada\"                                          \n [7] \"Distrito residencial\"                                \n [8] \"Enfermedad notificada\"                               \n [9] \"Fecha de inicio\"                                     \n[10] \"Fecha notificada por el centro de salud/la comunidad\"\n[11] \"Resultado\"                                           \n[12] \"Fecha del resultado\"                                 \n\n\nPara obtener el número de columnas y de filas puede utilizar:\n\nncol(datos_notif_crudos)\nnrow(datos_notif_crudos)\n\nEsto imprimirá en la consola el número de columnas y de filas de la base de datos.\n\n\n[1] 12\n\n\n[1] 987\n\n\nOtra manera rápida es mirar el Entorno en RStudio, donde verá, junto al nombre de la base de datos, el número de observaciones (filas) y de variables (columnas).\n\n\n\n\n\n\nUtilice skim() del paquete {skimr} o la función class() para comprobar las clases de las columnas.\n¿Recuerda cómo indicar la columna de interés dentro de la función class()? Alternativamente, puede observar el panel de Entorno en RStudio, donde aparece la clase de cada columna junto a su nombre.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas de la base de datos de notificación reconoce R como columnas de tipo fecha?\n\n 0 2 4\n\n¿Cuál es la clase de la mayoría de las columnas en la base de datos de notificación en bruto?\n\n character (texto) numeric (numérico) factor\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPuede usar class() como en el ejemplo siguiente. El operador $ sirve para seleccionar una columna concreta de la base de datos datos_notif_crudos. Fíjese en que se usan comillas invertidas (`) alrededor de Fecha de nacimiento porque el nombre de la columna contiene espacios.\n\nclass(datos_notif_crudos$`Fecha de nacimiento`)\n\nPara ver la clase desde el panel Entorno, haga click en la flecha azul junto con el nombre de la base de datos: aparececerán los nombres de las columnas con su clase al lado (por ejemplo, “chr” para indicar clase character o nominal)\nVerá que ninguna de las columnas que deberían ser fechas está reconocida como tal; en su lugar, R las interpreta como texto (character).\n\n\n\n\n\n\nUtilice tabyl() para inspeccionar los valores dentro de las columnas categóricas, especificando en el primer argumento la base de datos y en el segundo el nombre de la columna.\nPor ejemplo, este código tabula los valores de la columna Sexo. La salida muestra que los valores “masculino” y “femenino” están escritos de manera incoherente, por lo que esta columna necesitaría limpieza antes del análisis:\n\ntabyl(datos_notif_crudos, Sexo)\n\n      Sexo   n    percent valid_percent\n         F  47 0.04761905    0.05452436\n  FEMENINO 146 0.14792300    0.16937355\n         M  40 0.04052685    0.04640371\n MASCULINO 172 0.17426545    0.19953596\n         f 154 0.15602837    0.17865429\n  femenino  98 0.09929078    0.11368910\n         m 119 0.12056738    0.13805104\n masculino  86 0.08713273    0.09976798\n      &lt;NA&gt; 125 0.12664640            NA\n\n\nPara inspeccionar los valores faltantes (o perdidos), puede usar la función miss_var_summary() del paquete {naniar}:\n\nmiss_var_summary(datos_notif_crudos)\n\n# A tibble: 12 × 3\n   variable                                             n_miss pct_miss\n   &lt;chr&gt;                                                 &lt;int&gt;    &lt;num&gt;\n 1 Fecha de inicio                                         691     70.0\n 2 Embarazada                                              510     51.7\n 3 Resultado                                               197     20.0\n 4 Fecha del resultado                                     197     20.0\n 5 Fecha de nacimiento                                     168     17.0\n 6 Sexo                                                    125     12.7\n 7 Nombre de la unidad organizativa                          0      0  \n 8 Codigo del centro de salud                                0      0  \n 9 ID de notificacion                                        0      0  \n10 Distrito residencial                                      0      0  \n11 Enfermedad notificada                                     0      0  \n12 Fecha notificada por el centro de salud/la comunidad      0      0  \n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Los valores de la columna Distrito residencial están estandarizados?\n\n No: necesitan limpieza Sí: están estandarizados y listos para usarse en el análisis\n\n¿Los valores de la columna Enfermedad notificada están estandarizados?\n\n No: necesitan limpieza Sí: están estandarizados y listos para usarse en el análisis\n\n¿Qué reconoce R como un valor faltante?\n\n Sin valor, o solo un espacio, o solo un punto Sin valor en una celda, representado como NA Las palabras 'desconocido' e 'incierto'\n\nSegún los valores faltantes, ¿es útil la columna Fecha de inicio?\n\n Sí, la cantidad de valores faltantes es baja y esta columna es útil No demasiado: la ausencia es muy alta\n\n¿Por qué algunas columnas en los datos de notificación pueden tener grafías diferentes y categorías no estandarizadas?\n\n Un bot revuelve los datos para que sean menos identificables Cada clínica puede usar software configurado de forma diferente, o permitir entradas de texto libre, lo que genera variaciones en la ortografía El software de vigilancia usado en las clínicas tiene muchos errores en el código\n\n¿Por qué algunas columnas en los datos de notificación pueden tener una alta proporción de valores faltantes?\n\n El personal sanitario no pregunta al paciente durante la consulta El paciente no sabe o no quiere dar la respuesta El personal sanitario no tiene tiempo de completar ese campo, aunque sepa la información Todas las anteriores, y muchas más razones\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUse tabyl() para tabular los valores de la columna Distrito residencial. De nuevo, el primer argumento es el nombre de la base de datos y el segundo el nombre de la columna:\n\ntabyl(datos_notif_crudos, `Distrito residencial`)\n\n Distrito residencial   n    percent\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n          LAGO MINARA 185 0.18743668\n          Lago Minara  68 0.06889564\n             Lakeside 125 0.12664640\n\n\nVerá que cada una de las tres ubicaciones (Feveria Central, Lago Minara y Kasara) aparece escrita de distintas maneras y con diferentes mayúsculas. Esto deberá limpiarse si se quiere analizar la distribución geográfica de las enfermedades de declaración obligatoria.\nDe forma similar, utilice tabyl() para tabular los valores de la columna Enfermedad notificada. En este caso, verá que están escritos de forma adecuada y coherente, de modo que se puede analizar la distribución de los casos por enfermedad sin necesidad de más limpieza:\n\ntabyl(datos_notif_crudos, `Enfermedad notificada`)\n\n Enfermedad notificada   n    percent\n                colera  46 0.04660588\n                dengue 273 0.27659574\n       fiebre amarilla 100 0.10131712\n       fiebre tifoidea  35 0.03546099\n             paludismo 533 0.54002026\n\n\nPara comprobar los valores faltantes también puede usar is.na(). En el ejemplo siguiente, la función evalúa cada celda de la columna Fecha de inicio, devolviendo TRUE si falta el valor y FALSE si está presente. Si aplica tabyl() a este resultado, obtendrá de inmediato un recuento y un porcentaje claros de valores faltantes y no faltantes en esa columna.\nRecuerde: valores como un espacio vacío o las palabras “Desconocido” o “Faltante” no son reconocidos por R como NA. Solo los valores realmente en blanco, representados con NA, se consideran ausentes.\nEn el caso de Fecha de inicio, puede comprobar que aproximadamente un 70 % de las filas carecen de fecha de inicio, lo que hace que esta columna sea poco útil para analizar tendencias temporales.\n\ntabyl(is.na(datos_notif_crudos$`Fecha de inicio`))\n\n is.na(datos_notif_crudos$`Fecha de inicio`)   n   percent\n                                       FALSE 296 0.2998987\n                                        TRUE 691 0.7001013\n\n\nLos valores faltantes o las categorías no estandarizadas pueden deberse a muchas razones:\n\nEl diseño de la herramienta de recogida de datos (por ejemplo, si un campo es obligatorio o si se permite texto libre en lugar de listas desplegables),\nLos procesos y normas vigentes (por ejemplo, qué campos prioriza el personal),\nFactores contextuales (como la carga de trabajo o el tiempo disponible para recopilar la información).\n\n\n\n\n\n\n\n\n\n\nIgual que con los datos de vigilancia, utilice skim(), ncol() y nrow() o consulte el panel Entorno para inspeccionar los datos de laboratorio.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué base de datos tiene más columnas: la de notificación o la de laboratorio?\n\n Datos de laboratorio Datos de notificación Tienen el mismo número de columnas\n\n¿Qué base de datos tiene más filas: la de notificación o la de laboratorio?\n\n Datos de laboratorio Datos de notificación Tienen el mismo número de filas\n\nInspeccione los datos de laboratorio con View(). ¿Por qué podría haber más registros en la base de datos de laboratorio?\n\n Puede haber varias pruebas u objetivos por muestra Hay muchos resultados de pruebas de ensayo en los datos No todas las notificaciones tienen resultados de laboratorio todavía\n\n¿Cuál de estas columnas NO está en la base de datos de laboratorio?\n\n ID de notificacion ID de muestra Prueba Fecha de nacimiento Valor\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl igual que en la sección 3.1, puede utilizar skim() del paquete {skimr} para visualizar toda la base de datos del laboratorio con los resultados de las pruebas. Esto también le mostrará los distintos nombres de las columnas, poniendo de manifiesto que la base de datos del laboratorio solo contiene información sobre la prueba y no sobre el paciente. No obstante, también incluye un identificador de notificación similar, similar a los datos de notificación.\n\nskim(datos_lab_crudos)\n\nUtilice ncol() y nrow() para imprimir el número de columnas y filas, de la siguiente forma:\n\nncol(datos_lab_crudos)\nnrow(datos_lab_crudos)\n\nEsto mostrará en su consola el número de columnas y de filas, de manera que podrá comprobar que la base de datos de laboratorio tiene más filas que la base de datos de notificación que inspeccionó anteriormente.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nA menudo hay más registros en la base de datos de laboratorio que en los datos clínicos. Si inspecciona los datos con View(datos_lab_crudos) y luego hace clic en la flecha de la parte superior de la columna ID de notificacion para ordenarla alfabéticamente, verá que varias filas comparten el mismo ID de notificacion. Esto puede suceder cuando se analizan varios objetivos de la misma muestra (mismo identificador de muestra), o cuando se repite el análisis de un caso (lo que da lugar a un identificador de muestra diferente).\n\nView(datos_lab_crudos)\n\n\n\nnombre_laboratorioid_notificacionid_muestrafecha_pruebapruebaobjetivovalorHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNHospital General de Feveriaf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNHospital General de Feveria6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nAl igual que en el caso anterior, utilice las funciones class(), skim()o tabyl(), o inspeccione el Entorno, para observar las columnas con más detalle.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas columnas de la base de datos de laboratorio reconoce R como columnas de tipo fecha?\n\n 0 1 2\n\n¿Cuántas columnas de la base de datos de laboratorio tienen datos completos?\n\n 1 3 7 (Todas)\n\n¿Qué prueba detecta múltiples objetivos (y, por lo tanto, tiene varias filas por muestra)?\n\n Paludismo Dengue Fiebre Amarilla Cólera Fiebre tifoidea\n\n¿Cuántos valores posibles de resultado de prueba hay en la columna valor?\n\n 5 3 4\n\n¿Cuál de estos NO es un posible resultado en la prueba de cultivo de heces que detecta la bacteria V. cholerae?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nLos datos de laboratorio tienen una columna de fecha reconocida por R con la clase “IDate”. Se trata de una clase de fecha que suele aparecer al importar CSV con la función import() de {rio}. Igual que la clase “Date” de R base, permite ordenar por fecha y analizar tendencias en el tiempo.\n\nclass(datos_lab_crudos$fecha_prueba)\n\n[1] \"IDate\" \"Date\" \n\n\nEl uso de la función miss_var_summary() del paquete {naniar} muestra que todas las columnas de los datos de laboratorio están completas. Esto puede deberse a que los sistemas de laboratorio utilizan procesos automatizados, por lo que es menos probable que se produzcan errores humanos.\n(Punto importante: Tenga en cuenta que, en la vida real, los datos de laboratorio también presentarían probablemente algunos problemas).\n\nmiss_var_summary(datos_lab_crudos)\n\n# A tibble: 7 × 3\n  variable           n_miss pct_miss\n  &lt;chr&gt;               &lt;int&gt;    &lt;num&gt;\n1 nombre_laboratorio      0        0\n2 id_notificacion         0        0\n3 id_muestra              0        0\n4 fecha_prueba            0        0\n5 prueba                  0        0\n6 objetivo                0        0\n7 valor                   0        0\n\n\nPara ver cuántos objetivos se detectan en cada prueba, puede realizar una tabulación cruzada de las columnas prueba y objetivo con tabyl(). Escriba los nombres de las columnas en la función como dos argumentos separados. La salida muestra que cada prueba se alinea claramente con uno o más objetivos, y solo la prueba de dengue detecta más de un objetivo (IgG, IgM y NS1).\nConsejo: Pruebe a cambiar el orden de los nombres de las columnas en la función para ver el impacto en la tabla.\n\ntabyl(datos_lab_crudos, objetivo, prueba)\n\n             objetivo Cultivo de heces Dengue NS1/IgG/IgM Hemocultivo IgM ELISA\n Bacteria V. cholerae               45                  0           0         0\n   Bacterias S. Typhi                0                  0          33         0\n           Dengue IgG                0                215           0         0\n           Dengue IgM                0                215           0         0\n          Dengue NS.1                0                215           0         0\n  Fiebre amarilla IgM                0                  0           0        88\n           Plasmodium                0                  0           0         0\n Microscopía de sangre total\n                           0\n                           0\n                           0\n                           0\n                           0\n                           0\n                         503\n\n\nPor último, puede inspeccionar los distintos valores de los resultados de las pruebas en la columna valor utilizando de nuevo tabyl(). Verá que hay seis resultados posibles, incluidos N (negativo), P (positivo) e I (indeterminado). En el caso del cólera no aparece P, pero sí pueden aparecer P01 y P0139, que en este ejemplo representan positividad para los serogrupos O1 u O139.\n\ntabyl(datos_lab_crudos, prueba, valor)\n\n                      prueba  I   N   P PO1 PO139\n            Cultivo de heces  5   2   0  22    16\n          Dengue NS1/IgG/IgM  0 354 291   0     0\n                 Hemocultivo  2  24   7   0     0\n                   IgM ELISA 10  45  33   0     0\n Microscopía de sangre total 56 257 190   0     0"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-4.-limpiar-y-describir-los-datos-de-notificación",
    "href": "pages/multidisease_surveillance.es.html#paso-4.-limpiar-y-describir-los-datos-de-notificación",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Los datos de notificación (datos_notif_crudos) contienen información sobre casos sospechosos, junto con datos demográficos básicos (edad, sexo, embarazo, distrito de residencia), e información sobre su fecha de inicio, fecha reportada por el centro de salud, y resultado. Algunas columnas deben limpiarse antes de continuar con el análisis, debido a variaciones en la ortografía de los valores categóricos y a que algunas no se reconocen como fechas.\nAhora comenzará a redactar fragmentos más extensos de código para realizar limpieza de datos, utilizando diversas funciones de {dplyr} encadenadas mediante pipes (que se representan de la siguiente manera: |&gt;).\nNOTA SOBRE PIPES: Los pipes permiten ejecutar varias operaciones en una secuencia continua, “encadenando” diferentes funciones. La salida de una función se convierte en la entrada de la siguiente.\nPara obtener más información sobre el uso de pipes, consultar el Manual de R para Epis.\nCabe destacar que este ejercicio utiliza el pipe de base (|&gt;) en lugar del pipe de magrittr (%&gt;%), ya que resulta más rápido y no requiere instalación de paquetes. Si prefiere, puede utilizar el pipe de magrittr.\n\n\n\n\nDebido a problemas de calidad y de almacenamiento de datos, se recomienda elaborar una lista depurada (linelist) que contenga únicamente la información sobre el identificador único, la ubicación del caso, la enfermedad y la fecha en que la notificación fue reportada al sistema de vigilancia.\nEscribir código en R para generar una nueva base de datos limpio denominado datos_notif, aplicando las siguientes tareas de limpieza:\n\nRenombrar las columnas para que resulten más legibles por las máquinas (eliminando espacios y mayúsculas) mediante la función clean_names() del paquete {janitor}.\nUtilizar la función rename() de {dplyr} para que:\n\nel nombre de la columna con la fecha en la que se notificó el caso se sustituya por un nombre más conciso fecha_notificada.\nel nombre de la columna del identificador de la notificación sea más conciso (id_notificacion).\n\nSeleccionar las columnas relevantes para el análisis con la función select() del paquete {dplyr}.\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nIniciar el código con el nombre de la nueva base de datos, la flecha de asignación y el nombre del objeto de datos en bruto. Esto indica que el resultado del procesamiento de los datos en bruto será asignado a un nuevo objeto denominado datos_notif.\n\ndatos_notif &lt;- datos_notif_crudos\n\nA continuación, construya sobre este código añadiendo funciones adicionales, encadenadas mediante un pipe. Esto permite realizar varias operaciones en una secuencia continua. Primero, utilice clean_names() para estandarizar todos los nombres de columnas. Esta función reemplaza automáticamente los espacios y caracteres especiales por guiones bajos y convierte todo a minúsculas, lo que facilita el manejo de los nombres. Después, utilice rename() para asignar un nombre nuevo a una columna. Recordar que, al usar rename(), la columna ya tendrá la versión transformada por clean_names().\n\n# datos_notif &lt;- datos_notif_crudos |&gt; \n#   clean_names() |&gt; \n#   rename(NOMBRE_NUEVO = NOMBRE_ANTERIOR) |&gt; \n#   select(NOMBRES_VARIABLES)\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAquí está el código para limpiar los nombres de las columnas y seleccionar las columnas adecuadas para análisis:\n\n# Limpiar datos \ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada)\n\n\n\n\n\n\n\nA partir de la inspección de los datos, ya sabe que los valores de la columna distrito_residencial no están estandarizados.\nAgregar una función mutate() para limpiar la columna distrito_residencial, con el fin de:\n\nEstandarizar la capitalización de la columna.\n\nReemplazar la columna existente distrito_residencial por una columna depurada que contenga únicamente los siguientes valores de distrito: “Lago Minara”, “Feveria Central” y “Kasara”.\n\nConsultar la pista para ver qué funciones se pueden utilizar.\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nPrueba a utilizar str_to_title() del paquete {stringr} para que la primera letra de cada palabra sea mayúscula y todas las demás letras sean minúsculas. También puede utilizar case_match() para especificar distintas erratas concretas.\nUtilice la función ‘help’ de RStudio para ver cómo utilizar las funciones. Por ejemplo, escriba ?case_match en su consola para obtener la página de ayuda de la función. NOTA en case_match() - se trata de una función muy útil para sustituir o corregir valores, y sustituye a recode().\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSu código de limpieza debería tener ahora este aspecto:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = str_to_title(distrito_residencial)) |&gt; \n  mutate(distrito_residencial = case_match(distrito_residencial,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\nTambién puede envolver str_to_title en la función case_match() para acortar el código, como se indica a continuación:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt; \n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(str_to_title(distrito_residencial),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\"))\n\n\n\n\n\n\n\nLa columna correspondiente a la fecha de notificación necesita ser transformada para que sea reconocida como una fecha en R. Esto permitirá analizar tendencias a lo largo del tiempo, incluyendo semanas y meses.\nRevisar los valores dentro de la columna fecha_notificada. Luego, agregar una línea al código de limpieza para convertir fecha_notificada en una clase de fecha.\nConocer la estructura de la columna permitirá utilizar la función adecuada para transformarla en clase de fecha. Se recomienda emplear alguna de las funciones del paquete {lubridate}: ymd() (para fechas escritas como año-mes-día), mdy() (para fechas escritas como mes-día-año) o dmy() (para fechas escritas como día-mes-año). Estas funciones reconocerán cualquier formato de escritura de fecha siempre que el orden sea correcto; por ejemplo, “21st August 2025” y “21-08-2024” serían reconocidos por dmy().\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cómo están formateadas actualmente las fechas?\n\n día-mes-año año-mes-día mes-día-año año-día-mes\n\n¿Qué función de mutate() deberías usar para convertir la columna fecha_notificada en una clase de fecha?\n\n mutate(fecha_notificada = ymd(fecha_notificada)) mutate(fecha_notificada = dmy(fecha_notificada)) mutate(fecha_notificada = mdy(fecha_notificada))\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSe puede utilizar la función head() para visualizar las primeras seis filas de datos de la columna fecha_notificada. Al observarlas, se identifica que están escritas con el año en primer lugar, seguido del mes y, posteriormente, del día.\n\nhead(datos_notif$fecha_notificada)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nSe puede utilizar la función ymd() dentro de mutate() para convertir la clase de la columna fecha_notificada. Es posible verificar que la clase sea la correcta ejecutando posteriormente la función class().\nEl código de limpieza debería ahora tener el siguiente aspecto:\n\n# Limpiar datos\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; \n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(str_to_title(distrito_residencial),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(fecha_notificada = ymd(fecha_notificada)) \n\nY se puede volver a comprobar la clase con esto:\n\nclass(datos_notif$fecha_notificada)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nLos colegas indican que cada id_notificacion representa un caso sospechoso. Ahora se desea crear una tabla para verificar si id_notificacion se encuentra duplicado en las filas de los datos.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Equivale una fila en los datos de notificación a un caso?\n\n Sí No\n\n¿Necesita depurar (eliminar duplicados) sus datos para el análisis epidemiológico de casos?\n\n Sí No\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nExisten varias formas de realizar esta verificación, pero se sugiere utilizar la función count() de {dplyr}. Esta función creará una tabla que contabiliza el número de filas por cada valor único de la columna que se especifique dentro de la función. Posteriormente, emplear tabyl() para observar la distribución de estos conteos.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPrimero, encadenar los datos de vigilancia mediante un pipe hacia la función count(), indicando la columna id_notificacion como el único argumento. Esto generará una tabla que contabiliza el número de filas por cada valor único de id_notificacion, mostrando el resultado en una nueva columna denominada n. En este extracto se puede observar, por ejemplo, que existe solo una fila para cada uno de estos seis valores de id_notificacion.\n\ndatos_notif |&gt; \n  count(id_notificacion) \n\n\n\n  id_notificacion n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nA continuación, tabular la nueva columna n con la función tabyl(), lo que demuestra que existe únicamente una fila por cada id_notificacion único. Esto significa que una fila equivale a un caso y que no se requiere realizar una deduplicación adicional.\n\ndatos_notif |&gt; \n  count(id_notificacion) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nAhora puede proceder cómodamente al análisis descriptivo de los casos, ya que sus datos están limpios y sabe que una fila equivale a un caso. Utilice la función tabyl() para las siguientes tareas.\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué enfermedad fue diagnosticada con mayor frecuencia por las clínicas en Feveria en 2024?\n\n Cólera Paludismo Dengue Fiebre tifoidea Fiebre amarilla\n\n¿Qué enfermedad fue diagnosticada con menor frecuencia por las clínicas en Feveria en 2024?\n\n Cólera Paludismo Dengue Fiebre tifoidea Fiebre amarilla\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que había 533 casos sospechosos de paludismo en Feveria en 2024, y sólo 35 casos sospechosos de fiebre tifoidea.\n\ntabyl(datos_notif, enfermedad_notificada)\n\n enfermedad_notificada   n    percent\n                colera  46 0.04660588\n                dengue 273 0.27659574\n       fiebre amarilla 100 0.10131712\n       fiebre tifoidea  35 0.03546099\n             paludismo 533 0.54002026\n\n\n\n\n\n\n\n\nUtilice tabyl() para cruzar las columnas de enfermedad y distrito de residencia.\nComplete la tabla incorporando diversas funciones adorn del paquete {janitor}, con el fin de visualizar distribuciones porcentuales, por ejemplo: adorn_percentages(), adorn_pct_formatting() y adorn_ns().\nEscribir el nombre de la función precedido de un signo de interrogación en la consola (por ejemplo, ?adorn_ns) para consultar las páginas de ayuda correspondientes. También se puede revisar la sección sobre {janitor} en el manual de R para Epis para obtener una explicación más detallada sobre las funciones adorn_xxx().\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué distrito notificó la mayor cantidad de enfermedades transmitidas por vectores en 2024 (paludismo, dengue, fiebre amarilla)?\n\n Lago Minara Feveria Central Kasara\n\n¿Qué distrito notificó la mayor cantidad de enfermedades diarreicas en 2024 (cólera, fiebre tifoidea)?\n\n Lago Minara Feveria Central Kasara\n\n¿Qué factores contribuyen al aumento de enfermedades diarreicas en este distrito específico (seleccionado en la pregunta anterior)?\n\n Infraestructura deficiente de agua y saneamiento Hacinamiento de mosquitos No lo sabemos\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nAquí se presenta código para comenzar. Primero, se realiza una tabla de contingencia entre enfermedad_notificada y distrito_residencial con tabyl(). Luego, al agregar adorn_percentages(), estos valores se convierten en porcentajes con muchos decimales. A continuación, encadenar mediante pipes hacia adorn_pct_formatting() para aplicar un formato porcentual adecuado y, posteriormente, hacia adorn_ns() para reincorporar los números entre paréntesis.\nTener en cuenta que las funciones adorn_xxx() deben aplicarse en un orden específico.\n\ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages()\n\nPara conocer los factores que contribuyen a un mayor número de diarreas, desplácese hasta el principio del estudio de caso, cuando se presentaron por primera vez los distritos.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl utilizar tabyl(), se observa que la mayoría de los casos sospechosos de dengue, paludismo y fiebre amarilla se localizaron en Lago Minara, el área lacustre con mayor densidad de mosquitos y, por lo tanto, con enfermedades transmitidas por vectores. Mientras tanto, la mayoría de los casos de cólera y fiebre tifoidea se concentraron en Feveria Central, el área urbana sobrepoblada con problemas en la infraestructura de agua y saneamiento que generan un mayor riesgo de inundaciones y de contaminación del agua potable durante la temporada de lluvias.\n\ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n enfermedad_notificada Feveria Central      Kasara Lago Minara\n                colera      91.3% (42)  8.7%   (4)  0.0%   (0)\n                dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n       fiebre amarilla      11.0% (11) 21.0%  (21) 68.0%  (68)\n       fiebre tifoidea      68.6% (24) 31.4%  (11)  0.0%   (0)\n             paludismo      13.7% (73) 19.9% (106) 66.4% (354)"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-5.-limpiar-consolidar-y-describir-los-datos-de-laboratorio.",
    "href": "pages/multidisease_surveillance.es.html#paso-5.-limpiar-consolidar-y-describir-los-datos-de-laboratorio.",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "A partir del trabajo realizado anteriormente en el paso 3, se identificó que los datos de laboratorio contienen únicamente información de pruebas y no incluyen datos de pacientes. Los datos ya se encuentran muy depurados, por lo que únicamente es necesario estandarizar una columna. Asimismo, se debe procesar el marco de datos de laboratorio para que contenga una fila por cada notificación, de manera que pueda unirse de forma ordenada con la base de datos de notificación.\n\n\n\n\nCrear un nuevo objeto denominado datos_lab. Esto permitirá un análisis y una interpretación de resultados más directos.\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nUtilice case_match() para convertir los distintos valores originales en “Positivo”, “Negativo” o “Indeterminado”:\n\ndatos_lab &lt;- datos_lab_crudos |&gt; \n  mutate(valor = case_match(valor, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\nPosteriormente, se puede verificar que los nuevos valores sean correctos mediante la tabulación y la comparación de los valores en la base de datos original y en el depurado. Asegurarse de haber utilizado la letra ‘O’ y no el número ‘0’.\n\ntabyl(datos_lab_crudos, valor)\n\n valor   n    percent\n     I  73 0.05555556\n     N 682 0.51902588\n     P 521 0.39649924\n   PO1  22 0.01674277\n PO139  16 0.01217656\n\n\n\ntabyl(datos_lab, valor)\n\n         valor   n    percent\n Indeterminado  73 0.05555556\n      Negativo 682 0.51902588\n      Positivo 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nYa se sabe que algunas muestras tienen varias filas, y que esto se debe a que el ensayo de dengue posee tres objetivos, con un resultado por fila para cada uno de ellos.\nAhora, determinar el número de muestras con varias filas.\nPara ello, proceder de la misma manera que con los datos de notificación, utilizando el objeto datos_lab: primero contar el número de filas por muestra y luego crear una tabla que muestre la distribución de la cantidad de filas. Tener en cuenta que cada muestra se identifica mediante un identificador de muestra (id_muestra).\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas muestras (identificadores únicos id_muestra) están repetidas en tres filas?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nPrimero, encadenar los datos de laboratorio mediante un pipe hacia la función count(), indicando la columna id_muestra como el único argumento. Esto generará una tabla que contabiliza el número de filas por cada valor único de id_muestra, mostrando el resultado en una nueva columna denominada n. Por ejemplo, se puede observar que el id_muestra “000e8eee” tiene tres filas, mientras que el id_muestra “001e1878” aparece únicamente en una fila.\n\ndatos_lab |&gt; \n  count(id_muestra) \n\n\n\n  id_muestra n\n1   000e8eee 3\n2   001e1878 1\n3   005f39af 1\n4   00b30781 3\n5   00b56d18 1\n6   0110abcd 3\n\n\nA continuación, tabular la nueva columna n utilizando la función tabyl().\n\ndatos_lab |&gt; \n  count(id_muestra) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nIncluso se puede verificar que esto aplica únicamente al ensayo de dengue añadiendo la columna prueba al cálculo. De esta manera, se observa que solo la prueba de dengue presenta tres filas por muestra.\n\ndatos_lab |&gt; \n  count(prueba, id_muestra) |&gt; \n  tabyl(prueba, n)\n\n                      prueba   1   3\n            Cultivo de heces  45   0\n          Dengue NS1/IgG/IgM   0 215\n                 Hemocultivo  33   0\n                   IgM ELISA  88   0\n Microscopía de sangre total 503   0\n\n\n\n\n\n\n\n\nComo se observó en la sección 3.2, la prueba de dengue proporciona resultados para tres objetivos diferentes: IgG, IgM y NS.1. Los resultados de cada uno de estos objetivos pueden ser negativos o positivos. Sin embargo, para simplificar y consolidar los datos, se desea asignar una sola etiqueta (negativa o positiva) a cada muestra, con el fin de indicar si la muestra representa una infección activa.\n\n\nobjetivoNegativoPositivoDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nSu colega Ben, quien trabaja en el laboratorio, recomienda lo siguiente para la depuración:\n\nConsiderar una muestra como positiva si NS.1 o IgM son positivos (ambos pueden representar una infección aguda).\n\nIgnorar IgG (porque un resultado positivo en ausencia de NS.1 o IgM positivos es indicativo de inmunidad tras una infección pasada resuelta).\n\nAhora, consolidar los resultados de la prueba de dengue en una fila por prueba, con un único valor de resultado. Utilizar filter(), arrange() y slice(), asegurándose de que cualquier muestra positiva para NS.1 o IgM se considere positiva para dengue.\nCrear un nuevo objeto denominado datos_lab_pruebas.\n\n\n\n\n\n\nHaz clic para leer una pista\n\n\n\n\n\nIntentar aplicar lo siguiente para consolidar conforme a la recomendación de Ben:\n\nEliminar resultados de IgG: filtrar las filas donde el objetivo sea “IgG” utilizando filter() de {dplyr}.\n\nPriorizar resultados positivos de IgM/NS1: agrupar por id_muestra y ordenar las filas con arrange() de modo que cualquier resultado ‘P’ (positivo) aparezca primero.\n\nFiltrar al estado final: conservar únicamente la primera fila utilizando slice(1) para obtener el resultado positivo o negativo de la muestra.\n\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nA continuación se presenta el código para filtrar los resultados de IgG del dengue y, posteriormente, consolidar el resultado de la prueba dentro de cada grupo de filas con el mismo id_muestra, priorizando los resultados positivos. Es necesario especificar desc dentro de arrange(), ya que este ordena en orden alfabético inverso, colocando la letra P en la parte superior. Además, agregar la función ungroup() al final para que la nueva base de datos no quede agrupada, lo cual podría generar confusión en análisis posteriores.\n\ndatos_lab_pruebas &lt;- datos_lab |&gt; \n  filter(objetivo != \"Dengue IgG\") |&gt; \n  group_by(id_muestra) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nPosteriormente, se puede verificar que el nuevo objeto datos_lab_pruebas contenga una sola fila por prueba utilizando la combinación de count() y tabyl(), tal como se hizo en la Tarea A. Esta tabla muestra que todos los identificadores de muestra únicos aparecen únicamente en una fila cada uno:\n\ndatos_lab_pruebas |&gt; \n  count(id_muestra) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nA continuación, verificar el número de pruebas por identificador de notificación en los datos consolidados.\nSe observa que existen 26 filas con el mismo identificador de notificación que otra fila, pero únicamente en los casos analizados mediante microscopía de sangre total para paludismo.\n\ndatos_lab_pruebas |&gt; \n  count(prueba, id_notificacion) |&gt; \n  tabyl(prueba, n)\n\n                      prueba   1  2\n            Cultivo de heces  45  0\n          Dengue NS1/IgG/IgM 215  0\n                 Hemocultivo  33  0\n                   IgM ELISA  88  0\n Microscopía de sangre total 451 26\n\n\nSe procede a investigar con mayor detalle, examinando un caso de ejemplo con id_notificacion “043228”. Esto muestra que dicho caso fue analizado en dos ocasiones, con dos muestras diferentes tomadas con una semana de diferencia. El primer resultado fue positivo y el segundo resultado fue negativo.\n\ndatos_lab_pruebas |&gt; \n  filter(id_notificacion == \"043228\")\n\n# A tibble: 2 × 7\n  nombre_laboratorio     id_notificacion id_muestra fecha_prueba prueba objetivo\n  &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;      &lt;IDate&gt;      &lt;chr&gt;  &lt;chr&gt;   \n1 Hospital Universitari… 043228          27c37cd8   2024-06-18   Micro… Plasmod…\n2 Hospital Universitari… 043228          d2271be0   2024-06-25   Micro… Plasmod…\n# ℹ 1 more variable: valor &lt;chr&gt;\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuál afirmación sobre los datos de laboratorio es correcta?\n\n Todos los casos de diferentes enfermedades se vuelven a analizar Algunos casos de paludismo se vuelven a analizar Todos los casos de paludismo se vuelven a analizar\n\n¿Será necesario depurar (eliminar duplicados) los datos de laboratorio para unirlos con los datos de notificación?\n\n Sí - necesitamos una fila que represente el resultado de laboratorio por notificación No - los datos ya están suficientemente depurados\n\n\n\n\n¡Si la respuesta fue que es necesario deduplicar, es correcto!\nDeduplicar los datos para tener una sola fila por id_notificacion, priorizando los resultados positivos, de modo que puedan unirse con los datos de notificación.\nPara ello, seguir un proceso similar al de la Tarea B, utilizando el cuadro de datos generado en dicha tarea:\n\nAgrupar por id_notificacion.\n\nOrdenar por el valor del resultado de la prueba, de manera que los valores que comienzan con P tengan prioridad en la primera fila, seguidos por N (negativo) y luego I (indeterminado).\n\nConservar únicamente la primera fila dentro de cada grupo de id_notificacion, utilizando slice().\n\nAl realizar esto, crear un nuevo objeto denominado datos_lab_casos.\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nA continuación se presenta el código para deduplicar las filas dentro de cada grupo con el mismo id_notificacion, priorizando los resultados positivos. Una vez más, es necesario especificar desc dentro de arrange(). Esto funciona perfectamente porque el orden de prioridad deseado para los resultados —positivo, luego negativo y finalmente indeterminado— coincide con el orden alfabético inverso (P aparece antes que N, que aparece antes que I, al ordenar de forma descendente).\nSi el orden de prioridad fuera más complejo o no coincidiera con el orden alfabético (por ejemplo, si “indeterminado” debiera colocarse antes que “negativo”), sería necesario convertir la columna de resultados en un factor y definir explícitamente el orden deseado de sus niveles. No olvidar desagrupar nuevamente al final.\n\ndatos_lab_casos &lt;- datos_lab_pruebas |&gt; \n  group_by(id_notificacion) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nA continuación, puede volver a comprobar que el nuevo objeto datos_lab_casos sólo tiene una fila por prueba, utilizando la combinación de count() y tabyl() como que hizo en la Tarea A. Esta tabla le muestra que todos los ID de muestra únicos son sólo están presentes en una fila cada uno:\n\ndatos_lab_casos |&gt; \n  count(id_notificacion) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nAhora tenemos dos objetos que podemos utilizar para el análisis de los datos de laboratorio: datos_lab_pruebas y datos_lab_casos.\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué objeto debería usar para analizar las pruebas?\n\n datos_lab_pruebas datos_lab_casos ninguno\n\n¿Cuántas pruebas se realizaron para detectar paludismo (mediante microscopía de sangre completa)?\n\n 215 503 88 190\n\n¿Qué porcentaje de las pruebas para cólera (mediante cultivo de heces) resultaron positivas?\n\n 21% 11% 84% 87%\n\n¿Qué prueba tuvo el mayor porcentaje de resultados indeterminados?\n\n ELISA IgM (para la detección de fiebre amarilla) Cultivo de heces (para la detección de cólera) Hemocultivo (para la detección de fiebre tifoidea)\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nAl utilizar tabyl() se puede ver el número de positivos, negativos y resultados indeterminados por prueba. Se puede añadir una serie de funciones de adorn() para mostrar porcentajes y totales.\n\ntabyl(datos_lab_pruebas, prueba, valor) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                      prueba Indeterminado    Negativo    Positivo        Total\n            Cultivo de heces    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n          Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n                 Hemocultivo     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n                   IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n Microscopía de sangre total    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué base de datos de laboratorio debería usar para contar el número de casos sospechosos analizados?\n\n datos_lab_crudos datos_lab_casos datos_lab_pruebas datos_lab\n\n¿Cuántos casos sospechosos fueron analizados en los datos de laboratorio de 2024?\n\n 858 1314 884\n\n¿Hay más casos sospechosos en los datos de notificación o en los datos de laboratorio?\n\n Datos de notificación Datos de laboratorio\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nSe puede consultar el número de filas en la base de datos datos_lab_casos para observar la cantidad de casos sospechosos que fueron analizados.\n\nnrow(datos_lab_casos)\n\n[1] 858\n\n\nEste número es menor al de los casos sospechosos registrados en los datos depurados de vigilancia de enfermedades de notificación obligatoria (datos_notif), lo que sugiere que no todos los casos sospechosos en 2024 fueron analizados al momento en que estos datos estuvieron disponibles.\n\nnrow(datos_notif)\n\n[1] 987"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-6.-unión-y-tratamiento-final",
    "href": "pages/multidisease_surveillance.es.html#paso-6.-unión-y-tratamiento-final",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Ahora que ambas linelists están depuradas y cuentan con una sola fila por caso sospechoso, es posible unirlos para habilitar el análisis completo solicitado por la jefatura.\n\n\n\n\nCrear un nuevo objeto denominado datos_unidos, utilizando una función xxx_join() de {dplyr}. Conservar todas las notificaciones y añadir los resultados de laboratorio cuando estén disponibles para cada caso sospechoso.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué función es la correcta si desea conservar todas las filas de sus datos de notificación e incorporar los resultados de sus datos de laboratorio?\n\n left_join(datos_notif, datos_lab_casos… full_join(datos_notif, datos_lab_casos… right_join(datos_notif, datos_lab_casos…\n\n¿Qué identificador debería usarse para enlazar las dos listas línea?\n\n id_muestra id_notificacion id_muestra y fecha_notificada id_notificacion y fecha_notificada\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nUnir los datos utilizando la función left_join(), colocando los datos de notificación como la base de datos principal a la izquierda. Esto permitirá conservar todas las filas de dicha base de datos e incorporar únicamente los resultados de laboratorio provenientes de la base de datos especificado a la derecha de la función.\n\ndatos_unidos &lt;- left_join(datos_notif, datos_lab_casos, \n                         by = \"id_notificacion\")\n\nLa unión se realiza mediante la columna id_notificacion, la cual está presente, completa y depurada en ambas linelists.\nNota: En este caso resulta afortunado contar con un ejemplo tan sencillo de unión. Normalmente sería necesario depurar y verificar exhaustivamente la columna de identificadores, o bien realizar la unión a través de otras variables como el nombre y la fecha de nacimiento. En Feveria, el personal de las clínicas es excelente asignando de manera consistente los identificadores de notificación a cada paciente, incluso en los formularios de muestra enviados al laboratorio; a su vez, el personal de laboratorio es igualmente destacado registrando el identificador de notificación en sus sistemas, lo que permite que los resultados se unan adecuadamente con cada caso.\n\n\n\n\n\n\nAhora comprueba tus datos y revisa.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántas filas hay en su nueva base de datos datos_unidos?\n\n 987 884 858\n\n¿Cómo se compara esto con sus datos originales de notificación?\n\n más filas que el original el mismo número de filas menos filas\n\n¿Qué término describe mejor la unión que acaba de realizar?\n\n muchos-a-uno uno-a-uno muchos-a-muchos\n\n¿Cuántos resultados de laboratorio NO se unieron (pista: usar anti_join())?\n\n 30 19 0\n\n¿Qué tan afortunado es de que su unión haya sido tan exitosa?\n\n ¿Qué? ¿Acaso no toda unión es así de simple?? ¡Muy afortunado! Usualmente algunos registros no coinciden\n\n¿Cuáles son las razones típicas por las que los datos de laboratorio no coinciden con los datos de enfermedades de notificación obligatoria?\n\n Hay errores tipográficos en las columnas usadas para la unión, por lo que no se reconocen como coincidentes Los datos de laboratorio pueden contener casos adicionales de otras clínicas o países Los datos de laboratorio pueden incluir muestras de prueba Las notificaciones pueden haberse omitido accidentalmente en los datos de vigilancia aunque la muestra haya sido analizada en el laboratorio Todas las anteriores\n\n¿Cuántos casos sospechosos no tienen un resultado?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nVerificar el número de filas en cada marco de datos con la función nrow(), o consultando la información del objeto en el Entorno. Se puede observar que esta fue simplemente una unión uno-a-uno, ya que cada fila tenía un id_notificacion único; por lo tanto, una fila en los datos de notificación se unió directamente con una fila en los datos de laboratorio.\nNúmero de filas en los datos de notificación\n\nnrow(datos_notif)\n\n[1] 987\n\n\nNúmero de filas en los datos enlazados\n\nnrow(datos_unidos)\n\n[1] 987\n\n\nPara comprobar si existió algún resultado de laboratorio que no se unirá con los datos de notificación, se puede utilizar anti_join(). En este caso, el objeto datos_lab_casos se coloca a la izquierda, ya que la función evalúa cuántas filas de la base de datos de la izquierda no se encuentran en la base de datos de la derecha, haciendo la coincidencia por id_notificacion.\nEn esta ocasión no es necesario generar una nueva base de datos; simplemente se puede encadenar con un nrow() para contar el número de filas. El resultado es 0, lo que demuestra que no hubo resultados no unidos, ¡excelente!\n\nanti_join(datos_lab_casos, datos_notif, \n          by = \"id_notificacion\") |&gt; nrow()\n\n[1] 0\n\n\nPor último, para comprobar el número de notificaciones sin resultado, puede realizar un anti_join en putting datos_notif primero:\n\nanti_join(datos_notif, datos_lab_casos, \n          by = \"id_notificacion\") |&gt; nrow()\n\n[1] 129\n\n\nO bien, puede simplemente tabular el número de valores que faltan en el columna valor en datos_unidos (como la columna valor procede de los datos del laboratorio).\n\ntabyl(is.na(datos_unidos$valor)) \n\n is.na(datos_unidos$valor)   n   percent\n                     FALSE 858 0.8693009\n                      TRUE 129 0.1306991\n\n\nAmbos enfoques muestran que 129 casos sospechosos no tienen un resultado de laboratorio.\n\n\n\n\n\n\n\n\n\nUtilizar mutate() para crear una nueva columna denominada categoria_casos, actualizando la categoría de los casos sospechosos de acuerdo con su resultado de laboratorio. Las categorías deben definirse de la siguiente manera:\n\nSi el resultado fue positivo: Confirmado\n\nSi el resultado fue negativo: Descartado\n\nSi el resultado fue indeterminado o faltante: Sospechoso\n\nEsto implica que todos los casos en los datos de notificación se consideran inicialmente sospechosos al momento de ser reportados, y permanecen como sospechosos si no existe un resultado de prueba concluyente.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuál es la función más apropiada para crear esta nueva columna?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡pruébela usted primero!)\n\n\n\n\n\nDebe utilizar case_when() para crear la nueva columna. Esta función es ideal para aplicar múltiples condiciones lógicas para crear múltiples valores, mientras que case_match() es mejor para sustituir valores específicos, y if_else() es mejor si sólo hay dos valores posibles.\n\ndatos_unidos &lt;- datos_unidos |&gt; \n  mutate(categoria_casos = case_when(valor==\"Positivo\" ~ \"Confirmado\",\n                                   valor==\"Negativo\" ~ \"Descartado\",\n                                   valor==\"Indeterminado\" | is.na(valor) ~ \"Sospechoso\"))\n\n\n\n\n\n\n\n\n\n\nUtilizar tabyl() en general, y también la tabulación cruzada por enfermedad para responder a las siguientes preguntas.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuántos casos en los datos de notificación unidos no tenían un resultado positivo ni negativo?\n\n 202 347 250\n\n¿Qué porcentaje de casos en los datos de notificación SÍ tenían un resultado positivo o negativo?\n\n 60.1% 79.5% 92.2%\n\n¿Por qué hay más casos sospechosos restantes que notificaciones no enlazadas?\n\n Los casos sospechosos incluyen notificaciones sin resultado de laboratorio y con un resultado de laboratorio indeterminado Se están incorporando casos sospechosos adicionales desde el laboratorio Hay un problema con los datos\n\n¿Qué enfermedad tuvo el mayor porcentaje de casos que permanecieron como sospechosos después de la unión?\n\n Cólera Paludismo Dengue Fiebre amarilla\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nUna vez más se puede utilizar tabyl() para observar la distribución de las categorías de casos en las notificaciones. El número total de casos sospechosos, es decir, aquellos sin resultado de laboratorio o con un resultado indeterminado, es de 202. Esto significa que 785 casos, es decir, el 79.5%, sí contaron con un resultado de laboratorio concluyente.\n\ntabyl(datos_unidos, categoria_casos) \n\n categoria_casos   n   percent\n      Confirmado 438 0.4437690\n      Descartado 347 0.3515704\n      Sospechoso 202 0.2046606\n\n\nTambién se puede realizar una tabla de contingencia entre los resultados originales (indeterminado/negativo/positivo) en la columna valor y la nueva columna categoria_casos, primero para comprobar que la lógica haya funcionado correctamente y, además, para visualizar cómo se asignaron los valores originales a las nuevas categorías. Esto muestra que, además de las 129 notificaciones que no fueron unidas (con NA en la columna valor), 73 tuvieron resultados indeterminados, por lo que fueron clasificadas como casos sospechosos.\n\ntabyl(datos_unidos, categoria_casos, valor) \n\n categoria_casos Indeterminado Negativo Positivo NA_\n      Confirmado             0        0      438   0\n      Descartado             0      347        0   0\n      Sospechoso            73        0        0 129\n\n\nFinalmente, también se puede realizar una tabla de contingencia con el nombre de la enfermedad para observar las categorías de caso por enfermedad. Es posible añadir funciones adicionales adorn_xxx() para aplicar un formato porcentual. La tabla muestra que el 22% de los casos de fiebre amarilla permanecieron como sospechosos, lo cual representó el porcentaje más alto en comparación con las demás enfermedades.\n\ntabyl(datos_unidos, enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n enfermedad_notificada  Confirmado  Descartado  Sospechoso        Total\n                colera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n                dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n       fiebre amarilla 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n       fiebre tifoidea 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n             paludismo 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n                 Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUtilice tabyl() para ello una vez más, observando los resultados por enfermedad. ¡Piense en el denominador correcto!\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué porcentaje de los casos sospechosos notificados en 2024 fueron casos verdaderos, según sus resultados de laboratorio?\n\n 44% 56% 59%\n\n¿Qué porcentaje de los casos sospechosos de paludismo fueron realmente paludismo?\n\n 86% 41% 23%\n\n¿Qué porcentaje de los casos sospechosos de dengue fueron realmente dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nHaga clic para leer una pista\n\n\n\n\n\nDividir el número de casos confirmados (es decir, aquellos con un resultado positivo) entre el número de casos confirmados más los descartados (es decir, aquellos con resultado positivo o negativo). Esto genera una tasa de positividad, que aproxima el porcentaje de casos sospechosos que realmente fueron casos. Los resultados indeterminados se excluyen porque no aportan un desenlace claro y distorsionarían la tasa de positividad.\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nFiltrar los casos sospechosos y luego realizar una tabla de contingencia, para observar el porcentaje de casos inicialmente sospechosos que se convierten en confirmados o descartados, entre aquellos con resultados válidos.\nDado que existe una fila de totales, se puede ver que, en general, el 56% de los casos sospechosos terminaron confirmados, entre aquellos con resultado válido. También se observa que el 41% de los casos de paludismo y el 87% de los casos de dengue fueron confirmados.\n\ndatos_unidos |&gt; \n  filter(categoria_casos != \"Sospechoso\") |&gt; \n  tabyl(enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n enfermedad_notificada  Confirmado  Descartado        Total\n                colera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n                dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n       fiebre amarilla 42.3%  (33) 57.7%  (45) 100.0%  (78)\n       fiebre tifoidea 22.6%   (7) 77.4%  (24) 100.0%  (31)\n             paludismo 41.3% (174) 58.7% (247) 100.0% (421)\n                 Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTarea A: Crear una nueva linelist llamada datos_unidos_confirmados.\nEsto es lo que se utilizará en los informes oficiales de vigilancia.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Por qué estamos optando por reportar solo casos confirmados en nuestros datos de vigilancia?\n\n Reportar casos confirmados puede ser más confiable y preciso cuando el porcentaje de pruebas positivas es bajo y las pruebas de laboratorio son rutinarias, ayudando así a prevenir la sobreestimación de la carga de enfermedad Reportar casos confirmados es más lento, lo que nos da más tiempo para estar seguros de lo que estamos reportando Porque queremos ocultar el número real de casos\n\n¿Qué función es importante para crear la nueva lista de casos (linelist)?\n\n filter() arrange() mutate()\n\n¿Cuántas filas hay en esta nueva base de datos?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡intente hacerlo primero!)\n\n\n\n\n\nLa unidad de vigilancia desea centrarse en los casos confirmados en los informes. Esto se debe a que las pruebas de laboratorio son de rutina en Feveria y, por lo tanto, informar los casos sospechosos sería innecesariamente inexacto, ya que un alto porcentaje de estos terminan siendo descartados.\nLa decisión de publicar casos sospechosos puede ser diferente en otros contextos. Por ejemplo, si la tasa de positividad es alta (la mayoría de los casos resultan ser verdaderos al realizar la prueba), y las pruebas no son frecuentes o tardan mucho en realizarse, lo que retrasaría la notificación, se recomendaría que las tendencias de casos sospechosos fueran suficientemente precisas y más oportunas que esperar la confirmación de laboratorio.\nCrear la nueva linelist con la función filter():\ndatos_unidos_confirmados &lt;- datos_unidos |&gt; \n  filter(categoria_casos==\"Confirmado\")\nY compruebe el número de filas consultando la información de su Entorno, o con nrow():\nnrow(datos_unidos_confirmados)\n[1] 438"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#paso-7.-análisis-descriptivo-de-los-casos-confirmados",
    "href": "pages/multidisease_surveillance.es.html#paso-7.-análisis-descriptivo-de-los-casos-confirmados",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Ahora que ya tiene la lista de casos confirmados de enfermedades de notificación obligatoria reportados en Feveria en 2024, está listo o lista para llevar a cabo la parte final de su análisis de vigilancia. Se trata de resumir las cinco enfermedades de notificación obligatoria por zonas geográficas y por épocas.\nSugerencia Normalmente, el análisis de vigilancia también incluye el análisis por persona. Podría ampliar este estudio de caso analizando también los casos por variables demográficas.\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Qué enfermedad de notificación obligatoria se reportó con mayor frecuencia en 2024, al restringirse solo a los casos confirmados?\n\n Dengue Paludismo Fiebre amarilla\n\n¿Por qué la enfermedad más reportada es diferente al comparar los casos confirmados con los sospechosos?\n\n La sensibilidad y especificidad del diagnóstico clínico pueden variar según la enfermedad El desempeño de las pruebas utilizadas en el laboratorio puede variar según la enfermedad Puede haber sesgos en la notificación ¡Todas las anteriores!\n\n¿Qué distrito reportó el mayor número de casos confirmados de cólera en 2024?\n\n Lago Minara Feveria Central Kasara\n\n¿Cuántos casos confirmados de cólera reportados en 2024 correspondieron a residentes de Feveria Central?\n\n 35 42 4\n\n¿Qué distrito reportó el mayor número de casos confirmados de paludismo en 2024?\n\n Lago Minara Feveria Central Kasara\n\n¿Confirman estos datos que el dengue es la enfermedad infecciosa más común en Feveria?\n\n No - otra enfermedad puede estar subnotificada o no ser de notificación obligatoria Sí - si es la más reportada entonces debe ser la más común\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nUtilizando tabyl() podemos ver que el dengue fue la enfermedad más reportada en Feveria en 2024 cuando se restringe a casos confirmados, con 186 casos.\n\ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada) \n\n enfermedad_notificada   n    percent\n                colera  38 0.08675799\n                dengue 186 0.42465753\n       fiebre amarilla  33 0.07534247\n       fiebre tifoidea   7 0.01598174\n             paludismo 174 0.39726027\n\n\nNótese que esto es diferente a los casos sospechosos, ¡donde el paludismo fue la enfermedad más reportada (con 533 casos sospechosos)! Esto ya se insinuó anteriormente, cuando observamos que la tasa de positividad de los casos sospechosos de dengue era mayor que la de los casos sospechosos de paludismo. Esto puede deberse a diferentes razones, por ejemplo, el método de diagnóstico clínico utilizado para el paludismo puede ser menos específico (lo que podría significar que muchos de los casos sospechosos en realidad se deban a otras enfermedades), o bien la prueba utilizada para el dengue puede ser más sensible.\nPara realizar una tabulación cruzada con el distrito residencial, añada las funciones adorn_xxx().\n\ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada, distrito_residencial) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n enfermedad_notificada Feveria Central     Kasara Lago Minara        Total\n                colera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n                dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n       fiebre amarilla       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n       fiebre tifoidea      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n             paludismo      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n                 Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nAl igual que con los casos sospechosos, podemos ver que la mayoría de los casos confirmados de dengue, paludismo y fiebre amarilla se localizaron en el Lago Minara, la zona lacustre con mayor densidad de mosquitos y, por lo tanto, de enfermedades transmitidas por vectores. La mayoría de los casos confirmados de cólera y fiebre tifoidea se observaron en Feveria Central, donde hay problemas de agua y saneamiento.\nLos datos sugieren que las enfermedades transmitidas por vectores (dengue y paludismo) son especialmente preocupantes en este país tropical. Sin embargo, no sabemos con certeza cuál es la enfermedad más común ni cuáles son los patrones subyacentes: sólo cinco enfermedades son de notificación obligatoria, y normalmente los casos notificados sólo representan una fracción de los casos reales en la comunidad.\n\n\n\n\n\n\n\nProducirá esta curva epidémica en las siguientes tareas distintas.\n\n\n\n\n\n\n\n\n\n\n\nAsegúrese de especificar el argumento binwidth=7 para que cada barra del histograma represente el número de casos en un periodo de 7 días.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuándo se reportó el primer caso de fiebre tifoidea en Feveria en 2024?\n\n Enero 2024 Mayo 2024 Octubre 2024\n\nSegún este gráfico, ¿cuál fue el mayor número de casos de dengue reportados en una sola semana en 2024?\n\n 10 20 30 ¡Es muy difícil saberlo según este gráfico apilado!\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nEste es un código sencillo para producir la curva epidémica. Tenga en cuenta que aún no especificamos los colores ni en qué día de la semana comienza cada período de 7 días.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = enfermedad_notificada)), binwidth=7)\n\n\n\n\n\n\n\n\nConsulte el capítulo de Trabajando con Fechas en el Manual de R para Epis si desea un formato de fecha más específico o que el eje x indique el número de semana (semanas 1 a 52).\nImportante: ¡no es fácil ver las tendencias por enfermedad cuando se grafican apiladas de esta forma! Para visualizar estas tendencias temporales, debe producir un histograma para cada enfermedad.\n\n\n\n\n\n\nUtilice facet_wrap() para crear fácilmente pequeños gráficos multiples, uno por enfermedad. Para entender mejor la función, puede consultar la página Facetas del capítulo sobre ggplot2 en el Manual de R para Epis.\n\n\n\n\n\n\nPreguntas\n\n\n\n\nSegún este gráfico facetado, ¿cuál fue el mayor número de casos notificados de dengue en una sola semana en 2024?\n\n 11 15 29 ¡Todavía no lo puedo determinar!\n\n¿En qué distritos residían los casos de dengue notificados en esa semana?\n\n Los tres distritos Feveria Central Kasara Lago Minara Este gráfico no muestra esa información\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAhora puede ver una curva epidémica por enfermedad. Y puede ver que durante una semana de julio se notificaron 15 casos de dengue. Sin embargo, este gráfico aún no muestra ninguna información geográfica.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada)), binwidth=7) + \n  facet_wrap(.~enfermedad_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿En qué distrito residían los 15 casos de dengue notificados en una semana de julio de 2024?\n\n Los tres distritos Feveria Central Kasara Lago Minara\n\n¿En qué distrito se notificó el primer caso de fiebre tifoidea en 2024?\n\n Kasara Feveria Central Lago Minara ¡Todavía no lo puedo determinar!\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAhora puede ver una curva epidémica por enfermedad, con la coloración que refleja el distrito en el que reside el caso.\nSe puede ver que los 15 casos notificados de dengue en una sola semana vivían en tres distritos diferentes. También puede ver que el primer caso de fiebre tifoidea se registró en Feveria Central.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = distrito_residencial)), binwidth=7) + \n  facet_wrap(.~enfermedad_notificada)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPuede especificar:\n\nEl tema o diseño predeterminado del gráfico general (por ejemplo, color de fondo, aspecto de las líneas de la cuadrícula)\nEl título y las etiquetas\nLos colores de las barras (con scale_fill_manual())\nEl formato y espaciado de las fechas a lo largo del eje x (con scale_x_date)\n¡Muchas otras cosas!\n\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿El cólera y la fiebre tifoidea parecen endémicas?\n\n No - los datos sugieren brotes pequeños y ocasionales Sí los dos son endémicos\n\n¿Hubo un periodo particular del año en que el paludismo alcanzó su pico en 2024?\n\n Sí - alrededor de noviembre/diciembre Sí - alrededor de julio/agosto (verano) No, se mantuvo constantemente alto\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAquí está el código completo. Puede ver que este ejemplo contiene modificaciones adicionales. Por un lado, dentro de facet_wrap() se ha especificado que el panel tenga dos columnas. Por el otro, dentro de scale_x_date() se ha especificado que se muestre solo el día y el mes en el eje x.\n\ndatos_unidos_confirmados |&gt; \n  ggplot()+\n  geom_histogram((aes(x = fecha_notificada, fill = distrito_residencial)), binwidth=7) +\n  facet_wrap(.~enfermedad_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito residencial\",\n       x = \"Fecha notificada por el centro de salud\",\n       y = \"Recuento\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, paludismo, fiebre tifoidea, y fiebre amarilla por semana en Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nTambién podemos observar en la curva epidémica que el cólera y la fiebre tifoidea parecen presentarse como brotes aislados, en lugar de mostrar endemicidad. El paludismo y el dengue, sin embargo, estuvieron presentes en Feveria durante todo el año, con un pico de paludismo más evidente en los meses de verano.\n\n\n\n\n\n\nEsta vez, utilice group_by() y summarize() para producir una tabla por distrito que muestre las fechas más tempranas y más tardías de las notificaciones.\nPuede ajustar la tabla con filter() para crearla para un distrito a la vez.\n\n\n\n\n\n\nPreguntas\n\n\n\n\n¿Cuándo se notificó el primer caso de dengue en Feveria en 2024?\n\n 18 de enero 2024 17 de enero 2024 12 de febrero 2024\n\n¿Cuándo se notificó el último caso de dengue en Feveria Central en 2024?\n\n 22 de agosto 2024 18 de noviembre 2024 25 de diciembre 2024\n\n\n\n\n\n\n\n\n\n\nHaga clic para ver la solución (¡inténtelo usted primero!)\n\n\n\n\n\nAgrupe los datos por enfermedad y luego extraiga la primera y la última fecha para ver la cronología general de cada enfermedad en Feveria.\n\ndatos_unidos_confirmados |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            ultimo_reporte = max(fecha_notificada)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  enfermedad_notificada primer_reporte ultimo_reporte\n  &lt;chr&gt;                 &lt;date&gt;         &lt;date&gt;        \n1 colera                2024-06-03     2024-09-23    \n2 dengue                2024-01-17     2024-11-18    \n3 fiebre amarilla       2024-03-08     2024-08-23    \n4 fiebre tifoidea       2024-05-02     2024-11-07    \n5 paludismo             2024-01-08     2024-12-25    \n\n\nAñada filter() al código para obtener las fechas de “Feveria Central”.\n\ndatos_unidos_confirmados |&gt; \n  filter(distrito_residencial == \"Feveria Central\") |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            recent_reported = max(fecha_notificada)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  enfermedad_notificada primer_reporte recent_reported\n  &lt;chr&gt;                 &lt;date&gt;         &lt;date&gt;         \n1 colera                2024-06-03     2024-09-23     \n2 dengue                2024-01-29     2024-08-22     \n3 fiebre tifoidea       2024-05-02     2024-11-07     \n4 paludismo             2024-01-29     2024-12-17"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#conclusión",
    "href": "pages/multidisease_surveillance.es.html#conclusión",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "¡Vaya! De acuerdo con los objetivos de este estudio de caso, usted ha hecho lo siguiente:\n\nHa utilizado funciones clave de R para limpiar, procesar y unir bases de datos, además de crear nuevas columnas utilizando condiciones lógicas.\nPara tomar decisiones sobre el procesamiento de datos, ha realizado inspecciones y comprobaciones de los datos.\nRealizó un análisis descriptivo exhaustivo para comprender las notificaciones y los datos de laboratorio, antes y después de unirlos. En relación a las cuatro preguntas originales de su supervisor, puede decir:\n\n¿Cuántos casos sospechosos de las diferentes enfermedades de notificación obligatoria se reportaron en 2024, y cuál fue la más frecuente? Según los registros del sistema de vigilancia de enfermedades de notificación obligatoria, el paludismo fue la enfermedad más común en Feveria en 2024: 533 casos sospechosos de paludismo, 273 casos sospechosos de dengue, 100 de fiebre amarilla, 46 de cólera y 35 de fiebre tifoidea.\n¿Qué porcentaje de ellos acabo confirmándose? Casi el 80% de los casos de notificación obligatoria reportados en 2024 tenían un resultado de pruebas de laboratorio en el momento en que se creó la base de datos, con algunas variaciones según la enfermedad. En total, el 56% de los casos notificados acabaron confirmándose, pero este porcentaje osciló entre sólo el 23% en el caso de la fiebre tifoidea (7 casos confirmados de 31 sospechosos) y el 95% en el caso del cólera (38 casos confirmados de 40 sospechosos). Además, la tasa de positividad fue mayor en los casos sospechosos de dengue que en los de paludismo (87% frente a 41%).\n¿Cuántos casos confirmados de las diferentes enfermedades de notificación obligatoria se reportaron en 2024, y cuál fue la más frecuente? Los casos confirmados siguieron una tendencia ligeramente diferente a la de los casos sospechosos: la infección notificada con más frecuencia fue el dengue, con 186 casos, seguido por el paludismo (174), el cólera (38), la fiebre amarilla (33) y la fiebre tifoidea (7).\n¿Cómo se distribuyeron geográfica y temporalmente los casos confirmados en Feveria? Feveria experimentó transmisión de dengue y paludismo durante todo el año, con un pico en verano, y se concentró en el distrito de Lago Minara. También se registraron brotes pequeños y poco frecuentes de enfermedades diarreicas, como el cólera y la fiebre tifoidea, sobre todo en la zona urbana de Feveria Central, donde podrían existir problemas de agua y saneamiento.\n\nPor último, ha reflexionado sobre cómo la calidad y exhaustividad de los datos están determinados por procesos inherentes a la transferencia de los mismos entre los sistemas de vigilancia y los laboratorios.\n\nTiene un gran potencial por delante. Puede utilizar datos de vigilancia para explorar patrones por edad o sexo, calcular tasas con datos poblacionales e incluso analizar retrasos en la notificación al comparar las diferentes fechas en su base de datos.\nHa construido una base sólida y tiene las herramientas óptimas para llevar su análisis al siguiente nivel. Siga adelante: ¡le esperan descubrimientos emocionantes!\nPara profundizar, consulte los demás estudios de casos o explore el Manual de R para Epis."
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#código-de-limpieza-y-análisis-de-datos",
    "href": "pages/multidisease_surveillance.es.html#código-de-limpieza-y-análisis-de-datos",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "A continuación encontrará un script con todos los pasos para la limpieza de datos y el análisis descriptivo. Observe cómo los análisis se incluyen al final, en vez de intercalarse entre los pasos de limpieza. Esta es una forma más ordenada de organizar el script.\nPor motivos de brevedad, el código que aparece a continuación no incluye todas las inspecciones y comprobaciones realizadas durante el proceso, pero si desea puede crear una sección con dichas comprobaciones.\nLa parte superior de su script también debería contener información para ayudar al lector a entender cuál es el propósito del script, así como comentarios a lo largo del mismo. Más adelante se agradecerá haber añadido estos comentarios.\n\n\n\n\n\n\nCódigo para limpiar y analizar los datos de notificación y los datos de laboratorio de Feveria, 2024\n\n\n\n\n\n\n# Código para limpiar y analizar los datos de notificación y de laboratorio de Feveria, 2024\n# Fecha:\n# Elaborado por:\n\n# Instalar paquetes -------------------------------------------------\n# Asegurarse que el paquete \"pacman\" está instalado\nif (!require(\"pacman\")) {\n  install.packages(\"pacman\") }\n\n# Instalar (si es necesario) desde CRAN y cargar los paquetes necesarios\npacman::p_load(\n  rio,        # para importar datos  \n  skimr,      # para revisar los datos\n  janitor,    # para limpieza de datos y crear tablas \n  lubridate,  # para limpieza de fechas\n  epikit,     # para crear grupos de edad \n  gtsummary,  # para generar resúmenes estadísticos, pruebas y regresiones\n  apyramid,   # para graficar pirámides de edad  \n  flextable,  # para crear tablas listas para presentar \n  naniar,     # para evaluar los datos faltantes\n  remotes,    # para instalar paquetes necesarios para descargar datos \n  tidyverse   # para gestión y visualización de datos \n)\n\n# Importar datos --------------------------------------------\n\n# Datos de notificación \ndatos_notif_crudos &lt;- import(\"datos/notificaciones_multienfermedad.xlsx\")\n\n# Datos de laboratorio\ndatos_lab_crudos &lt;- import(\"datos/pruebas_multienfermedad.csv\")\n\n# Limpiar datos de notificación --------------------------------\ndatos_notif &lt;- datos_notif_crudos |&gt; \n  clean_names() |&gt; names()\n  rename(\n    fecha_notificada = fecha_notificada_por_el_centro_de_salud_la_comunidad,\n    id_notificacion = id_de_notificacion) |&gt;\n  select(id_notificacion, distrito_residencial, enfermedad_notificada, fecha_notificada) |&gt; \n  mutate(distrito_residencial = case_match(\n    str_to_title(distrito_residencial),\n    c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n    c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n    c(\"L Minara\", \"Lago Minara\", \"Lakeside\") ~ \"Lago Minara\")) |&gt; \n  mutate(fecha_notificada = ymd(fecha_notificada)) \n\n\n# Limpiar datos de laboratorio ---------------------------------\n# Limpiar los valores\ndatos_lab &lt;- datos_lab_crudos |&gt; \n  mutate(valor = case_match(valor, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positivo\",\n                            \"N\" ~ \"Negativo\",\n                            \"I\" ~ \"Indeterminado\"))\n\n# Crear datos de laboratorio a nivel de prueba \ndatos_lab_pruebas &lt;- datos_lab |&gt; \n  filter(objetivo != \"Dengue IgG\") |&gt; \n  group_by(id_muestra) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Crear datos de laboratorio a nivel de caso\ndatos_lab_casos &lt;- datos_lab_pruebas |&gt; \n  group_by(id_notificacion) |&gt; \n  arrange(desc(valor)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Unir datos de notificación y de laboratorio  ----------------------------\ndatos_unidos &lt;- left_join(datos_notif, datos_lab_casos, by = \"id_notificacion\")\n\n# Limpiar base de datos unificada -----------------------------------------\ndatos_unidos &lt;- datos_unidos |&gt; \n  mutate(categoria_casos = case_when(\n    valor==\"Positivo\" ~ \"Confirmado\",\n    valor==\"Negativo\" ~ \"Descartado\",\n    valor==\"Indeterminado\" | is.na(valor) ~ \"Sospechoso\"))\n\ndatos_unidos_confirmados &lt;- datos_unidos |&gt; \n  filter(categoria_casos==\"Confirmado\")\n\n# ANÁLISIS ---------------------------------------------------------\n# Número de casos sospechosos en Feveria \ntabyl(datos_notif, enfermedad_notificada)\n\n# Distribución de casos sospechosos por distrito \ntabyl(datos_notif, enfermedad_notificada, distrito_residencial) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribución de los resultados por prueba especifíca de cada enfermedad \ntabyl(datos_lab_pruebas, prueba, valor) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de la categoria de caso, en la base de datos unificada \ntabyl(datos_unidos, categoria_casos) \n\n# Distribución de la categoria de caso por enfermedad, en la base de datos unificada\ntabyl(datos_unidos, enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de la categoria de caso por enfermedad, en la base de datos unificada: \n# solo casos con un resultado válido\ndatos_unidos |&gt; \n  filter(categoria_casos != \"Sospechoso\") |&gt; \n  tabyl(enfermedad_notificada, categoria_casos) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n# Distribución de casos confirmados por distrito \ndatos_unidos_confirmados |&gt; \n  tabyl(enfermedad_notificada, distrito_residencial) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n# Visualizar casos confirmados a lo largo del tiempo \ndatos_unidos_confirmados |&gt; \n  ggplot() +\n  geom_histogram(\n    aes(x = fecha_notificada, fill = distrito_residencial), \n    binwidth=7\n  ) +\n  facet_wrap(.~enfermedad_notificada, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"Distrito residencial\",\n       x = \"Fecha notificada por el centro de salud\",\n       y = \"Recuento\",\n       subtitle = \"Número de casos confirmados de cólera, dengue, paludismo, fiebre tifoidea, y fiebre amarilla por semana en Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n# Primera y última fecha de notificación por enfermedad \ndatos_unidos_confirmados |&gt; \n  group_by(enfermedad_notificada) |&gt; \n  summarize(primer_reporte = min(fecha_notificada), \n            ultimo_reporte = max(fecha_notificada)) |&gt;\n  ungroup()"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#información-sobre-casos-de-estudio",
    "href": "pages/multidisease_surveillance.es.html#información-sobre-casos-de-estudio",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Autores originales Paula Blomquist y Alanah Jansen, con el apoyo técnico de la Subdivisión de Vigilancia Mundial, Laboratorios y Sistemas de Datos de los CDC, en colaboración con TEPHINET.\nFuente de datos Datos ficticios proporcionados por Applied Epi.\n\n\n\n\n\n\n\n\n\n\n\n\nFecha\nCambios realizados\nVersión\nAutor\n\n\n\n\nJulio 2025\nPrimer borrador\n1\nPaula Blomquist y Alanah Jansen, Applied Epi, con el apoyo técnico de la Subdivisión de Vigilancia Mundial, Laboratorios y Sistemas de Datos de los CDC, en colaboración con TEPHINET.\n\n\nAgosto 2025\nVersión en español\n1\nLuis Quezada, Martin Lotto y Shazia Ruybal"
  },
  {
    "objectID": "pages/multidisease_surveillance.es.html#condiciones-de-uso",
    "href": "pages/multidisease_surveillance.es.html#condiciones-de-uso",
    "title": "Vinculación y análisis de datos de notificación y datos de laboratorio en R",
    "section": "",
    "text": "Descargo de responsabilidad La información presentada en este ejercicio y los archivos de datos asociados se han elaborado para ayudar al alumnado a alcanzar los objetivos de aprendizaje previstos. El contenido es responsabilidad de los autores y no refleja necesariamente la opinión oficial de los CDC, del Departamento de Salud y Servicios Humanos de EE. UU. o de TEPHINET.\nLicencia: Este estudio de caso está bajo una licencia CC BY-NC-SA 4.0. Para obtener más información sobre cómo compartir y adaptar este estudio de caso, consulte la página escritura asociada.\nFinanciación Este estudio de caso fue financiado al 100% por el Acuerdo de Cooperación número NU2HGH000044 financiado por los Centros para el Control y la Prevención de Enfermedades (CDC) de EE.UU."
  },
  {
    "objectID": "pages/multidisease_surveillance.html",
    "href": "pages/multidisease_surveillance.html",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Tool: R Technical complexity: Intermediate Methodological complexity: Basic\nPrior knowledge required: R basics (Using Rstudio; R packages, functions and arguments, using pipes) as well as key tidyverse functions and ggplots).\nSource: Applied Epi, with technical support provided by the CDC Global Surveillance, Laboratory, and Data Systems Branch in collaboration with TEPHINET.\n\n\n\nFor instructions on how to use our case studies, see our How-to Guide. We welcome feedback and suggestions via contact@appliedepi.org. You can also discuss the case study or related concepts on the Applied Epi Community.\n\n\n\nYou are an epidemiologist working in the national surveillance office of Feveria, a very small tropical country. There are three districts within Feveria:\n\nFeveria Central: an over-populated urban area, with sometimes unreliable water and sanitation infrastructure.\nLake Minara: a lake area with good infrastructure but many mosquitoes in the warmer months of the year.\nKasara: a more sub-urban area on the other side of Feveria Central.\n\nMap of districts in the country Feveria\n\nIt is January 2025, and your supervisor would like you to transfer the routine processing of notifiable disease data from Excel into R, and to conduct some analyses on the data. She wants to know at least:\n\nHow many suspected cases of the different notifiable diseases were reported in 2024, and which was most common?\nWhat percentage of them ended up being confirmed?\nHow many confirmed cases of different notifiable diseases were reported in 2024, and which was most common?\nHow were confirmed cases geographically and temporally distributed in Feveria?\n\nShe asks that you write code to import, clean, link, and analyse the following linelists:\n\n2024 notifiable disease surveillance data: Referred to also as “notification data”, this is surveillance data on five notifiable diseases reported by clinics in Feveria: dengue, malaria, cholera, typhoid fever, and yellow fever. These are suspected cases, based on patients’ symptoms. Clinicians enter each notification into an online system every weekday.\n2024 laboratory test result data: This data comes from lab test results, from three major labs in Feveria. These results are for samples taken from those suspected notifiable disease cases mentioned above.\n\nLet’s go!\n\n\n\nIn this case study you will:\n\nUse key R functions to clean data, reshape datasets, link data sources, and create new columns using logical conditions to prepare data for analysis.\nConduct data inspections and data quality checks at multiple stages of the project and understand their importance for reliable analysis.\nPerform basic descriptive analyses to compare disease trends across different data sources, before and after linkage.\nInterpret differences in results across data sources and understand how these reflect the structure and design of the overall surveillance system.\n\n\n\n\n\n\nStart by setting up a reproducible and well-organized workflow. This will make it easy to rerun your analysis whenever needed.\nTasks:\n\nSet up an RStudio project\nSet up clear sub-folders where your code, data, and outputs will go\nCreate an R script, or an R Markdown file if you prefer. Make sure the script purpose, date, and author are written as comments at the top.\nExtra: Ensure your working language in RStudio is appropriate (e.g. English for this exercise)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\n\nCreate a folder where all the work in this case study will go. For example, create ‘multi_disease_lab’ on your computer desktop. Create your RStudio project to be based in this folder.\nWe suggest creating the following sub-folders: scripts (for your code), data (for your data), and outputs (for your analytical outputs).\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a folder (e.g. ‘multi_disease_lab’ on your Desktop) for your work. To create an Rstudio project in your new folder, click New Project… in the top left of your R Studio, then Existing Directory, then Browse to select your new folder. For more information, look at the R projects section of the Epi R Handbook.\nStart a new R script by clicking New File in the top left of your R Studio, then R Script. Save it immediately in the appropriate place, e.g. in a scripts sub-folder of your R Project.\nAt the top of your new R script, write some essential information like your name, the purpose of the file, and the date.\nYour R locale determines the language and regional settings used for things like date formats and translations. If your locale is different from the language you want for your report (e.g., a French locale vs. an English report), you can change it to English by running Sys.setlocale(\"LC_ALL\", \"English\"). Include this in your script if needed, or skip it if your locale is usually appropriate. This is explained in more detail in the How-to Guide.\n\n\n\n\n\n\nNext in your R script, you need to install and load the necessary R packages. This ensures that the functions you need are available for your analysis.\nYou will need the following packages: {rio} (for importing data),{skimr} (for reviewing data), {janitor} (for cleaning data), {lubridate} (for cleaning dates), {epikit} (for epi-related tasks), {gtsummary} (for summary statistics/tests and regression), {apyramid} (for age-sex pyramids), {flextable} (for presentation-ready tables), {naniar} (for evaluating missing data), and {tidyverse} (for general data manipulation/science tasks).\nYou will also need the {remotes} package to download the data - which we will explain in the download section.\nAs you start, your trusted colleague nudges you and whispers “I’ve heard that a great way to manage your packages is with the {pacman} package”.\nOver to you!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the function p_load() from pacman for this task. You provide the function with a list of packages that you want to use. The function will undertake two steps per package:\n\nCheck if the package is installed on your computer, and install it if necessary.\nLoad the package so it can be used during this R session.\n\nIf you don’t already have pacman installed, you will need to install it the “traditional way” first, with install.packages().\nNote that the order of packages in your p_load function can be important. If two packages have the same function names (e.g. select() in the package MASS and select() in tidyverse, which do different things), then R will use the function from the most recently loaded package. To prioritize functions from tidyverse, which are commonly used for data manipulation and visualization, load tidyverse last.\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  flextable,  # Presentation ready tables\n  naniar,     # Evaluating missingness of data\n  remotes,    # Used to install package to download data\n  tidyverse   # data management and visualization\n)\n\n\n\n\n\n\n\n\n\n\nYour office provides you with two files for your analysis, both containing data for 2024 and updated as of 15th January 2025:\n\nA disease notification-level dataset (“multidisease_notifications.xlsx”) with case information from 5 health centers.\nA laboratory test-level dataset (“multidisease_tests.csv”) submitted by three laboratories conducting testing for the 5 health centers.\n\nFor this case study, you can download the data via Applied Epi’s very useful data repository, which you can access using the {appliedepidata} package. Follow these steps:\n\nInstall the {appliedepidata} package from GitHub using the install_github() function in the {remotes} package (which you installed previously)\n\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSave the two datasets into a specific folder using the save_data() function from {appliedepidata}, by running the code below. The example below saves the data into a data subfolder within the RStudio project. Note that if you do not specify a location within the path argument of the function, a window will pop up asking you to manually select a folder.\n\n\n# Save down the two data files using the save_data() function from appliedepidata\nappliedepidata::save_data(\"multidisease_tests\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"multidisease_notifications\",\n                          path = \"data\")\n\n\n\n\nGreat! Thanks country office and Applied Epi! Now it’s time to import the data from that folder into RStudio, so you can analyse it.\n\n\nIdeally, you will use the same function for importing both datasets, despite one being a .csv and the other an .xlsx file. Note going forward we will simply say “environment” when we mean the environment pane in R Studio.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nUse the import function from the {rio} package, which can recognize and import different file types. It replaces importing functions that are specific to the file type, such as read.csv() from {base} for .csv files and read_excel() from {readxl} to import .xlsx files.\nIf you feel you need to know more about importing functions, read the Import and export chapter of the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nBelow we use the import function to bring in both files. Note how we are assigning the imported data to two objects, one called data_notif_raw, and one called data_lab_raw. We add the ‘raw’ suffix to distinguish this data from the cleaned versions we will make later.\n\n# Import data\n\n# Notification data\ndata_notif_raw &lt;- import(\"data/multidisease_notifications.xlsx\")\n\n# Lab data\ndata_lab_raw &lt;- import(\"data/multidisease_tests.csv\")\n\n\n\n\n\n\n\n\n\nThe data’s in, and now it’s time to see what story it tells. Take an initial look at your two raw data frames to check their contents and quality.\n\n\n\n\nUse skim() from the {skimr} package, names(), ncol(), and nrow() to inspect your data frame.\nskim() gives you a lot of information on data structure and content, whereas names() will show you the different column names in your data. The ncol() and nrow() functions to simply count the numbers of columns and rows in the data. Do you know what to put inside the parentheses?\nEasiest of all though, is to look at the environment. Remember the object in your environment for the notification data is called data_notif_raw.\nClick on the solution box underneath the questions if you need help.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns are there in the notification data?\n\n 10 11 12 13\n\nWhich of these columns are NOT in the data?\n\n Onset date Date reported by Health Facility/Community Date of outcome Date of test Date of birth\n\nWhat is the name of the column in the notification data that identifies each notification?\n\n Notification ID Test ID Health facility code Combination of Notification ID and Sex\n\nHow many rows are there in the notification data?\n\n 987 1314 950 778\n\nWhat type of information can you NOT see in the notification data?\n\n Laboratory test results District of residence Birthday and sex Health facility in which the case was diagnosed Outcome\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse skim() from the {skimr} package to look at a summary of the entire data frame, and View() to look at the whole data frame directly:\n\nskim(data_notif_raw)\n\nOr, you could use names() to print out just the column names. Through either skim() or names() you will be able to see the types of information including: the health facility of the case, birth-date, sex, a flag indicating pregnancy, district of residence, onset date, and date reported by the clinic, and outcome information.\nThere is also a Notification ID which appears to be a unique identifier for a case, but we would want to double check duplicates before we are sure.\nNote that there are NO test results in this data, as these notifications are from clinics diagnosing notifiable diseases based on clinical case definitions.\n\nnames(data_notif_raw)\n\n [1] \"Organisation unit name\"                    \n [2] \"Health facility code\"                      \n [3] \"Notification ID\"                           \n [4] \"Date of Birth\"                             \n [5] \"Sex\"                                       \n [6] \"Pregnant\"                                  \n [7] \"Residential District\"                      \n [8] \"Disease notified\"                          \n [9] \"Onset date\"                                \n[10] \"Date reported by Health Facility/Community\"\n[11] \"Outcome\"                                   \n[12] \"Date of outcome\"                           \n\n\nUse ncol() and nrow() to print the number of columns and rows, like this:\n\nncol(data_notif_raw)\nnrow(data_notif_raw)\n\nThis will print the numbers of columns and rows in your console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nOtherwise, when you look at the environment you can see that the number of observations (which is the same as rows) and columns are listed next to the name of the data frame.\n\n\n\n\n\n\nUse skim() from the {skimr} package or class() to inspect your column classes.\nDo you remember how to specify the column of interest inside the class() function? Alternatively, you can just look at the environment.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns in the notification data frame are recognised by R to be date columns?\n\n 0 2 4\n\nWhat is the class of most columns in the raw notification data frame?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can use class like the example below. The $ is an operator used to select a specific column from the data_notif_raw data frame.\nNote that the back-ticks (`) are used around Date of Birth because the column name contains spaces.\n\nclass(data_notif_raw$`Date of Birth`)\n\nTo look at class via the environment, click on the blue arrow next to the data frame name. The column names will appear, with the class next to it (e.g. it says “chr” to show character class).\nYou can see the none of the columns that should be dates are recognized as dates. Instead, they are recognized as character values.\n\n\n\n\n\n\nUse the tabyl() function to inspect the values within categorical columns, specifying the data frame object in the first argument, and the column name in the second argument.\nFor example, this code tabulates the values for the Sex column. The output shows that male and female are inconsistently spelled across the data. This column would need further cleaning before analysis.\n\ntabyl(data_notif_raw, Sex)\n\n    Sex   n    percent valid_percent\n      F  47 0.04761905    0.05452436\n FEMALE 146 0.14792300    0.16937355\n      M  40 0.04052685    0.04640371\n   MALE 172 0.17426545    0.19953596\n      f 154 0.15602837    0.17865429\n female  98 0.09929078    0.11368910\n      m 119 0.12056738    0.13805104\n   male  86 0.08713273    0.09976798\n   &lt;NA&gt; 125 0.12664640            NA\n\n\nTo inspect missingness, you can use the miss_var_summary() function from the {naniar} package:\n\nmiss_var_summary(data_notif_raw)\n\n# A tibble: 12 × 3\n   variable                                   n_miss pct_miss\n   &lt;chr&gt;                                       &lt;int&gt;    &lt;num&gt;\n 1 Onset date                                    691     70.0\n 2 Pregnant                                      510     51.7\n 3 Outcome                                       197     20.0\n 4 Date of outcome                               197     20.0\n 5 Date of Birth                                 168     17.0\n 6 Sex                                           125     12.7\n 7 Organisation unit name                          0      0  \n 8 Health facility code                            0      0  \n 9 Notification ID                                 0      0  \n10 Residential District                            0      0  \n11 Disease notified                                0      0  \n12 Date reported by Health Facility/Community      0      0  \n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nAre the values in the Residential District column standardized?\n\n No - they need cleaning They are standardized and are ready to be used for analysis\n\nAre the values in the Disease notified column standardized?\n\n No - they need cleaning They are standardized and are ready to be used for analysis\n\nWhat does R recognise as a missing value?\n\n Either no value, or just a space, or just a dot No value in a cell, represented with NA The words Unknown and Uncertain\n\nBased on the missingness of its values, is the Onset date column useful?\n\n Yes, the missingness is low so this column is useful Minimally, as the missingness is too high\n\nWhy might some columns in the notification data have different spellings and non-standardized categories?\n\n A bot scrambles the data so it becomes less identifiable Each clinic might use software that is configured slightly differently, or use free-text entries, so there are variations in spelling The surveillance system software used by the clinical settings has lots of bugs\n\nWhy might some columns in the notification data have high missingness?\n\n The clinician does not ask the patient the question during their consultation The patient might not know or want to share the answer The clinician might not have time to prioritise filling in that field in the data, even if they know the information All of the above, and many more reasons\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the tabyl() function to tabulate the values within the Residential District column. Again, the first argument is the name of the data frame object, and the second argument is the name of the column.\n\ntabyl(data_notif_raw, `Residential District`)\n\n Residential District   n    percent\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n          LAKE MINARA 185 0.18743668\n          Lake Minara  68 0.06889564\n             Lakeside 125 0.12664640\n\n\nYou can see that each of the three locations (Feveria Central, Lake Minara, and Kasara) are spelled in different ways and with different capitalization. This will need to be cleaned out if we want to analyse the geographic distribution of the notifiable diseases.\nSimilarly, use the tabyl() function to tabulate the values within the Disease notified column. You can see these are spelled out appropriately and consistently, so you can already see the distribution of rows by disease without further cleaning.\n\ntabyl(data_notif_raw, `Disease notified`)\n\n Disease notified   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n          malaria 533 0.54002026\n          typhoid  35 0.03546099\n     yellow fever 100 0.10131712\n\n\nA different way of checking missingness is to tabulate the output of the function is.na(). In the example below, the function is.na() evaluates each cell within the column Onset date, returning TRUE for missing ones and FALSE for present ones.\nRunning tabyl() on this TRUE/FALSE output then quickly gives you a clear count and percentage of both missing and non-missing values in that column. Remember, values like a space or the words “Unknown” or “Missing” will not be recognized by R as missing. R will only recognize true blanks as missing, represented by NA.\nFor Onset date, you can see that 70% of cases are missing onset date, suggesting that this column would not be particularly useful for analyzing trends in disease over time.\n\ntabyl(is.na(data_notif_raw$`Onset date`))\n\n is.na(data_notif_raw$`Onset date`)   n   percent\n                              FALSE 296 0.2998987\n                               TRUE 691 0.7001013\n\n\nMissing or non-standardized data can arise for many reasons, including:\n\nthe design of the data collection tool (e.g. whether questions are mandatory or use free text vs. drop-downs),\nthe processes and standards in place (such as which fields staff are instructed to prioritise), and\ncontextual factors (like whether staff have sufficient time to gather the information).\n\n\n\n\n\n\n\n\n\n\nLike with the notification data, use skim(), ncol(), and nrow() functions or check the environment to inspect the lab data.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich linelist has more columns - the notification data or the laboratory data?\n\n Lab data Notification data They have the same number of columns\n\nWhich linelist has more rows?\n\n Lab data Notification data They have the same number of rows\n\nInspect the lab data with View(). Why might the lab data have more records?\n\n There may be several tests or targets per sample There are so many trial test results in the data Not all the notifications have test results yet\n\nWhich of these columns are NOT in the lab data?\n\n Notification ID Sample ID Test type Date of birth Test result\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nJust like in section 3.1, you can use skim() from the {skimr} package to look at the entire laboratory data frame with test results. This will also show you the different column names in the data, showing you that the lab data only contains information about the test and not about the patient. It does however also contain a notification ID, just like the notification data does.\n\nskim(data_lab_raw)\n\nUse ncol() and nrow() to print the number of columns and rows, like this:\n\nncol(data_lab_raw)\nnrow(data_lab_raw)\n\nThis will print the numbers of columns and rows in your console, showing you that the lab data has more rows than the notification data you inspected earlier.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nThere are often more records in the lab data than in the clinical data. If you inspect the data with View(data_lab_raw) and then click on the arrow at the top of the notification_id column to sort it alphabetically, you’ll see that several rows share the same notification_id. This can happen when multiple targets are tested from the same sample (same sample ID), or when a case is retested (resulting in a different sample ID).\n\nView(data_lab_raw)\n\n\n\nlaboratory_namenotification_idsample_iddate_testtesttargetvalueFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nAs above, use the class(), skim(), or tabyl() functions, or inspect the environment, to look at your columns in more detail.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns in the laboratory data frame are recognised by R to be date columns?\n\n 0 1 2\n\nHow many columns in the laboratory data frame have complete data?\n\n 1 3 7 (all of them!)\n\nWhich test detects multiple targets (and therefore has multiple rows per sample)?\n\n Malaria Dengue Yellow Fever Cholera Typhoid Fever\n\nHow many possible test result values are there in the column value?\n\n 5 3 4\n\nWhat is NOT a possible test result for the stool culture test which detects V. cholerae bacteria?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nThe laboratory data has one date column, recognized by R as an “IDate” class. This is a date class used by {rio}’s import() when reading csv files. Like base R’s Date class, it allows sorting by date and analyzing trends over time.\n\nclass(data_lab_raw$date_test)\n\n[1] \"IDate\" \"Date\" \n\n\nUse of the miss_var_summary() function from the {naniar} package demonstrates that all columns in the laboratory data are actually complete. This may be because the laboratory systems use automated processes, so are much less likely to have human error.\n(Important point: Note that in real life, the lab data would probably have some issues too!)\n\nmiss_var_summary(data_lab_raw)\n\n# A tibble: 7 × 3\n  variable        n_miss pct_miss\n  &lt;chr&gt;            &lt;int&gt;    &lt;num&gt;\n1 laboratory_name      0        0\n2 notification_id      0        0\n3 sample_id            0        0\n4 date_test            0        0\n5 test                 0        0\n6 target               0        0\n7 value                0        0\n\n\nTo see how many targets are detected by each test, you can cross-tabulate test and target columns with tabyl(). Write the column names into the function as two separate arguments. The output shows that each test clearly aligns with one or more targets, and only the dengue assay detects more than one target (IgG, IgM, and NS.1).\nTip: Experiment with changing the order of the column names in the function to see the impact on the table.\n\ntabyl(data_lab_raw, target, test)\n\n               target Blood culture Dengue NS1/IgG/IgM IgM ELISA Stool Culture\n           Dengue IgG             0                215         0             0\n           Dengue IgM             0                215         0             0\n          Dengue NS.1             0                215         0             0\n           Plasmodium             0                  0         0             0\n    S. Typhi bacteria            33                  0         0             0\n V. cholerae bacteria             0                  0         0            45\n     Yellow Fever IgM             0                  0        88             0\n Whole Blood Microscopy\n                      0\n                      0\n                      0\n                    503\n                      0\n                      0\n                      0\n\n\nFinally, you can inspect the different test result values in the column value, again using tabyl(). You can see that there are six possible results, including N for negative, P for positive, and I for indeterminate. Cholera specifically does not show P, but can show P01 and P0139, which in this case represent being positive for serogroups O1 or O139.\n\ntabyl(data_lab_raw, test, value)\n\n                   test  I   N   P PO1 PO139\n          Blood culture  2  24   7   0     0\n     Dengue NS1/IgG/IgM  0 354 291   0     0\n              IgM ELISA 10  45  33   0     0\n          Stool Culture  5   2   0  22    16\n Whole Blood Microscopy 56 257 190   0     0\n\n\n\n\n\n\n\n\n\n\nYou now know that the notification data (data_notif_raw) contains information about suspected cases, alongside basic demographic information (age, sex, pregnancy, district of residence), and information about their onset date, date reported by the health facility, and outcome. Some columns need cleaning before further analysis, due to variations in spelling of categorical values and some date columns not being recognized as dates.\nYou will now start writing longer chunks of code to clean data, using various {dplyr} functions chained together with pipes (which look like this: |&gt;).\nNOTE ON PIPES: Pipes allow you to perform several operations in one smooth sequence, by “chaining” different functions together. The output from one function becomes the input for the next.\nIf you need more information on piping, please refer to the Epi R Handbook.\nNote that this exercise uses the base pipe (|&gt;) rather than the magrittr pipe (%&gt;%), as it is faster and does not require package installation. Use the magrittr pipe if you prefer it.\n\n\n\n\nDue to quality and data storage issues, your team recommends that you create a clean linelist that only contains information on the unique identifier, location of the case, disease, and the date the notification was reported to the surveillance system.\nWrite R code to produce a new clean data frame called data_notif, applying the following cleaning tasks:\n\nRename columns to be more machine readable (remove spaces and capitalization) using clean_names() from the {janitor} package\nUse the rename() function from {dplyr} so that the column with the date the case was reported is changed to a more concise date_report.\n\nSelect relevant columns for analysis with the select() function from the {dplyr} package.\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nStart your code with the name of the new data frame, the assignment arrow, and the name of the raw data object. This shows that the outcome of the raw data processing will be assigned to a new object called data_notif.\n\ndata_notif &lt;- data_notif_raw\n\nThen build on this code by adding in additional functions, chained together with a pipe. This lets you perform several operations in one smooth sequence. First, you’ll use clean_names() to standardize all your column names. It automatically replaces spaces and special characters with underscores and converts everything to lowercase, making names easier to work with. Then, you can use rename() to give a column a new name. Just remember, when you use rename(), the column will already have its clean_names() version.\n\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(NEW_NAME = OLD_NAME) |&gt; \n  select(VAR_NAMES)\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to clean column names and select the right columns for analysis:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report)\n\n\n\n\n\n\n\nYou already know from your data inspection that the values for district are not standardized.\nAdd a mutate() function to clean the residential_district column, to:\n\nStandardize the capitalization of the column\nReplace the existing residential_district column with a clean column that only contains these district values: “Lake Minara”, “Feveria Central”, and “Kasara”.\n\nSee the hint to see what functions you can use.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTry using str_to_title() from {stringr} package so that the first letter of each word is upper case and all other letters are lower case. You can also use case_match() to specify different specific typos.\nUse the ‘help’ functionality of RStudio to see how to use these functions. For example, type ?case_match in your console to get the help page. NOTE on case_match() - this is a very useful function for replacing or correcting values, and supersedes recode().\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYour cleaning code should now look like this:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = str_to_title(residential_district)) |&gt; \n  mutate(residential_district = case_match(residential_district,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\"))\n\nYou could also wrap the str_to_title function into the case_match() for shorter code, as follows:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\"))\n\n\n\n\n\n\n\nThe column for report date needs to be transformed so that it is recognized as a date in R. This will allow you to analyse trends over time, including over weeks and months.\nReview the values within the date_report column. Then, add a line to your cleaning code to change date_report into a date class.\nKnowing the structure will allow you to use the correct function to convert the column into a date class. We recommend you use one of the functions from the {lubridate} package: either ymd() (for converting dates written as year-month-date), mdy() (for dates written as month-day-year), or dmy() (for dates written as day-month-year). These functions will recognize any way of writing the date as long as it is the correct order, for example “21st August 2025” and “21-08-2024” would both be recognized by dmy().\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow are the dates currently formatted?\n\n day-month-year year-month-day month-day-year year-day-month\n\nWhich mutate() function should you use to convert the date_report column into a date class?\n\n mutate(date_report = ymd(date_report)) mutate(date_report = dmy(date_report)) mutate(date_report = mdy(date_report))\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can use the head() function to view the first six rows of data for the date_report column. You can see that they are written with the year first, then the month, then the date.\n\nhead(data_notif$date_report)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nYou can use the ymd() function inside mutate() to convert the class of the date_report function. You can double-check that the class is correct by running a class() function afterwards.\nYour cleaning code should now look like this:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\")) |&gt; \n  mutate(date_report = ymd(date_report)) \n\nAnd you can double check the class with this:\n\nclass(data_notif$date_report)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nYour colleagues tell you that each notification_id represents one suspected case. You now want to create a table to check if notification_id is duplicated across rows in you data.\n\n\n\n\n\n\nQuestions\n\n\n\n\nDoes one row in the notification data equate to one case?\n\n Yes No\n\nDo you need to deduplicate your data for epidemiological analysis of cases?\n\n Yes No\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nThere are many ways to do this, but try using count() function from {dplyr}. It will create a table that counts the number of rows per unique value of the column that you specify inside the function. Then, use tabyl() to look at the distribution of these counts.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, pipe from the notification data into the count() function, giving the notification_id column as the only argument. This creates a table that counts the number of rows per unique value of notification_id, shown in a new column n. You can see for example in this excerpt that there is only one row per each of these 6 notification_ids.\n\ndata_notif |&gt; \n  count(notification_id) \n\n\n\n  notification_id n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nThen tabulate the new column n with the tabyl(), which shows that there is only one row per unique notification_id. This means that one row equates to one case, and no further deduplication is needed.\n\ndata_notif |&gt; \n  count(notification_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nYou can now comfortably proceed with descriptive analyses of cases, as your data is clean and you know that one row equals one case. Use the tabyl() function for the following tasks.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich disease was most commonly diagnosed by clinics in Feveria in 2024?\n\n Cholera Malaria Dengue Typhoid Fever Yellow Fever\n\nWhich disease was least commonly diagnosed by clinics in Feveria in 2024?\n\n Cholera Malaria Dengue Typhoid Fever Yellow Fever\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that there were 533 suspected cases of malaria in Feveria in 2024, and only 35 suspected cases of typhoid fever.\n\ntabyl(data_notif, disease_notified)\n\n disease_notified   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n          malaria 533 0.54002026\n          typhoid  35 0.03546099\n     yellow fever 100 0.10131712\n\n\n\n\n\n\n\n\nUse tabyl() to cross-tabulate the disease and district of residence columns.\nBuild on your table by adding various adorn functions from the {janitor} package, to see percentage distributions, e.g. adorn_percentages(), adorn_pct_formatting(), and adorn_ns()\nType the name of the function after a ? in your console (e.g. ?adorn_ns) to see the relevant Help pages. You can also look at the section about {janitor} in the Epi R Handbook for more explanation of adorn_xxx() functions.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich district reported the most vector-borne disease in 2024 (malaria, dengue, yellow fever)?\n\n Lake Minara Feveria Central Kasara\n\nWhich district reported the most diarrhoeal disease in 2024 (cholera, typhoid fever)?\n\n Lake Minara Feveria Central Kasara\n\nWhat factors contribute to increased diarrhoeal disease in this specific district (selected in previous question)?\n\n Unreliable water and sanitation infrastructure Overcrowding of mosquitoes We don't know\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nHere is some code to get you started. It cross-tabulates disease_notified and residential_district with tabyl(), then adding adorn_percentages() converts these numbers to percentages with many decimals. You then need to pipe into adorn_pct_formatting() to convert into actual percentage formatting, and then adorn_ns() to add numbers back in in parentheses.\nNote that adorn_xxx() functions need to be applied in a specific order!\n\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages()\n\nFor factors contributing to more diarrhea - scroll up to earlier in the case study when the districts were first introduced!\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that most suspected cases of dengue, malaria, and yellow fever were located in Lake Minara - the lake area with higher density of mosquitoes and therefore vector-borne disease. Meanwhile the majority of cholera and typhoid fever were in Feveria Central, the over-populated urban area with water and sanitation infrastructure issues that result in higher risk of flooding and drinking water contamination during rainy weather.\n\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n disease_notified Feveria Central      Kasara Lake Minara\n          cholera      91.3% (42)  8.7%   (4)  0.0%   (0)\n           dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n          malaria      13.7% (73) 19.9% (106) 66.4% (354)\n          typhoid      68.6% (24) 31.4%  (11)  0.0%   (0)\n     yellow fever      11.0% (11) 21.0%  (21) 68.0%  (68)\n\n\n\n\n\n\n\n\n\n\nFrom your earlier work in step 3, you have found that the laboratory data contains only testing data, and no patient information. The data is already very clean, so we only need to standardize one column. We will also want to process the laboratory data frame to be one row per notification, so that it can be neatly linked to the notification data frame.\n\n\n\n\nCreate a new object data_lab. This will allow a more straight-forward analysis and interpretation of results.\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse case_match() to turn the different original values into “Positive”, “Negative”, or “Indeterminate”:\n\ndata_lab &lt;- data_lab_raw |&gt; \n  mutate(value = case_match(value, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positive\",\n                            \"N\" ~ \"Negative\",\n                            \"I\" ~ \"Indeterminate\"))\n\nYou can then double-check that the new values look correct by tabulating and comparing the values in the original data frame and the clean one. Make sure that you used the letter ‘O’ and not the number ‘0’!\n\ntabyl(data_lab_raw, value)\n\n value   n    percent\n     I  73 0.05555556\n     N 682 0.51902588\n     P 521 0.39649924\n   PO1  22 0.01674277\n PO139  16 0.01217656\n\n\n\ntabyl(data_lab, value)\n\n         value   n    percent\n Indeterminate  73 0.05555556\n      Negative 682 0.51902588\n      Positive 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nWe already know that some samples have multiple rows, and that this is because the dengue assay has three targets, with one row per target result.\nNow find the number of samples with multiple rows.\nDo this as you did with the notification data, using the data_lab object: first count the number of rows per sample, then create a table to show the distribution of row numbers. Keep in mind that each sample is identified by a sample_ID.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many samples (unique sample_ids) are repeated across three rows?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, pipe from the lab data into the count() function, giving the sample_id column as the only argument. This creates a table that counts the number of rows per unique value of sample_id, shown in a new column n. You can see for example that the sample_id “000e8eee” has three rows, whereas the sample_id “001e1878” is only seen on one row.\n\ndata_lab |&gt; \n  count(sample_id) \n\n\n\n  sample_id n\n1  000e8eee 3\n2  001e1878 1\n3  005f39af 1\n4  00b30781 3\n5  00b56d18 1\n6  0110abcd 3\n\n\nThen tabulate the new column n with the tabyl().\n\ndata_lab |&gt; \n  count(sample_id) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nYou can even double-check that this only applies to the dengue assay by adding in the test column to the calculation. You can see that it is only the dengue test that has 3 rows per sample.\n\ndata_lab |&gt; \n  count(test, sample_id) |&gt; \n  tabyl(test, n)\n\n                   test   1   3\n          Blood culture  33   0\n     Dengue NS1/IgG/IgM   0 215\n              IgM ELISA  88   0\n          Stool Culture  45   0\n Whole Blood Microscopy 503   0\n\n\n\n\n\n\n\n\nAs you saw in section 3.2, your dengue test provides results for three different targets: IgG, IgM, and NS.1. The results for each of these targets can be either negative or positive. However, to simplify and consolidate your data, you want to assign a single negative or positive label to each sample, to indicate if the sample represents current infection.\n\n\ntargetNegativePositiveDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nYour colleague Ben, who works in the lab, advises you on the cleaning as follows:\n\nA sample can be considered positive if NS.1 or IgM are positive (as both can represent acute infection)\nYou can ignore IgG (because a positive result in the absence of positive NS.1 or IgM is indicative of immunity after a past resolved infection)\n\nNow you need to consolidate the dengue test results to one row per test, with one result value. Use filter(), arrange(), and slice(), making sure any sample positive for NS.1 or IgM is considered positive for dengue. Create a new object called data_lab_tests\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTry to apply the following to consolidate according to Ben’s recommendation:\n\nRemove IgG Results: filter out rows where the target is “IgG” using filter() from {dplyr}.\nPrioritize positive IgM/NS1results: Group by sample_id and arrange rows with arrange() so any ‘P’ (positive) result appears first\nFilter to final status: Keep only the first row using slice(1) to get the positive or negative result for the sample.\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to filter out the dengue IgG results, and then consolidate the test result within each group of rows with the same sample_id, prioritizing positive results.\nYou need to specify desc within arrange(), as this means that the results will be in reverse alphabetical order, meaning P will be at the top.\nAlso, add the ungroup() function at the end so that the new data is not grouped, which could confuse further analyses.\n\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(target != \"Dengue IgG\") |&gt; \n  group_by(sample_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nYou can then double-check that the new object data_lab_tests has only one row per test, using the combination of count() and tabyl() like you did in Task A.\nThis table shows you that all unique sample IDs are only present in one row each:\n\ndata_lab_tests |&gt; \n  count(sample_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nNext, you check the number of tests per notification ID in your new consolidated data.\nYou can see that there are 26 rows with the same notification_id as another row, but only among cases tested with whole blood microscopy for malaria.\n\ndata_lab_tests |&gt; \n  count(test, notification_id) |&gt; \n  tabyl(test, n)\n\n                   test   1  2\n          Blood culture  33  0\n     Dengue NS1/IgG/IgM 215  0\n              IgM ELISA  88  0\n          Stool Culture  45  0\n Whole Blood Microscopy 451 26\n\n\nYou investigate further, looking at one example case with notification_id “043228”. This shows you that this one case was tested twice, with two different samples, one week apart. The first result was positive, and the second result was negative.\n\ndata_lab_tests |&gt; \n  filter(notification_id == \"043228\")\n\n# A tibble: 2 × 7\n  laboratory_name        notification_id sample_id date_test  test  target value\n  &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;     &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n1 Kasara University Hos… 043228          27c37cd8  2024-06-18 Whol… Plasm… Posi…\n2 Kasara University Hos… 043228          d2271be0  2024-06-25 Whol… Plasm… Nega…\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich statement about the lab data is correct?\n\n All cases of different diseases get retested Some malaria cases get retested All malaria cases get retested\n\nWill you need to deduplicate the lab data, to link with the notification data?\n\n Yes - we need one row representing the lab result per notification No - the data is sufficiently deduplicated\n\n\n\n\nIf you answered that you need to deduplicate, you are correct!\nDeduplicate your data to have one row per notification ID, prioritizing positive results, so that you can link to the notification data.\nTo do this, follow a similar process as you did in Task B, using the data frame produced by task B:\n\nGroup by notification_id\nArrange by the test result value so that values starting with P are prioritized in the top row, followed by N (negative), and then I (indeterminate).\nThen keep the first row within each group of notification_ids, using slice().\nWhen doing this, create a new object called data_lab_cases.\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to deduplicate rows within each group of rows with the same notification_id, prioritizing positive results. Once again you need to specify desc within arrange(). This works perfectly because the desired priority order for results — positive, then negative, then indeterminate — happens to align with reverse alphabetical order (P comes before N, which comes before I, when sorted descending).\nIf your priority order was more complex or didn’t match alphabetical sorting (e.g., if “indeterminate” needed to come before “negative”), you’d have to convert the result column into a factor and explicitly define the desired order of its levels. Don’t forget to ungroup again at the end.\n\ndata_lab_cases &lt;- data_lab_tests |&gt; \n  group_by(notification_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nYou can then double-check that the new object data_lab_cases has only one row per test, using the combination of count() and tabyl() like you did in Task A. This table shows you that all unique sample IDs are only present in one row each:\n\ndata_lab_cases |&gt; \n  count(notification_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nNow we have two objects that we can use for analysis of laboratory data: data_lab_tests and data_lab_cases.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich object should you use to analyse tests?\n\n data_lab_tests data_lab_cases neither\n\nHow many tests were conducted to test for malaria (via whole blood microscopy)?\n\n 215 503 88 190\n\nWhat percentage of tests for cholera (via stool culture) were positive?\n\n 21% 11% 84% 87%\n\nWhich test had the highest percentage of indeterminate results?\n\n IgM ELISA (for yellow fever detection) Stool Culture (for cholera detection) Blood culture (for typhoid fever detection)\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see the number of positive, negative, and indeterminate results per test. You can add a series of adorn() functions to show percentages and totals.\n\ntabyl(data_lab_tests, test, value) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                   test Indeterminate    Negative    Positive        Total\n          Blood culture     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n     Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n              IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n          Stool Culture    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n Whole Blood Microscopy    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich lab data frame should you use to count the number of suspected cases tested?\n\n data_lab_raw data_lab_cases data_lab_tests data_lab\n\nHow many suspected cases were tested in the 2024 lab data?\n\n 858 1314 884\n\nAre there more suspected cases in the notification data or the lab data?\n\n Notification data Lab data\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can simply look at the number of rows in the data_lab_cases data frame to see the number of suspected cases who were tested.\n\nnrow(data_lab_cases)\n\n[1] 858\n\n\nThis is less than the number of suspected cases that were in the clean notifiable disease surveillance data (data_notif) - which suggests that not all suspected cases in 2024 were tested by the time this data was available.\n\nnrow(data_notif)\n\n[1] 987\n\n\n\n\n\n\n\n\n\n\nNow that both linelists are clean and have one row per suspected case, you can link them to enable the full analysis requested by your boss.\n\n\n\n\nCreate a new object called data_linked, using a xxx_join() function from {dplyr}. You want to keep all notifications, but add on test results where available for each suspected case.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich function is the correct approach if you want to retain all rows from your notification data and bring in results from your lab data?\n\n left_join(data_notif, data_lab_cases… full_join(data_notif, data_lab_cases… right_join(data_notif, data_lab_cases…\n\nWhat identifier should be used to link the two linelists?\n\n sample_id notification_id sample_id and date of report notification_id and date of report\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nLink the data using the left_join() function, with notification data as the main data frame on the left. This will keep all the rows from this data frame, and will just bring in the test results from the lab data specified on the “right” of the function.\n\ndata_linked &lt;- left_join(data_notif, data_lab_cases, \n                         by = \"notification_id\")\n\nYou are linking on the notification_id column, which is present, complete, and clean in both linelists.\nNote: You are lucky to work with such a straight-forward example of linkage! Usually you would need to really clean and check the ID column, or link on other columns like name and date fo birth. In Feveria, clinic staff are fantastic at consistently allocating notification IDs to each patient, including on the sample forms sent to the lab, and then the lab staff are equally brilliant at recording the notification ID in their lab systems so that the results can be linked back to the case.\n\n\n\n\n\n\nNow check your data and review a few things.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many rows are in your new data_linked data frame?\n\n 987 884 858\n\nHow does this compare to your original notification data?\n\n more rows than the original same number of rows fewer rows\n\nWhat term best describes the linkage you just did?\n\n many-to-one one-to-one many-to-many\n\nHow many lab results were NOT linked (hint: use anti-join())?\n\n 30 19 0\n\nHow fortunate are you that your linkage is so successful?\n\n What? Isn't all linkage this simple?? Very! Usually some records don't match\n\nWhat are typical reasons that lab data doesn’t match to the notifiable diseases data?\n\n There are typos in the columns used for linkage, so they are not recognised as matching The lab data may contain additional cases from other clinics or countries The lab data may include test samples Notifications may have been accidentally missed in the notification data even though the sample was tested in the lab All of the above\n\nHow many suspected cases do not have a result?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCheck the number of rows in each data frame with the nrow() function, or by checking the object information in your environment. You can see that this was simply a one-to-one merge, because each row had a unique notification_id, so one row in the notification data linked directly to one row in the lab data.\nNumber of rows in notification data\n\nnrow(data_notif)\n\n[1] 987\n\n\nNumber of rows in linked data\n\nnrow(data_linked)\n\n[1] 987\n\n\nTo check if there were any lab result that were not linked to the notification data, you can use anti_join(). This time the data_lab_cases object is on the left, as the function assess how many rows from the left data frame were not found in the right data frame, matching by notification_id. Here you do not need to generate a new data frame, you can simply pipe into an nrow() to count the number of rows. The output is 0, which shows there were no unlinked results - amazing!\n\nanti_join(data_lab_cases, data_notif, \n          by = \"notification_id\") |&gt; nrow()\n\n[1] 0\n\n\nFinally, to check the number of notifications without a result, you can either conduct an anti_join in putting data_notif first:\n\nanti_join(data_notif, data_lab_cases, \n          by = \"notification_id\") |&gt; nrow()\n\n[1] 129\n\n\nOr, you can simply tabulate the number of missing values in the value column in data_linked (as the value column comes from the lab data).\n\ntabyl(is.na(data_linked$value)) \n\n is.na(data_linked$value)   n   percent\n                    FALSE 858 0.8693009\n                     TRUE 129 0.1306991\n\n\nBoth of these approaches show that 129 suspected cases do not have a lab test result.\n\n\n\n\n\n\n\n\n\nUse mutate() to create a new column case_category, updating the label of suspected cases according to their lab result. The categories should be as follows:\n\nIf the result was positive: Confirmed\nIf the result was negative: Discarded\nIf the result was indeterminate or missing: Suspected\n\nThis means that all cases in the notification data are initially suspected when reported, and then remain suspected if there is no conclusive test result.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich is the most appropriate function for creating this new column?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou should use case_when() to create the new column. This function is ideal for applying multiple logical conditions to create multiple values, whereas case_match() is better for replacing specific values, and if_else() is better if there are only two possible values.\n\ndata_linked &lt;- data_linked |&gt; \n  mutate(case_category = case_when(value==\"Positive\" ~ \"Confirmed\",\n                                   value==\"Negative\" ~ \"Discarded\",\n                                   value==\"Indeterminate\" | is.na(value) ~ \"Suspected\"))\n\n\n\n\n\n\n\n\n\n\nUse tabyl() overall, and also cross-tabulate by disease to answer the questions below.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many cases in the linked notification data did not have a positive or negative result?\n\n 202 347 250\n\nWhat percentage of cases in the notification data DID have a positive or negative result?\n\n 60.1% 79.5% 92.2%\n\nWhy are there more remaining suspected cases than there are unlinked notifications?\n\n Suspected cases include notifications without a lab result and with an indeterminate lab result There are additional suspected cases being brought in from the lab There is an issue with the data\n\nWhich disease had the highest percentage of cases that remained suspected after linkage?\n\n Cholera Malaria Dengue Yellow fever\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nOnce again you can use tabyl() to see the distribution of case categories across notifications. The total number of suspected cases, i.e. those with either no lab result at all or with an indeterminate result, is 202. This means 785 cases, i.e. 79.5%, did have a definitive laboratory result.\n\ntabyl(data_linked, case_category) \n\n case_category   n   percent\n     Confirmed 438 0.4437690\n     Discarded 347 0.3515704\n     Suspected 202 0.2046606\n\n\nYou can also cross-tabulate the original results (indeterminate/negative/positive) in the value column with the new case_category column, firstly to check your logic worked, and to see how the original values map to the new column values. This shows that in addition to the 129 notifications that were not linked (with NA in the value column), 73 had indeterminate results, so were categorized as suspected cases.\n\ntabyl(data_linked, case_category, value) \n\n case_category Indeterminate Negative Positive NA_\n     Confirmed             0        0      438   0\n     Discarded             0      347        0   0\n     Suspected            73        0        0 129\n\n\nFinally, you can also cross-tabulate with the disease name to see the case categories by disease. Add additional adorn_xxx() functions for percentage formatting. The table shows you that 22% of yellow fever cases remained suspected, which was the highest percentage compared to the other diseases.\n\ntabyl(data_linked, disease_notified, case_category) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n disease_notified   Confirmed   Discarded   Suspected        Total\n          cholera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n           dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n          malaria 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n          typhoid 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n     yellow fever 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n            Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUse tabyl() for this once again, looking at the results by disease. Think about the correct denominator!\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhat percentage of suspected cases reported in 2024 were true cases, according to their test results?\n\n 44% 56% 59%\n\nWhat percentage of suspected malaria cases were really malaria?\n\n 86% 41% 23%\n\nWhat percentage of suspected dengue cases were really dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nDivide the number of confirmed cases (i.e. those with a positive result) by the number of confirmed plus discarded cases (i.e. those with either a positive or negative result). This gives a positivity rate, which approximates the percentage of suspected cases that were truly cases. Indeterminate results are excluded because they don’t provide a clear outcome and would skew the positivity rate.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFilter out suspected cases and then cross-tabulate, to see the percentage of originally suspected cases that become confirmed or discarded, among those with valid test results.\nBecause there is a totals row, you can see that 56% of suspected cases overall became confirmed, among those with a valid result. You can also see that 41% and 87% of malaria and dengue cases respectively were confirmed.\n\ndata_linked |&gt; \n  filter(case_category != \"Suspected\") |&gt; \n  tabyl(disease_notified, case_category) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n disease_notified   Confirmed   Discarded        Total\n          cholera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n           dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n          malaria 41.3% (174) 58.7% (247) 100.0% (421)\n          typhoid 22.6%   (7) 77.4%  (24) 100.0%  (31)\n     yellow fever 42.3%  (33) 57.7%  (45) 100.0%  (78)\n            Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTask A: Create a new linelist called data_linked_confirmed.\nThis is what you will use in official surveillance reporting.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhy are we opting to report only confirmed cases in our surveillance data?\n\n Reporting confirmed cases can be more reliable and accurate when the percentage testing positive is low and lab testing is routine, thereby helping prevent over-estimation of disease burden Reporting confirmed cases is slower, which gives us more time to be sure of what we are reporting Because we want to hide the true number of cases\n\nWhat function is important for creating the new linelist?\n\n filter() arrange() mutate()\n\nHow many rows are in this new data frame?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYour surveillance unit wants to focus on confirmed cases in reporting. This is because lab testing is routine in Feveria, and so reporting suspected cases would be unnecessarily inaccurate, with a high percentage of suspected cases getting discarded.\nThe decision to publish suspected cases may be different in other contexts. For example, if the positivity rate is high (most cases are true cases if tested), and testing itself is not common, or testing takes a long time and would result in delayed reporting, this would suggest that suspected case trends are sufficiently accurate and also more timely than waiting for laboratory confirmation.\nCreate the new linelist with the filter() function:\ndata_linked_confirmed &lt;- data_linked |&gt; \n  filter(case_category==\"Confirmed\")\nAnd check the number of rows by looking at the information in your environment, or with nrow():\nnrow(data_linked_confirmed)\n[1] 438\n\n\n\n\n\n\n\nNow that you have your linelist of confirmed notifiable disease cases reported in Feveria in 2024, you are ready to conduct the final part of your surveillance analysis! Namely, this is to summarize the five notifiable diseases by geography and time.\nTip: Typically surveillance analysis would also include analysis by person. You could expand on this case study by also analyzing by demographic variables.\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich notifiable disease was most commonly reported in 2024, when restricting to only confirmed cases?\n\n Dengue Malaria Yellow Fever\n\nWhy is the most commonly reported disease different when looking at confirmed and suspected cases?\n\n The sensitivity and specificity of the clinical diagnosis may differ by disease The performance of the tests used in the lab may differ by disease There may be reporting biases All of the above!\n\nWhich district reported the most confirmed cholera cases in 2024?\n\n Lake Minara Feveria Central Kasara\n\nHow many confirmed cases of cholera reported in 2024 were among residents of Feveria Central?\n\n 35 42 4\n\nWhich district reported the most confirmed malaria cases in 2024?\n\n Lake Minara Feveria Central Kasara\n\nDoes this data confirm that dengue is the most common infectious disease in Feveria?\n\n No - a different disease may be under-reported and/or not notifiable Yes - if it's most reported then it must be most common\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that dengue was the most commonly reported disease in Feveria in 2024 when restricting to confirmed cases, with 186 cases.\n\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified) \n\n disease_notified   n    percent\n          cholera  38 0.08675799\n           dengue 186 0.42465753\n          malaria 174 0.39726027\n          typhoid   7 0.01598174\n     yellow fever  33 0.07534247\n\n\nNote that this is different from the suspected cases, where malaria was most commonly reported (with 533 suspected cases)! This was hinted at previously, when you saw that the positivity rate for suspected dengue cases was higher than for suspected malaria cases. This can be for different reasons, for instance the clinical diagnosis method used for malaria may be less specific (so many of the suspected cases are actually other diseases), or the test used for dengue may be more sensitive.\nTo cross-tabulate with residential district, add the relevant adorn_xxx() functions.\n\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified, residential_district) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n disease_notified Feveria Central     Kasara Lake Minara        Total\n          cholera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n           dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n          malaria      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n          typhoid      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n     yellow fever       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n            Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nLike with the suspected cases, we can see that most confirmed cases of dengue, malaria, and yellow fever were located in Lake Minara - the lake area with higher density of mosquitoes and therefore vector-borne disease. The majority of confirmed cholera and typhoid fever cases were in Feveria Central, where there are water and sanitation issues.\nThe data suggests that vector-borne disease (dengue and malaria) are a particular concern in this tropical country. However, we don’t know for sure which is the most common disease and what the underlying patterns are - only five diseases are notifiable, and typically the reported cases only represent a fraction of true cases in the community.\n\n\n\n\n\n\n\nYou are going to work towards producing this epicurve, over the various tasks below.\n\n\n\n\n\n\n\n\n\n\n\nMake sure you specify the argument binwidth=7 so that each bar in the histogram represents the number of cases within a 7 day period.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhen was the first case of typhoid fever reported in Feveria in 2024?\n\n January 2024 May 2024 October 2024\n\nAccording to this graph, what was the highest number of dengue cases reported in a single week in 2024?\n\n 10 20 30 It's very hard to tell from this stacked graph!\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is some simple code to produce the epicurve. Note that you are not controlling the colors just yet, or specifying what day of the week each 7-day period starts on.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = disease_notified)), binwidth=7)\n\n\n\n\n\n\n\n\nRefer to the dates chapter in the Epi R Handbook if you want more specific date formatting, for instance so that each bar represents a Monday-Sunday week, or the x axis labels the week number (weeks 1 - 52).\nImportantly - it is not straight forward to see the trends per disease when stacked this way! To see such temporal trends, you should produce one histogram per disease.\n\n\n\n\n\n\nUse facet_wrap() to easily create several mini-plots, one per disease. To understand this further, you can look at the facet section of the ggplot2 chapter in the Epi R Handbook\n\n\n\n\n\n\nQuestions\n\n\n\n\nAccording to this faceted graph, what was the highest number of dengue cases reported in a single week in 2024?\n\n 11 15 29 I still can't tell!\n\nAmong the dengue cases reported that week, what districts did they live in?\n\n All three districts Feveria Central Kasara Lake Minara This graph does not show this information\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nNow you can see an epicurve per disease! And you can see that during one week in July, 15 cases of dengue were reported. However, this graph does not show any geographical information yet.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report)), binwidth=7) + \n  facet_wrap(.~disease_notified)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nAmong the 15 dengue cases reported in one week in July 2024, what districts did they live in?\n\n All three districts Feveria Central Kasara Lake Minara\n\nIn what district was the first typhoid fever case reported in 2024?\n\n Kasara Feveria Central Lake Minara I still can't tell!\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nNow you can see an epicurve per disease, with the coloring reflecting the district the case is a resident of.\nYou can see that among the 15 dengue cases reported in a single week, they lived across the three different districts. You can also see that the first case of typhoid was reported in Feveria Central.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) + \n  facet_wrap(.~disease_notified)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can specify:\n\nThe theme/appearance of the overall graph (e.g. background color, appearance of grid lines)\nThe title and labels\nThe colors of the bars (with scale_fill_manual())\nThe formatting and spacing of dates along the x-axis (with scale_x_date)\nMany other things!\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nDo cholera and typhoid fever appear endemic?\n\n No - the data suggests smaller occasional outbreaks Yes they are both endemic\n\nIs there a particular time of the year when malaria peaked in 2024?\n\n Yes - around November/December time Yes - around July/August (summer) time No, it is consistently high\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the fully formatted code. Note some other changes include specifying that we only want two columns of mini-plots within facet_wrap(), and that the date label along the x axis should only show day and month (not year, since all cases are in 2024 anyway).\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) +\n  facet_wrap(.~disease_notified, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District of residence\",\n       x = \"Date reported by clinic\",\n       y = \"Count\",\n       subtitle = \"Number of confirmed cholera, dengue, malaria, typhoid fever, and yellow fever cases by week in Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nWe can also see from the epicurve that cholera and typhoid appear to be occurring as isolated outbreaks, rather than showing endemicity. Malaria and dengue however were present in Feveria throughout the year, with malaria more obviously peaking in the summer months.\n\n\n\n\n\n\nThis time, use group_by() and summarize() to produce a table by district showing the earliest and latest report dates.\nYou can adjust your table with a filter() function to create this table for one district at a time.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhen was the first dengue case reported in Feveria in 2024?\n\n 18th January 2024 17th January 2024 12th February 2024\n\nWhen was the last dengue case reported in Feveria Central in 2024?\n\n 22nd August 2024 18th November 2024 25th December 2024\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nGroup the data by disease and then summarize the first and last date to look at the overall timeline of each disease in Feveria.\n\ndata_linked_confirmed |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            last_reported = max(date_report)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  disease_notified first_reported last_reported\n  &lt;chr&gt;            &lt;date&gt;         &lt;date&gt;       \n1 cholera          2024-06-03     2024-09-23   \n2 dengue           2024-01-17     2024-11-18   \n3 malaria          2024-01-08     2024-12-25   \n4 typhoid          2024-05-02     2024-11-07   \n5 yellow fever     2024-03-08     2024-08-23   \n\n\nAdd a filter() to the code to look at first and most recent report dates for the district you’re interested in.\n\ndata_linked_confirmed |&gt; \n  filter(residential_district == \"Feveria Central\") |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            recent_reported = max(date_report)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  disease_notified first_reported recent_reported\n  &lt;chr&gt;            &lt;date&gt;         &lt;date&gt;         \n1 cholera          2024-06-03     2024-09-23     \n2 dengue           2024-01-29     2024-08-22     \n3 malaria          2024-01-29     2024-12-17     \n4 typhoid          2024-05-02     2024-11-07     \n\n\n\n\n\n\n\n\n\n\nWow! In line with the objectives for this case study, you have done the following:\n\nYou used key R functions to clean, reshape, and link data frames, plus created new columns using logical conditions.\nTo inform the data processing, you conducted data inspections and checks along the way\nYou conducted a thorough descriptive analysis to understand the testing and notification data, before and after linkage. In response to your supervisor’s original four questions, you can say:\n\nHow many suspected cases of the different notifiable diseases were reported in 2024, and which was most common? Malaria was the most common notifiable disease in Feveria in 2024, reported through the notifiable disease surveillance system: There were 533 suspected cases of malaria reported, 273 suspected cases of dengue, 100 yellow fever, 46 cholera, and 35 typhoid.\nWhat percentage of them ended up being confirmed? Almost 80% of notifiable cases reported in 2024 had a laboratory test result by the time the linked dataset was created, with some variation by disease. In total, 56% of notified cases were eventually confirmed, but this ranged from only 23% for typhoid fever (7 confirmed of 31 suspected cases with test results), to 95% for cholera (38 confirmed of 40 suspected cases with rest results). Additionally, the positivity rate was higher for suspected dengue than for suspected malaria (87% vs 41%).\nHow many confirmed cases of different notifiable diseases were reported in 2024, and which was most common? Confirmed cases followed a slightly different trend to suspected cases: the most commonly reported infection was dengue with 186 cases, followed by malaria (174), then cholera (38), yellow fever (33), and typhoid fever (7).\nHow are confirmed cases geographically and temporally distributed in Feveria? Feveria experienced dengue and malaria transmission throughout the year, peaking in the summer, and concentrated in the Lake Minara district. Feveria also experienced small and infrequent outbreaks of diarrhoeal disease, e.g. cholera and typhoid fever, particularly in the urban Feveria Central where there can be issues with water and sanitation.\n\nFinally, you have reflected on how the processes involved in notifiable disease surveillance systems and lab testing, for instance the transfer of data between clinics to labs, can affect data quality and completeness, and therefore your results.\n\nThere is so much more potential ahead. You can explore disease patterns by age or sex, calculate disease rates with population data, and even analyze reporting delays by examining the different dates in your datasets.\nYou have built a strong foundation and are well equipped to take your analysis to the next level. Keep going — exciting discoveries await!\nTo learn more, check out the other case studies or dive into the Epi R Handbook.\n\n\n\nSee below a script of all data cleaning steps and descriptive analyses. Note how the analyses are combined at the end rather than interspersed in between cleaning steps. This is a tidier way to organize your script.\nFor brevity, the code below does not include all inspections and checks made along the way, but you may decide to create a sections with such checks.\nThe top of your script should also contain information to help the reader understand what the script is for, as well as comments throughout. You will thank yourself later for adding these comments!\n\n\n\n\n\n\nCode to clean and analyse notification data and lab data from Feveria, 2024\n\n\n\n\n\n\n# Code to clean and analyse notification data and lab data from Feveria, 2024\n# Date:\n# Author:\n\n# Install packages -------------------------------------------------\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  flextable,  # Presentation ready tables\n  naniar,     # Evaluating missingness of data\n  remotes,    # Used to install package to download data\n  tidyverse   # data management and visualization\n)\n\n# Import data --------------------------------------------\n\n# Notification data\ndata_notif_raw &lt;- import(\"data/multidisease_notifications.xlsx\")\n\n# Lab data\ndata_lab_raw &lt;- import(\"data/multidisease_tests.csv\")\n\n# Clean notification data --------------------------------\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\")) |&gt; \n  mutate(date_report = ymd(date_report)) \n\n\n# Clean and consolidate lab data  ---------------------------------------\n# Clean values\ndata_lab &lt;- data_lab_raw |&gt; \n  mutate(value = case_match(value, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positive\",\n                            \"N\" ~ \"Negative\",\n                            \"I\" ~ \"Indeterminate\"))\n\n# Create test-level lab data\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(target != \"Dengue IgG\") |&gt; \n  group_by(sample_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Create case-level lab data\ndata_lab_cases &lt;- data_lab_tests |&gt; \n  group_by(notification_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Link notification and lab data  ---------------------------------------\ndata_linked &lt;- left_join(data_notif, data_lab_cases, by = \"notification_id\")\n\n# Clean data--------------------------------------------------------------\ndata_linked &lt;- data_linked |&gt; \n  mutate(case_category = case_when(value==\"Positive\" ~ \"Confirmed\",\n                                   value==\"Negative\" ~ \"Discarded\",\n                                   value==\"Indeterminate\" | is.na(value) ~ \"Suspected\"))\n\ndata_linked_confirmed &lt;- data_linked |&gt; \n  filter(case_category==\"Confirmed\")\n\n# ANALYSIS ---------------------------------------------------------\n# Number of suspected cases in Feveria\ntabyl(data_notif, disease_notified)\n\n# Distribution of suspected cases by district\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribution of results per disease-specific test\ntabyl(data_lab_tests, test, value) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of case category, in linked data: all cases\ntabyl(data_linked, case_category) \n\n# Distribution of case category by diseases, in linked data: all cases\ntabyl(data_linked, disease_notified, case_category) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of case category by disease, in linked data: only cases with a valid result\ndata_linked |&gt; \n    filter(case_category != \"Suspected\") |&gt; \n    tabyl(disease_notified, case_category) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of confirmed cases by district\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified, residential_district) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualize confirmed cases over time\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) +\n  facet_wrap(.~disease_notified, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District of residence\",\n       x = \"Date reported by clinic\",\n       y = \"Count\",\n       subtitle = \"Number of confirmed cholera, dengue, malaria, typhoid fever, and yellow fever cases by week in Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# First and last report date per disease\ndata_linked_confirmed |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            last_reported = max(date_report)) |&gt;\n  ungroup()\n\n\n\n\n\n\n\n\n\n\n\n\n\nOriginal authors: Paula Blomquist and Alanah Jansen, with technical support provided by the CDC Global Surveillance, Laboratory, and Data Systems Branch in collaboration with TEPHINET.\nData source: Fictional data provided by Applied Epi.\nEstimated duration: 4 hours\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nChanges made\nVersion\nAuthor\n\n\n\n\nJuly 2025\nFirst draft\n1\nPaula Blomquist and Alanah Jansen, Applied Epi, with technical support by the CDC Global Surveillance, Laboratory, and Data Systems Branch in collaboration with TEPHINET\n\n\n\n\n\n\nDisclaimer: The information presented in this exercise and the associated data files have been developed to help learners achieve the intended learning objectives. The contents are those of the author(s) and do not necessarily represent the official views of CDC, the US Department of Health and Human Services, or TEPHINET.\nLicense: This case study is under a CC BY-NC-SA 4.0 license. For more information about sharing and adapting this case study, see the associated deed.\nFunding: This case study was 100% supported by Cooperative Agreement number NU2HGH000044 funded by the US Centers for Disease Control and Prevention (CDC)."
  },
  {
    "objectID": "pages/multidisease_surveillance.html#scenario",
    "href": "pages/multidisease_surveillance.html#scenario",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "You are an epidemiologist working in the national surveillance office of Feveria, a very small tropical country. There are three districts within Feveria:\n\nFeveria Central: an over-populated urban area, with sometimes unreliable water and sanitation infrastructure.\nLake Minara: a lake area with good infrastructure but many mosquitoes in the warmer months of the year.\nKasara: a more sub-urban area on the other side of Feveria Central.\n\nMap of districts in the country Feveria\n\nIt is January 2025, and your supervisor would like you to transfer the routine processing of notifiable disease data from Excel into R, and to conduct some analyses on the data. She wants to know at least:\n\nHow many suspected cases of the different notifiable diseases were reported in 2024, and which was most common?\nWhat percentage of them ended up being confirmed?\nHow many confirmed cases of different notifiable diseases were reported in 2024, and which was most common?\nHow were confirmed cases geographically and temporally distributed in Feveria?\n\nShe asks that you write code to import, clean, link, and analyse the following linelists:\n\n2024 notifiable disease surveillance data: Referred to also as “notification data”, this is surveillance data on five notifiable diseases reported by clinics in Feveria: dengue, malaria, cholera, typhoid fever, and yellow fever. These are suspected cases, based on patients’ symptoms. Clinicians enter each notification into an online system every weekday.\n2024 laboratory test result data: This data comes from lab test results, from three major labs in Feveria. These results are for samples taken from those suspected notifiable disease cases mentioned above.\n\nLet’s go!"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#objectives",
    "href": "pages/multidisease_surveillance.html#objectives",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "In this case study you will:\n\nUse key R functions to clean data, reshape datasets, link data sources, and create new columns using logical conditions to prepare data for analysis.\nConduct data inspections and data quality checks at multiple stages of the project and understand their importance for reliable analysis.\nPerform basic descriptive analyses to compare disease trends across different data sources, before and after linkage.\nInterpret differences in results across data sources and understand how these reflect the structure and design of the overall surveillance system."
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-1.-set-up",
    "href": "pages/multidisease_surveillance.html#step-1.-set-up",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Start by setting up a reproducible and well-organized workflow. This will make it easy to rerun your analysis whenever needed.\nTasks:\n\nSet up an RStudio project\nSet up clear sub-folders where your code, data, and outputs will go\nCreate an R script, or an R Markdown file if you prefer. Make sure the script purpose, date, and author are written as comments at the top.\nExtra: Ensure your working language in RStudio is appropriate (e.g. English for this exercise)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\n\nCreate a folder where all the work in this case study will go. For example, create ‘multi_disease_lab’ on your computer desktop. Create your RStudio project to be based in this folder.\nWe suggest creating the following sub-folders: scripts (for your code), data (for your data), and outputs (for your analytical outputs).\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a folder (e.g. ‘multi_disease_lab’ on your Desktop) for your work. To create an Rstudio project in your new folder, click New Project… in the top left of your R Studio, then Existing Directory, then Browse to select your new folder. For more information, look at the R projects section of the Epi R Handbook.\nStart a new R script by clicking New File in the top left of your R Studio, then R Script. Save it immediately in the appropriate place, e.g. in a scripts sub-folder of your R Project.\nAt the top of your new R script, write some essential information like your name, the purpose of the file, and the date.\nYour R locale determines the language and regional settings used for things like date formats and translations. If your locale is different from the language you want for your report (e.g., a French locale vs. an English report), you can change it to English by running Sys.setlocale(\"LC_ALL\", \"English\"). Include this in your script if needed, or skip it if your locale is usually appropriate. This is explained in more detail in the How-to Guide.\n\n\n\n\n\n\nNext in your R script, you need to install and load the necessary R packages. This ensures that the functions you need are available for your analysis.\nYou will need the following packages: {rio} (for importing data),{skimr} (for reviewing data), {janitor} (for cleaning data), {lubridate} (for cleaning dates), {epikit} (for epi-related tasks), {gtsummary} (for summary statistics/tests and regression), {apyramid} (for age-sex pyramids), {flextable} (for presentation-ready tables), {naniar} (for evaluating missing data), and {tidyverse} (for general data manipulation/science tasks).\nYou will also need the {remotes} package to download the data - which we will explain in the download section.\nAs you start, your trusted colleague nudges you and whispers “I’ve heard that a great way to manage your packages is with the {pacman} package”.\nOver to you!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the function p_load() from pacman for this task. You provide the function with a list of packages that you want to use. The function will undertake two steps per package:\n\nCheck if the package is installed on your computer, and install it if necessary.\nLoad the package so it can be used during this R session.\n\nIf you don’t already have pacman installed, you will need to install it the “traditional way” first, with install.packages().\nNote that the order of packages in your p_load function can be important. If two packages have the same function names (e.g. select() in the package MASS and select() in tidyverse, which do different things), then R will use the function from the most recently loaded package. To prioritize functions from tidyverse, which are commonly used for data manipulation and visualization, load tidyverse last.\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  flextable,  # Presentation ready tables\n  naniar,     # Evaluating missingness of data\n  remotes,    # Used to install package to download data\n  tidyverse   # data management and visualization\n)"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-2.-download-and-import-the-data",
    "href": "pages/multidisease_surveillance.html#step-2.-download-and-import-the-data",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Your office provides you with two files for your analysis, both containing data for 2024 and updated as of 15th January 2025:\n\nA disease notification-level dataset (“multidisease_notifications.xlsx”) with case information from 5 health centers.\nA laboratory test-level dataset (“multidisease_tests.csv”) submitted by three laboratories conducting testing for the 5 health centers.\n\nFor this case study, you can download the data via Applied Epi’s very useful data repository, which you can access using the {appliedepidata} package. Follow these steps:\n\nInstall the {appliedepidata} package from GitHub using the install_github() function in the {remotes} package (which you installed previously)\n\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSave the two datasets into a specific folder using the save_data() function from {appliedepidata}, by running the code below. The example below saves the data into a data subfolder within the RStudio project. Note that if you do not specify a location within the path argument of the function, a window will pop up asking you to manually select a folder.\n\n\n# Save down the two data files using the save_data() function from appliedepidata\nappliedepidata::save_data(\"multidisease_tests\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"multidisease_notifications\",\n                          path = \"data\")\n\n\n\n\nGreat! Thanks country office and Applied Epi! Now it’s time to import the data from that folder into RStudio, so you can analyse it.\n\n\nIdeally, you will use the same function for importing both datasets, despite one being a .csv and the other an .xlsx file. Note going forward we will simply say “environment” when we mean the environment pane in R Studio.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nUse the import function from the {rio} package, which can recognize and import different file types. It replaces importing functions that are specific to the file type, such as read.csv() from {base} for .csv files and read_excel() from {readxl} to import .xlsx files.\nIf you feel you need to know more about importing functions, read the Import and export chapter of the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nBelow we use the import function to bring in both files. Note how we are assigning the imported data to two objects, one called data_notif_raw, and one called data_lab_raw. We add the ‘raw’ suffix to distinguish this data from the cleaned versions we will make later.\n\n# Import data\n\n# Notification data\ndata_notif_raw &lt;- import(\"data/multidisease_notifications.xlsx\")\n\n# Lab data\ndata_lab_raw &lt;- import(\"data/multidisease_tests.csv\")"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-3.-inspect-the-data",
    "href": "pages/multidisease_surveillance.html#step-3.-inspect-the-data",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "The data’s in, and now it’s time to see what story it tells. Take an initial look at your two raw data frames to check their contents and quality.\n\n\n\n\nUse skim() from the {skimr} package, names(), ncol(), and nrow() to inspect your data frame.\nskim() gives you a lot of information on data structure and content, whereas names() will show you the different column names in your data. The ncol() and nrow() functions to simply count the numbers of columns and rows in the data. Do you know what to put inside the parentheses?\nEasiest of all though, is to look at the environment. Remember the object in your environment for the notification data is called data_notif_raw.\nClick on the solution box underneath the questions if you need help.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns are there in the notification data?\n\n 10 11 12 13\n\nWhich of these columns are NOT in the data?\n\n Onset date Date reported by Health Facility/Community Date of outcome Date of test Date of birth\n\nWhat is the name of the column in the notification data that identifies each notification?\n\n Notification ID Test ID Health facility code Combination of Notification ID and Sex\n\nHow many rows are there in the notification data?\n\n 987 1314 950 778\n\nWhat type of information can you NOT see in the notification data?\n\n Laboratory test results District of residence Birthday and sex Health facility in which the case was diagnosed Outcome\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse skim() from the {skimr} package to look at a summary of the entire data frame, and View() to look at the whole data frame directly:\n\nskim(data_notif_raw)\n\nOr, you could use names() to print out just the column names. Through either skim() or names() you will be able to see the types of information including: the health facility of the case, birth-date, sex, a flag indicating pregnancy, district of residence, onset date, and date reported by the clinic, and outcome information.\nThere is also a Notification ID which appears to be a unique identifier for a case, but we would want to double check duplicates before we are sure.\nNote that there are NO test results in this data, as these notifications are from clinics diagnosing notifiable diseases based on clinical case definitions.\n\nnames(data_notif_raw)\n\n [1] \"Organisation unit name\"                    \n [2] \"Health facility code\"                      \n [3] \"Notification ID\"                           \n [4] \"Date of Birth\"                             \n [5] \"Sex\"                                       \n [6] \"Pregnant\"                                  \n [7] \"Residential District\"                      \n [8] \"Disease notified\"                          \n [9] \"Onset date\"                                \n[10] \"Date reported by Health Facility/Community\"\n[11] \"Outcome\"                                   \n[12] \"Date of outcome\"                           \n\n\nUse ncol() and nrow() to print the number of columns and rows, like this:\n\nncol(data_notif_raw)\nnrow(data_notif_raw)\n\nThis will print the numbers of columns and rows in your console.\n\n\n[1] 12\n\n\n[1] 987\n\n\nOtherwise, when you look at the environment you can see that the number of observations (which is the same as rows) and columns are listed next to the name of the data frame.\n\n\n\n\n\n\nUse skim() from the {skimr} package or class() to inspect your column classes.\nDo you remember how to specify the column of interest inside the class() function? Alternatively, you can just look at the environment.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns in the notification data frame are recognised by R to be date columns?\n\n 0 2 4\n\nWhat is the class of most columns in the raw notification data frame?\n\n character numeric factor\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can use class like the example below. The $ is an operator used to select a specific column from the data_notif_raw data frame.\nNote that the back-ticks (`) are used around Date of Birth because the column name contains spaces.\n\nclass(data_notif_raw$`Date of Birth`)\n\nTo look at class via the environment, click on the blue arrow next to the data frame name. The column names will appear, with the class next to it (e.g. it says “chr” to show character class).\nYou can see the none of the columns that should be dates are recognized as dates. Instead, they are recognized as character values.\n\n\n\n\n\n\nUse the tabyl() function to inspect the values within categorical columns, specifying the data frame object in the first argument, and the column name in the second argument.\nFor example, this code tabulates the values for the Sex column. The output shows that male and female are inconsistently spelled across the data. This column would need further cleaning before analysis.\n\ntabyl(data_notif_raw, Sex)\n\n    Sex   n    percent valid_percent\n      F  47 0.04761905    0.05452436\n FEMALE 146 0.14792300    0.16937355\n      M  40 0.04052685    0.04640371\n   MALE 172 0.17426545    0.19953596\n      f 154 0.15602837    0.17865429\n female  98 0.09929078    0.11368910\n      m 119 0.12056738    0.13805104\n   male  86 0.08713273    0.09976798\n   &lt;NA&gt; 125 0.12664640            NA\n\n\nTo inspect missingness, you can use the miss_var_summary() function from the {naniar} package:\n\nmiss_var_summary(data_notif_raw)\n\n# A tibble: 12 × 3\n   variable                                   n_miss pct_miss\n   &lt;chr&gt;                                       &lt;int&gt;    &lt;num&gt;\n 1 Onset date                                    691     70.0\n 2 Pregnant                                      510     51.7\n 3 Outcome                                       197     20.0\n 4 Date of outcome                               197     20.0\n 5 Date of Birth                                 168     17.0\n 6 Sex                                           125     12.7\n 7 Organisation unit name                          0      0  \n 8 Health facility code                            0      0  \n 9 Notification ID                                 0      0  \n10 Residential District                            0      0  \n11 Disease notified                                0      0  \n12 Date reported by Health Facility/Community      0      0  \n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nAre the values in the Residential District column standardized?\n\n No - they need cleaning They are standardized and are ready to be used for analysis\n\nAre the values in the Disease notified column standardized?\n\n No - they need cleaning They are standardized and are ready to be used for analysis\n\nWhat does R recognise as a missing value?\n\n Either no value, or just a space, or just a dot No value in a cell, represented with NA The words Unknown and Uncertain\n\nBased on the missingness of its values, is the Onset date column useful?\n\n Yes, the missingness is low so this column is useful Minimally, as the missingness is too high\n\nWhy might some columns in the notification data have different spellings and non-standardized categories?\n\n A bot scrambles the data so it becomes less identifiable Each clinic might use software that is configured slightly differently, or use free-text entries, so there are variations in spelling The surveillance system software used by the clinical settings has lots of bugs\n\nWhy might some columns in the notification data have high missingness?\n\n The clinician does not ask the patient the question during their consultation The patient might not know or want to share the answer The clinician might not have time to prioritise filling in that field in the data, even if they know the information All of the above, and many more reasons\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the tabyl() function to tabulate the values within the Residential District column. Again, the first argument is the name of the data frame object, and the second argument is the name of the column.\n\ntabyl(data_notif_raw, `Residential District`)\n\n Residential District   n    percent\n            F Central  32 0.03242148\n            FEVERIA C  23 0.02330294\n      FEVERIA CENTRAL  85 0.08611955\n            Feveria C  24 0.02431611\n      Feveria Central  12 0.01215805\n               KASARA  64 0.06484296\n                  KSR  17 0.01722391\n               Kasara 109 0.11043566\n             L MINARA  50 0.05065856\n             L Minara 193 0.19554205\n          LAKE MINARA 185 0.18743668\n          Lake Minara  68 0.06889564\n             Lakeside 125 0.12664640\n\n\nYou can see that each of the three locations (Feveria Central, Lake Minara, and Kasara) are spelled in different ways and with different capitalization. This will need to be cleaned out if we want to analyse the geographic distribution of the notifiable diseases.\nSimilarly, use the tabyl() function to tabulate the values within the Disease notified column. You can see these are spelled out appropriately and consistently, so you can already see the distribution of rows by disease without further cleaning.\n\ntabyl(data_notif_raw, `Disease notified`)\n\n Disease notified   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n          malaria 533 0.54002026\n          typhoid  35 0.03546099\n     yellow fever 100 0.10131712\n\n\nA different way of checking missingness is to tabulate the output of the function is.na(). In the example below, the function is.na() evaluates each cell within the column Onset date, returning TRUE for missing ones and FALSE for present ones.\nRunning tabyl() on this TRUE/FALSE output then quickly gives you a clear count and percentage of both missing and non-missing values in that column. Remember, values like a space or the words “Unknown” or “Missing” will not be recognized by R as missing. R will only recognize true blanks as missing, represented by NA.\nFor Onset date, you can see that 70% of cases are missing onset date, suggesting that this column would not be particularly useful for analyzing trends in disease over time.\n\ntabyl(is.na(data_notif_raw$`Onset date`))\n\n is.na(data_notif_raw$`Onset date`)   n   percent\n                              FALSE 296 0.2998987\n                               TRUE 691 0.7001013\n\n\nMissing or non-standardized data can arise for many reasons, including:\n\nthe design of the data collection tool (e.g. whether questions are mandatory or use free text vs. drop-downs),\nthe processes and standards in place (such as which fields staff are instructed to prioritise), and\ncontextual factors (like whether staff have sufficient time to gather the information).\n\n\n\n\n\n\n\n\n\n\nLike with the notification data, use skim(), ncol(), and nrow() functions or check the environment to inspect the lab data.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich linelist has more columns - the notification data or the laboratory data?\n\n Lab data Notification data They have the same number of columns\n\nWhich linelist has more rows?\n\n Lab data Notification data They have the same number of rows\n\nInspect the lab data with View(). Why might the lab data have more records?\n\n There may be several tests or targets per sample There are so many trial test results in the data Not all the notifications have test results yet\n\nWhich of these columns are NOT in the lab data?\n\n Notification ID Sample ID Test type Date of birth Test result\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nJust like in section 3.1, you can use skim() from the {skimr} package to look at the entire laboratory data frame with test results. This will also show you the different column names in the data, showing you that the lab data only contains information about the test and not about the patient. It does however also contain a notification ID, just like the notification data does.\n\nskim(data_lab_raw)\n\nUse ncol() and nrow() to print the number of columns and rows, like this:\n\nncol(data_lab_raw)\nnrow(data_lab_raw)\n\nThis will print the numbers of columns and rows in your console, showing you that the lab data has more rows than the notification data you inspected earlier.\n\n\n[1] 7\n\n\n[1] 1314\n\n\nThere are often more records in the lab data than in the clinical data. If you inspect the data with View(data_lab_raw) and then click on the arrow at the top of the notification_id column to sort it alphabetically, you’ll see that several rows share the same notification_id. This can happen when multiple targets are tested from the same sample (same sample ID), or when a case is retested (resulting in a different sample ID).\n\nView(data_lab_raw)\n\n\n\nlaboratory_namenotification_idsample_iddate_testtesttargetvalueFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue NS.1NFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgGNFeveria General Hospitalf2170848b003132024-06-07Dengue NS1/IgG/IgMDengue IgMPFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue NS.1NFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgGNFeveria General Hospital6a47a3ca5e865b2024-06-15Dengue NS1/IgG/IgMDengue IgMP\n\n\n\n\n\n\n\n\nAs above, use the class(), skim(), or tabyl() functions, or inspect the environment, to look at your columns in more detail.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many columns in the laboratory data frame are recognised by R to be date columns?\n\n 0 1 2\n\nHow many columns in the laboratory data frame have complete data?\n\n 1 3 7 (all of them!)\n\nWhich test detects multiple targets (and therefore has multiple rows per sample)?\n\n Malaria Dengue Yellow Fever Cholera Typhoid Fever\n\nHow many possible test result values are there in the column value?\n\n 5 3 4\n\nWhat is NOT a possible test result for the stool culture test which detects V. cholerae bacteria?\n\n P P01 P0139 N I\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nThe laboratory data has one date column, recognized by R as an “IDate” class. This is a date class used by {rio}’s import() when reading csv files. Like base R’s Date class, it allows sorting by date and analyzing trends over time.\n\nclass(data_lab_raw$date_test)\n\n[1] \"IDate\" \"Date\" \n\n\nUse of the miss_var_summary() function from the {naniar} package demonstrates that all columns in the laboratory data are actually complete. This may be because the laboratory systems use automated processes, so are much less likely to have human error.\n(Important point: Note that in real life, the lab data would probably have some issues too!)\n\nmiss_var_summary(data_lab_raw)\n\n# A tibble: 7 × 3\n  variable        n_miss pct_miss\n  &lt;chr&gt;            &lt;int&gt;    &lt;num&gt;\n1 laboratory_name      0        0\n2 notification_id      0        0\n3 sample_id            0        0\n4 date_test            0        0\n5 test                 0        0\n6 target               0        0\n7 value                0        0\n\n\nTo see how many targets are detected by each test, you can cross-tabulate test and target columns with tabyl(). Write the column names into the function as two separate arguments. The output shows that each test clearly aligns with one or more targets, and only the dengue assay detects more than one target (IgG, IgM, and NS.1).\nTip: Experiment with changing the order of the column names in the function to see the impact on the table.\n\ntabyl(data_lab_raw, target, test)\n\n               target Blood culture Dengue NS1/IgG/IgM IgM ELISA Stool Culture\n           Dengue IgG             0                215         0             0\n           Dengue IgM             0                215         0             0\n          Dengue NS.1             0                215         0             0\n           Plasmodium             0                  0         0             0\n    S. Typhi bacteria            33                  0         0             0\n V. cholerae bacteria             0                  0         0            45\n     Yellow Fever IgM             0                  0        88             0\n Whole Blood Microscopy\n                      0\n                      0\n                      0\n                    503\n                      0\n                      0\n                      0\n\n\nFinally, you can inspect the different test result values in the column value, again using tabyl(). You can see that there are six possible results, including N for negative, P for positive, and I for indeterminate. Cholera specifically does not show P, but can show P01 and P0139, which in this case represent being positive for serogroups O1 or O139.\n\ntabyl(data_lab_raw, test, value)\n\n                   test  I   N   P PO1 PO139\n          Blood culture  2  24   7   0     0\n     Dengue NS1/IgG/IgM  0 354 291   0     0\n              IgM ELISA 10  45  33   0     0\n          Stool Culture  5   2   0  22    16\n Whole Blood Microscopy 56 257 190   0     0"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-4.-clean-and-describe-the-notification-data",
    "href": "pages/multidisease_surveillance.html#step-4.-clean-and-describe-the-notification-data",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "You now know that the notification data (data_notif_raw) contains information about suspected cases, alongside basic demographic information (age, sex, pregnancy, district of residence), and information about their onset date, date reported by the health facility, and outcome. Some columns need cleaning before further analysis, due to variations in spelling of categorical values and some date columns not being recognized as dates.\nYou will now start writing longer chunks of code to clean data, using various {dplyr} functions chained together with pipes (which look like this: |&gt;).\nNOTE ON PIPES: Pipes allow you to perform several operations in one smooth sequence, by “chaining” different functions together. The output from one function becomes the input for the next.\nIf you need more information on piping, please refer to the Epi R Handbook.\nNote that this exercise uses the base pipe (|&gt;) rather than the magrittr pipe (%&gt;%), as it is faster and does not require package installation. Use the magrittr pipe if you prefer it.\n\n\n\n\nDue to quality and data storage issues, your team recommends that you create a clean linelist that only contains information on the unique identifier, location of the case, disease, and the date the notification was reported to the surveillance system.\nWrite R code to produce a new clean data frame called data_notif, applying the following cleaning tasks:\n\nRename columns to be more machine readable (remove spaces and capitalization) using clean_names() from the {janitor} package\nUse the rename() function from {dplyr} so that the column with the date the case was reported is changed to a more concise date_report.\n\nSelect relevant columns for analysis with the select() function from the {dplyr} package.\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nStart your code with the name of the new data frame, the assignment arrow, and the name of the raw data object. This shows that the outcome of the raw data processing will be assigned to a new object called data_notif.\n\ndata_notif &lt;- data_notif_raw\n\nThen build on this code by adding in additional functions, chained together with a pipe. This lets you perform several operations in one smooth sequence. First, you’ll use clean_names() to standardize all your column names. It automatically replaces spaces and special characters with underscores and converts everything to lowercase, making names easier to work with. Then, you can use rename() to give a column a new name. Just remember, when you use rename(), the column will already have its clean_names() version.\n\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(NEW_NAME = OLD_NAME) |&gt; \n  select(VAR_NAMES)\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to clean column names and select the right columns for analysis:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report)\n\n\n\n\n\n\n\nYou already know from your data inspection that the values for district are not standardized.\nAdd a mutate() function to clean the residential_district column, to:\n\nStandardize the capitalization of the column\nReplace the existing residential_district column with a clean column that only contains these district values: “Lake Minara”, “Feveria Central”, and “Kasara”.\n\nSee the hint to see what functions you can use.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTry using str_to_title() from {stringr} package so that the first letter of each word is upper case and all other letters are lower case. You can also use case_match() to specify different specific typos.\nUse the ‘help’ functionality of RStudio to see how to use these functions. For example, type ?case_match in your console to get the help page. NOTE on case_match() - this is a very useful function for replacing or correcting values, and supersedes recode().\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYour cleaning code should now look like this:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = str_to_title(residential_district)) |&gt; \n  mutate(residential_district = case_match(residential_district,\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\"))\n\nYou could also wrap the str_to_title function into the case_match() for shorter code, as follows:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\"))\n\n\n\n\n\n\n\nThe column for report date needs to be transformed so that it is recognized as a date in R. This will allow you to analyse trends over time, including over weeks and months.\nReview the values within the date_report column. Then, add a line to your cleaning code to change date_report into a date class.\nKnowing the structure will allow you to use the correct function to convert the column into a date class. We recommend you use one of the functions from the {lubridate} package: either ymd() (for converting dates written as year-month-date), mdy() (for dates written as month-day-year), or dmy() (for dates written as day-month-year). These functions will recognize any way of writing the date as long as it is the correct order, for example “21st August 2025” and “21-08-2024” would both be recognized by dmy().\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow are the dates currently formatted?\n\n day-month-year year-month-day month-day-year year-day-month\n\nWhich mutate() function should you use to convert the date_report column into a date class?\n\n mutate(date_report = ymd(date_report)) mutate(date_report = dmy(date_report)) mutate(date_report = mdy(date_report))\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can use the head() function to view the first six rows of data for the date_report column. You can see that they are written with the year first, then the month, then the date.\n\nhead(data_notif$date_report)\n\n[1] \"2024-03-08\" \"2024-03-11\" \"2024-03-11\" \"2024-03-18\" \"2024-03-14\"\n[6] \"2024-03-12\"\n\n\nYou can use the ymd() function inside mutate() to convert the class of the date_report function. You can double-check that the class is correct by running a class() function afterwards.\nYour cleaning code should now look like this:\n\n# Clean data\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\")) |&gt; \n  mutate(date_report = ymd(date_report)) \n\nAnd you can double check the class with this:\n\nclass(data_notif$date_report)\n\n[1] \"Date\"\n\n\n\n\n\n\n\n\nYour colleagues tell you that each notification_id represents one suspected case. You now want to create a table to check if notification_id is duplicated across rows in you data.\n\n\n\n\n\n\nQuestions\n\n\n\n\nDoes one row in the notification data equate to one case?\n\n Yes No\n\nDo you need to deduplicate your data for epidemiological analysis of cases?\n\n Yes No\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nThere are many ways to do this, but try using count() function from {dplyr}. It will create a table that counts the number of rows per unique value of the column that you specify inside the function. Then, use tabyl() to look at the distribution of these counts.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, pipe from the notification data into the count() function, giving the notification_id column as the only argument. This creates a table that counts the number of rows per unique value of notification_id, shown in a new column n. You can see for example in this excerpt that there is only one row per each of these 6 notification_ids.\n\ndata_notif |&gt; \n  count(notification_id) \n\n\n\n  notification_id n\n1          00399b 1\n2          005c85 1\n3          006f52 1\n4          00cbbb 1\n5          01830d 1\n6          019045 1\n\n\nThen tabulate the new column n with the tabyl(), which shows that there is only one row per unique notification_id. This means that one row equates to one case, and no further deduplication is needed.\n\ndata_notif |&gt; \n  count(notification_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 987       1\n\n\n\n\n\n\n\n\n\nYou can now comfortably proceed with descriptive analyses of cases, as your data is clean and you know that one row equals one case. Use the tabyl() function for the following tasks.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich disease was most commonly diagnosed by clinics in Feveria in 2024?\n\n Cholera Malaria Dengue Typhoid Fever Yellow Fever\n\nWhich disease was least commonly diagnosed by clinics in Feveria in 2024?\n\n Cholera Malaria Dengue Typhoid Fever Yellow Fever\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that there were 533 suspected cases of malaria in Feveria in 2024, and only 35 suspected cases of typhoid fever.\n\ntabyl(data_notif, disease_notified)\n\n disease_notified   n    percent\n          cholera  46 0.04660588\n           dengue 273 0.27659574\n          malaria 533 0.54002026\n          typhoid  35 0.03546099\n     yellow fever 100 0.10131712\n\n\n\n\n\n\n\n\nUse tabyl() to cross-tabulate the disease and district of residence columns.\nBuild on your table by adding various adorn functions from the {janitor} package, to see percentage distributions, e.g. adorn_percentages(), adorn_pct_formatting(), and adorn_ns()\nType the name of the function after a ? in your console (e.g. ?adorn_ns) to see the relevant Help pages. You can also look at the section about {janitor} in the Epi R Handbook for more explanation of adorn_xxx() functions.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich district reported the most vector-borne disease in 2024 (malaria, dengue, yellow fever)?\n\n Lake Minara Feveria Central Kasara\n\nWhich district reported the most diarrhoeal disease in 2024 (cholera, typhoid fever)?\n\n Lake Minara Feveria Central Kasara\n\nWhat factors contribute to increased diarrhoeal disease in this specific district (selected in previous question)?\n\n Unreliable water and sanitation infrastructure Overcrowding of mosquitoes We don't know\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nHere is some code to get you started. It cross-tabulates disease_notified and residential_district with tabyl(), then adding adorn_percentages() converts these numbers to percentages with many decimals. You then need to pipe into adorn_pct_formatting() to convert into actual percentage formatting, and then adorn_ns() to add numbers back in in parentheses.\nNote that adorn_xxx() functions need to be applied in a specific order!\n\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages()\n\nFor factors contributing to more diarrhea - scroll up to earlier in the case study when the districts were first introduced!\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that most suspected cases of dengue, malaria, and yellow fever were located in Lake Minara - the lake area with higher density of mosquitoes and therefore vector-borne disease. Meanwhile the majority of cholera and typhoid fever were in Feveria Central, the over-populated urban area with water and sanitation infrastructure issues that result in higher risk of flooding and drinking water contamination during rainy weather.\n\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n disease_notified Feveria Central      Kasara Lake Minara\n          cholera      91.3% (42)  8.7%   (4)  0.0%   (0)\n           dengue       9.5% (26) 17.6%  (48) 72.9% (199)\n          malaria      13.7% (73) 19.9% (106) 66.4% (354)\n          typhoid      68.6% (24) 31.4%  (11)  0.0%   (0)\n     yellow fever      11.0% (11) 21.0%  (21) 68.0%  (68)"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-5.-clean-consolidate-and-describe-the-laboratory-data",
    "href": "pages/multidisease_surveillance.html#step-5.-clean-consolidate-and-describe-the-laboratory-data",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "From your earlier work in step 3, you have found that the laboratory data contains only testing data, and no patient information. The data is already very clean, so we only need to standardize one column. We will also want to process the laboratory data frame to be one row per notification, so that it can be neatly linked to the notification data frame.\n\n\n\n\nCreate a new object data_lab. This will allow a more straight-forward analysis and interpretation of results.\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse case_match() to turn the different original values into “Positive”, “Negative”, or “Indeterminate”:\n\ndata_lab &lt;- data_lab_raw |&gt; \n  mutate(value = case_match(value, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positive\",\n                            \"N\" ~ \"Negative\",\n                            \"I\" ~ \"Indeterminate\"))\n\nYou can then double-check that the new values look correct by tabulating and comparing the values in the original data frame and the clean one. Make sure that you used the letter ‘O’ and not the number ‘0’!\n\ntabyl(data_lab_raw, value)\n\n value   n    percent\n     I  73 0.05555556\n     N 682 0.51902588\n     P 521 0.39649924\n   PO1  22 0.01674277\n PO139  16 0.01217656\n\n\n\ntabyl(data_lab, value)\n\n         value   n    percent\n Indeterminate  73 0.05555556\n      Negative 682 0.51902588\n      Positive 559 0.42541857\n\n\n\n\n\n\n\n\n\n\n\nWe already know that some samples have multiple rows, and that this is because the dengue assay has three targets, with one row per target result.\nNow find the number of samples with multiple rows.\nDo this as you did with the notification data, using the data_lab object: first count the number of rows per sample, then create a table to show the distribution of row numbers. Keep in mind that each sample is identified by a sample_ID.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many samples (unique sample_ids) are repeated across three rows?\n\n 200 215 230\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, pipe from the lab data into the count() function, giving the sample_id column as the only argument. This creates a table that counts the number of rows per unique value of sample_id, shown in a new column n. You can see for example that the sample_id “000e8eee” has three rows, whereas the sample_id “001e1878” is only seen on one row.\n\ndata_lab |&gt; \n  count(sample_id) \n\n\n\n  sample_id n\n1  000e8eee 3\n2  001e1878 1\n3  005f39af 1\n4  00b30781 3\n5  00b56d18 1\n6  0110abcd 3\n\n\nThen tabulate the new column n with the tabyl().\n\ndata_lab |&gt; \n  count(sample_id) |&gt; \n  tabyl(n)\n\n n n_n   percent\n 1 669 0.7567873\n 3 215 0.2432127\n\n\nYou can even double-check that this only applies to the dengue assay by adding in the test column to the calculation. You can see that it is only the dengue test that has 3 rows per sample.\n\ndata_lab |&gt; \n  count(test, sample_id) |&gt; \n  tabyl(test, n)\n\n                   test   1   3\n          Blood culture  33   0\n     Dengue NS1/IgG/IgM   0 215\n              IgM ELISA  88   0\n          Stool Culture  45   0\n Whole Blood Microscopy 503   0\n\n\n\n\n\n\n\n\nAs you saw in section 3.2, your dengue test provides results for three different targets: IgG, IgM, and NS.1. The results for each of these targets can be either negative or positive. However, to simplify and consolidate your data, you want to assign a single negative or positive label to each sample, to indicate if the sample represents current infection.\n\n\ntargetNegativePositiveDengue IgG110105Dengue IgM105110Dengue NS.113976\n\n\nYour colleague Ben, who works in the lab, advises you on the cleaning as follows:\n\nA sample can be considered positive if NS.1 or IgM are positive (as both can represent acute infection)\nYou can ignore IgG (because a positive result in the absence of positive NS.1 or IgM is indicative of immunity after a past resolved infection)\n\nNow you need to consolidate the dengue test results to one row per test, with one result value. Use filter(), arrange(), and slice(), making sure any sample positive for NS.1 or IgM is considered positive for dengue. Create a new object called data_lab_tests\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTry to apply the following to consolidate according to Ben’s recommendation:\n\nRemove IgG Results: filter out rows where the target is “IgG” using filter() from {dplyr}.\nPrioritize positive IgM/NS1results: Group by sample_id and arrange rows with arrange() so any ‘P’ (positive) result appears first\nFilter to final status: Keep only the first row using slice(1) to get the positive or negative result for the sample.\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to filter out the dengue IgG results, and then consolidate the test result within each group of rows with the same sample_id, prioritizing positive results.\nYou need to specify desc within arrange(), as this means that the results will be in reverse alphabetical order, meaning P will be at the top.\nAlso, add the ungroup() function at the end so that the new data is not grouped, which could confuse further analyses.\n\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(target != \"Dengue IgG\") |&gt; \n  group_by(sample_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\nYou can then double-check that the new object data_lab_tests has only one row per test, using the combination of count() and tabyl() like you did in Task A.\nThis table shows you that all unique sample IDs are only present in one row each:\n\ndata_lab_tests |&gt; \n  count(sample_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 884       1\n\n\n\n\n\n\n\n\nNext, you check the number of tests per notification ID in your new consolidated data.\nYou can see that there are 26 rows with the same notification_id as another row, but only among cases tested with whole blood microscopy for malaria.\n\ndata_lab_tests |&gt; \n  count(test, notification_id) |&gt; \n  tabyl(test, n)\n\n                   test   1  2\n          Blood culture  33  0\n     Dengue NS1/IgG/IgM 215  0\n              IgM ELISA  88  0\n          Stool Culture  45  0\n Whole Blood Microscopy 451 26\n\n\nYou investigate further, looking at one example case with notification_id “043228”. This shows you that this one case was tested twice, with two different samples, one week apart. The first result was positive, and the second result was negative.\n\ndata_lab_tests |&gt; \n  filter(notification_id == \"043228\")\n\n# A tibble: 2 × 7\n  laboratory_name        notification_id sample_id date_test  test  target value\n  &lt;chr&gt;                  &lt;chr&gt;           &lt;chr&gt;     &lt;IDate&gt;    &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n1 Kasara University Hos… 043228          27c37cd8  2024-06-18 Whol… Plasm… Posi…\n2 Kasara University Hos… 043228          d2271be0  2024-06-25 Whol… Plasm… Nega…\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich statement about the lab data is correct?\n\n All cases of different diseases get retested Some malaria cases get retested All malaria cases get retested\n\nWill you need to deduplicate the lab data, to link with the notification data?\n\n Yes - we need one row representing the lab result per notification No - the data is sufficiently deduplicated\n\n\n\n\nIf you answered that you need to deduplicate, you are correct!\nDeduplicate your data to have one row per notification ID, prioritizing positive results, so that you can link to the notification data.\nTo do this, follow a similar process as you did in Task B, using the data frame produced by task B:\n\nGroup by notification_id\nArrange by the test result value so that values starting with P are prioritized in the top row, followed by N (negative), and then I (indeterminate).\nThen keep the first row within each group of notification_ids, using slice().\nWhen doing this, create a new object called data_lab_cases.\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the code to deduplicate rows within each group of rows with the same notification_id, prioritizing positive results. Once again you need to specify desc within arrange(). This works perfectly because the desired priority order for results — positive, then negative, then indeterminate — happens to align with reverse alphabetical order (P comes before N, which comes before I, when sorted descending).\nIf your priority order was more complex or didn’t match alphabetical sorting (e.g., if “indeterminate” needed to come before “negative”), you’d have to convert the result column into a factor and explicitly define the desired order of its levels. Don’t forget to ungroup again at the end.\n\ndata_lab_cases &lt;- data_lab_tests |&gt; \n  group_by(notification_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt;\n  ungroup()\n\nYou can then double-check that the new object data_lab_cases has only one row per test, using the combination of count() and tabyl() like you did in Task A. This table shows you that all unique sample IDs are only present in one row each:\n\ndata_lab_cases |&gt; \n  count(notification_id) |&gt; \n  tabyl(n)\n\n n n_n percent\n 1 858       1\n\n\n\n\n\n\n\n\n\nNow we have two objects that we can use for analysis of laboratory data: data_lab_tests and data_lab_cases.\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich object should you use to analyse tests?\n\n data_lab_tests data_lab_cases neither\n\nHow many tests were conducted to test for malaria (via whole blood microscopy)?\n\n 215 503 88 190\n\nWhat percentage of tests for cholera (via stool culture) were positive?\n\n 21% 11% 84% 87%\n\nWhich test had the highest percentage of indeterminate results?\n\n IgM ELISA (for yellow fever detection) Stool Culture (for cholera detection) Blood culture (for typhoid fever detection)\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see the number of positive, negative, and indeterminate results per test. You can add a series of adorn() functions to show percentages and totals.\n\ntabyl(data_lab_tests, test, value) |&gt; \n  adorn_totals(where = \"col\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n                   test Indeterminate    Negative    Positive        Total\n          Blood culture     6.1%  (2) 72.7%  (24) 21.2%   (7) 100.0%  (33)\n     Dengue NS1/IgG/IgM     0.0%  (0) 13.5%  (29) 86.5% (186) 100.0% (215)\n              IgM ELISA    11.4% (10) 51.1%  (45) 37.5%  (33) 100.0%  (88)\n          Stool Culture    11.1%  (5)  4.4%   (2) 84.4%  (38) 100.0%  (45)\n Whole Blood Microscopy    11.1% (56) 51.1% (257) 37.8% (190) 100.0% (503)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich lab data frame should you use to count the number of suspected cases tested?\n\n data_lab_raw data_lab_cases data_lab_tests data_lab\n\nHow many suspected cases were tested in the 2024 lab data?\n\n 858 1314 884\n\nAre there more suspected cases in the notification data or the lab data?\n\n Notification data Lab data\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou can simply look at the number of rows in the data_lab_cases data frame to see the number of suspected cases who were tested.\n\nnrow(data_lab_cases)\n\n[1] 858\n\n\nThis is less than the number of suspected cases that were in the clean notifiable disease surveillance data (data_notif) - which suggests that not all suspected cases in 2024 were tested by the time this data was available.\n\nnrow(data_notif)\n\n[1] 987"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-6.-linkage-and-final-processing",
    "href": "pages/multidisease_surveillance.html#step-6.-linkage-and-final-processing",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Now that both linelists are clean and have one row per suspected case, you can link them to enable the full analysis requested by your boss.\n\n\n\n\nCreate a new object called data_linked, using a xxx_join() function from {dplyr}. You want to keep all notifications, but add on test results where available for each suspected case.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich function is the correct approach if you want to retain all rows from your notification data and bring in results from your lab data?\n\n left_join(data_notif, data_lab_cases… full_join(data_notif, data_lab_cases… right_join(data_notif, data_lab_cases…\n\nWhat identifier should be used to link the two linelists?\n\n sample_id notification_id sample_id and date of report notification_id and date of report\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nLink the data using the left_join() function, with notification data as the main data frame on the left. This will keep all the rows from this data frame, and will just bring in the test results from the lab data specified on the “right” of the function.\n\ndata_linked &lt;- left_join(data_notif, data_lab_cases, \n                         by = \"notification_id\")\n\nYou are linking on the notification_id column, which is present, complete, and clean in both linelists.\nNote: You are lucky to work with such a straight-forward example of linkage! Usually you would need to really clean and check the ID column, or link on other columns like name and date fo birth. In Feveria, clinic staff are fantastic at consistently allocating notification IDs to each patient, including on the sample forms sent to the lab, and then the lab staff are equally brilliant at recording the notification ID in their lab systems so that the results can be linked back to the case.\n\n\n\n\n\n\nNow check your data and review a few things.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many rows are in your new data_linked data frame?\n\n 987 884 858\n\nHow does this compare to your original notification data?\n\n more rows than the original same number of rows fewer rows\n\nWhat term best describes the linkage you just did?\n\n many-to-one one-to-one many-to-many\n\nHow many lab results were NOT linked (hint: use anti-join())?\n\n 30 19 0\n\nHow fortunate are you that your linkage is so successful?\n\n What? Isn't all linkage this simple?? Very! Usually some records don't match\n\nWhat are typical reasons that lab data doesn’t match to the notifiable diseases data?\n\n There are typos in the columns used for linkage, so they are not recognised as matching The lab data may contain additional cases from other clinics or countries The lab data may include test samples Notifications may have been accidentally missed in the notification data even though the sample was tested in the lab All of the above\n\nHow many suspected cases do not have a result?\n\n 83 100 129\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCheck the number of rows in each data frame with the nrow() function, or by checking the object information in your environment. You can see that this was simply a one-to-one merge, because each row had a unique notification_id, so one row in the notification data linked directly to one row in the lab data.\nNumber of rows in notification data\n\nnrow(data_notif)\n\n[1] 987\n\n\nNumber of rows in linked data\n\nnrow(data_linked)\n\n[1] 987\n\n\nTo check if there were any lab result that were not linked to the notification data, you can use anti_join(). This time the data_lab_cases object is on the left, as the function assess how many rows from the left data frame were not found in the right data frame, matching by notification_id. Here you do not need to generate a new data frame, you can simply pipe into an nrow() to count the number of rows. The output is 0, which shows there were no unlinked results - amazing!\n\nanti_join(data_lab_cases, data_notif, \n          by = \"notification_id\") |&gt; nrow()\n\n[1] 0\n\n\nFinally, to check the number of notifications without a result, you can either conduct an anti_join in putting data_notif first:\n\nanti_join(data_notif, data_lab_cases, \n          by = \"notification_id\") |&gt; nrow()\n\n[1] 129\n\n\nOr, you can simply tabulate the number of missing values in the value column in data_linked (as the value column comes from the lab data).\n\ntabyl(is.na(data_linked$value)) \n\n is.na(data_linked$value)   n   percent\n                    FALSE 858 0.8693009\n                     TRUE 129 0.1306991\n\n\nBoth of these approaches show that 129 suspected cases do not have a lab test result.\n\n\n\n\n\n\n\n\n\nUse mutate() to create a new column case_category, updating the label of suspected cases according to their lab result. The categories should be as follows:\n\nIf the result was positive: Confirmed\nIf the result was negative: Discarded\nIf the result was indeterminate or missing: Suspected\n\nThis means that all cases in the notification data are initially suspected when reported, and then remain suspected if there is no conclusive test result.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich is the most appropriate function for creating this new column?\n\n case_when() if_else() case_match()\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYou should use case_when() to create the new column. This function is ideal for applying multiple logical conditions to create multiple values, whereas case_match() is better for replacing specific values, and if_else() is better if there are only two possible values.\n\ndata_linked &lt;- data_linked |&gt; \n  mutate(case_category = case_when(value==\"Positive\" ~ \"Confirmed\",\n                                   value==\"Negative\" ~ \"Discarded\",\n                                   value==\"Indeterminate\" | is.na(value) ~ \"Suspected\"))\n\n\n\n\n\n\n\n\n\n\nUse tabyl() overall, and also cross-tabulate by disease to answer the questions below.\n\n\n\n\n\n\nQuestions\n\n\n\n\nHow many cases in the linked notification data did not have a positive or negative result?\n\n 202 347 250\n\nWhat percentage of cases in the notification data DID have a positive or negative result?\n\n 60.1% 79.5% 92.2%\n\nWhy are there more remaining suspected cases than there are unlinked notifications?\n\n Suspected cases include notifications without a lab result and with an indeterminate lab result There are additional suspected cases being brought in from the lab There is an issue with the data\n\nWhich disease had the highest percentage of cases that remained suspected after linkage?\n\n Cholera Malaria Dengue Yellow fever\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nOnce again you can use tabyl() to see the distribution of case categories across notifications. The total number of suspected cases, i.e. those with either no lab result at all or with an indeterminate result, is 202. This means 785 cases, i.e. 79.5%, did have a definitive laboratory result.\n\ntabyl(data_linked, case_category) \n\n case_category   n   percent\n     Confirmed 438 0.4437690\n     Discarded 347 0.3515704\n     Suspected 202 0.2046606\n\n\nYou can also cross-tabulate the original results (indeterminate/negative/positive) in the value column with the new case_category column, firstly to check your logic worked, and to see how the original values map to the new column values. This shows that in addition to the 129 notifications that were not linked (with NA in the value column), 73 had indeterminate results, so were categorized as suspected cases.\n\ntabyl(data_linked, case_category, value) \n\n case_category Indeterminate Negative Positive NA_\n     Confirmed             0        0      438   0\n     Discarded             0      347        0   0\n     Suspected            73        0        0 129\n\n\nFinally, you can also cross-tabulate with the disease name to see the case categories by disease. Add additional adorn_xxx() functions for percentage formatting. The table shows you that 22% of yellow fever cases remained suspected, which was the highest percentage compared to the other diseases.\n\ntabyl(data_linked, disease_notified, case_category) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n disease_notified   Confirmed   Discarded   Suspected        Total\n          cholera 82.6%  (38)  4.3%   (2) 13.0%   (6) 100.0%  (46)\n           dengue 68.1% (186) 10.6%  (29) 21.2%  (58) 100.0% (273)\n          malaria 32.6% (174) 46.3% (247) 21.0% (112) 100.0% (533)\n          typhoid 20.0%   (7) 68.6%  (24) 11.4%   (4) 100.0%  (35)\n     yellow fever 33.0%  (33) 45.0%  (45) 22.0%  (22) 100.0% (100)\n            Total 44.4% (438) 35.2% (347) 20.5% (202) 100.0% (987)\n\n\n\n\n\n\n\n\nUse tabyl() for this once again, looking at the results by disease. Think about the correct denominator!\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhat percentage of suspected cases reported in 2024 were true cases, according to their test results?\n\n 44% 56% 59%\n\nWhat percentage of suspected malaria cases were really malaria?\n\n 86% 41% 23%\n\nWhat percentage of suspected dengue cases were really dengue?\n\n 87% 41% 23%\n\n\n\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nDivide the number of confirmed cases (i.e. those with a positive result) by the number of confirmed plus discarded cases (i.e. those with either a positive or negative result). This gives a positivity rate, which approximates the percentage of suspected cases that were truly cases. Indeterminate results are excluded because they don’t provide a clear outcome and would skew the positivity rate.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFilter out suspected cases and then cross-tabulate, to see the percentage of originally suspected cases that become confirmed or discarded, among those with valid test results.\nBecause there is a totals row, you can see that 56% of suspected cases overall became confirmed, among those with a valid result. You can also see that 41% and 87% of malaria and dengue cases respectively were confirmed.\n\ndata_linked |&gt; \n  filter(case_category != \"Suspected\") |&gt; \n  tabyl(disease_notified, case_category) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns()\n\n disease_notified   Confirmed   Discarded        Total\n          cholera 95.0%  (38)  5.0%   (2) 100.0%  (40)\n           dengue 86.5% (186) 13.5%  (29) 100.0% (215)\n          malaria 41.3% (174) 58.7% (247) 100.0% (421)\n          typhoid 22.6%   (7) 77.4%  (24) 100.0%  (31)\n     yellow fever 42.3%  (33) 57.7%  (45) 100.0%  (78)\n            Total 55.8% (438) 44.2% (347) 100.0% (785)\n\n\n\n\n\n\n\n\n\nTask A: Create a new linelist called data_linked_confirmed.\nThis is what you will use in official surveillance reporting.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhy are we opting to report only confirmed cases in our surveillance data?\n\n Reporting confirmed cases can be more reliable and accurate when the percentage testing positive is low and lab testing is routine, thereby helping prevent over-estimation of disease burden Reporting confirmed cases is slower, which gives us more time to be sure of what we are reporting Because we want to hide the true number of cases\n\nWhat function is important for creating the new linelist?\n\n filter() arrange() mutate()\n\nHow many rows are in this new data frame?\n\n 389 438 858\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nYour surveillance unit wants to focus on confirmed cases in reporting. This is because lab testing is routine in Feveria, and so reporting suspected cases would be unnecessarily inaccurate, with a high percentage of suspected cases getting discarded.\nThe decision to publish suspected cases may be different in other contexts. For example, if the positivity rate is high (most cases are true cases if tested), and testing itself is not common, or testing takes a long time and would result in delayed reporting, this would suggest that suspected case trends are sufficiently accurate and also more timely than waiting for laboratory confirmation.\nCreate the new linelist with the filter() function:\ndata_linked_confirmed &lt;- data_linked |&gt; \n  filter(case_category==\"Confirmed\")\nAnd check the number of rows by looking at the information in your environment, or with nrow():\nnrow(data_linked_confirmed)\n[1] 438"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#step-7.-descriptive-analysis-of-confirmed-cases",
    "href": "pages/multidisease_surveillance.html#step-7.-descriptive-analysis-of-confirmed-cases",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Now that you have your linelist of confirmed notifiable disease cases reported in Feveria in 2024, you are ready to conduct the final part of your surveillance analysis! Namely, this is to summarize the five notifiable diseases by geography and time.\nTip: Typically surveillance analysis would also include analysis by person. You could expand on this case study by also analyzing by demographic variables.\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhich notifiable disease was most commonly reported in 2024, when restricting to only confirmed cases?\n\n Dengue Malaria Yellow Fever\n\nWhy is the most commonly reported disease different when looking at confirmed and suspected cases?\n\n The sensitivity and specificity of the clinical diagnosis may differ by disease The performance of the tests used in the lab may differ by disease There may be reporting biases All of the above!\n\nWhich district reported the most confirmed cholera cases in 2024?\n\n Lake Minara Feveria Central Kasara\n\nHow many confirmed cases of cholera reported in 2024 were among residents of Feveria Central?\n\n 35 42 4\n\nWhich district reported the most confirmed malaria cases in 2024?\n\n Lake Minara Feveria Central Kasara\n\nDoes this data confirm that dengue is the most common infectious disease in Feveria?\n\n No - a different disease may be under-reported and/or not notifiable Yes - if it's most reported then it must be most common\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing tabyl(), we can see that dengue was the most commonly reported disease in Feveria in 2024 when restricting to confirmed cases, with 186 cases.\n\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified) \n\n disease_notified   n    percent\n          cholera  38 0.08675799\n           dengue 186 0.42465753\n          malaria 174 0.39726027\n          typhoid   7 0.01598174\n     yellow fever  33 0.07534247\n\n\nNote that this is different from the suspected cases, where malaria was most commonly reported (with 533 suspected cases)! This was hinted at previously, when you saw that the positivity rate for suspected dengue cases was higher than for suspected malaria cases. This can be for different reasons, for instance the clinical diagnosis method used for malaria may be less specific (so many of the suspected cases are actually other diseases), or the test used for dengue may be more sensitive.\nTo cross-tabulate with residential district, add the relevant adorn_xxx() functions.\n\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified, residential_district) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n disease_notified Feveria Central     Kasara Lake Minara        Total\n          cholera      92.1% (35)  7.9%  (3)  0.0%   (0) 100.0%  (38)\n           dengue       8.6% (16) 17.2% (32) 74.2% (138) 100.0% (186)\n          malaria      14.9% (26) 22.4% (39) 62.6% (109) 100.0% (174)\n          typhoid      71.4%  (5) 28.6%  (2)  0.0%   (0) 100.0%   (7)\n     yellow fever       0.0%  (0) 18.2%  (6) 81.8%  (27) 100.0%  (33)\n            Total      18.7% (82) 18.7% (82) 62.6% (274) 100.0% (438)\n\n\nLike with the suspected cases, we can see that most confirmed cases of dengue, malaria, and yellow fever were located in Lake Minara - the lake area with higher density of mosquitoes and therefore vector-borne disease. The majority of confirmed cholera and typhoid fever cases were in Feveria Central, where there are water and sanitation issues.\nThe data suggests that vector-borne disease (dengue and malaria) are a particular concern in this tropical country. However, we don’t know for sure which is the most common disease and what the underlying patterns are - only five diseases are notifiable, and typically the reported cases only represent a fraction of true cases in the community.\n\n\n\n\n\n\n\nYou are going to work towards producing this epicurve, over the various tasks below.\n\n\n\n\n\n\n\n\n\n\n\nMake sure you specify the argument binwidth=7 so that each bar in the histogram represents the number of cases within a 7 day period.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhen was the first case of typhoid fever reported in Feveria in 2024?\n\n January 2024 May 2024 October 2024\n\nAccording to this graph, what was the highest number of dengue cases reported in a single week in 2024?\n\n 10 20 30 It's very hard to tell from this stacked graph!\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is some simple code to produce the epicurve. Note that you are not controlling the colors just yet, or specifying what day of the week each 7-day period starts on.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = disease_notified)), binwidth=7)\n\n\n\n\n\n\n\n\nRefer to the dates chapter in the Epi R Handbook if you want more specific date formatting, for instance so that each bar represents a Monday-Sunday week, or the x axis labels the week number (weeks 1 - 52).\nImportantly - it is not straight forward to see the trends per disease when stacked this way! To see such temporal trends, you should produce one histogram per disease.\n\n\n\n\n\n\nUse facet_wrap() to easily create several mini-plots, one per disease. To understand this further, you can look at the facet section of the ggplot2 chapter in the Epi R Handbook\n\n\n\n\n\n\nQuestions\n\n\n\n\nAccording to this faceted graph, what was the highest number of dengue cases reported in a single week in 2024?\n\n 11 15 29 I still can't tell!\n\nAmong the dengue cases reported that week, what districts did they live in?\n\n All three districts Feveria Central Kasara Lake Minara This graph does not show this information\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nNow you can see an epicurve per disease! And you can see that during one week in July, 15 cases of dengue were reported. However, this graph does not show any geographical information yet.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report)), binwidth=7) + \n  facet_wrap(.~disease_notified)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nAmong the 15 dengue cases reported in one week in July 2024, what districts did they live in?\n\n All three districts Feveria Central Kasara Lake Minara\n\nIn what district was the first typhoid fever case reported in 2024?\n\n Kasara Feveria Central Lake Minara I still can't tell!\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nNow you can see an epicurve per disease, with the coloring reflecting the district the case is a resident of.\nYou can see that among the 15 dengue cases reported in a single week, they lived across the three different districts. You can also see that the first case of typhoid was reported in Feveria Central.\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) + \n  facet_wrap(.~disease_notified)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can specify:\n\nThe theme/appearance of the overall graph (e.g. background color, appearance of grid lines)\nThe title and labels\nThe colors of the bars (with scale_fill_manual())\nThe formatting and spacing of dates along the x-axis (with scale_x_date)\nMany other things!\n\n\n\n\n\n\n\nQuestions\n\n\n\n\nDo cholera and typhoid fever appear endemic?\n\n No - the data suggests smaller occasional outbreaks Yes they are both endemic\n\nIs there a particular time of the year when malaria peaked in 2024?\n\n Yes - around November/December time Yes - around July/August (summer) time No, it is consistently high\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere is the fully formatted code. Note some other changes include specifying that we only want two columns of mini-plots within facet_wrap(), and that the date label along the x axis should only show day and month (not year, since all cases are in 2024 anyway).\n\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) +\n  facet_wrap(.~disease_notified, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District of residence\",\n       x = \"Date reported by clinic\",\n       y = \"Count\",\n       subtitle = \"Number of confirmed cholera, dengue, malaria, typhoid fever, and yellow fever cases by week in Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n\n\n\n\n\n\nWe can also see from the epicurve that cholera and typhoid appear to be occurring as isolated outbreaks, rather than showing endemicity. Malaria and dengue however were present in Feveria throughout the year, with malaria more obviously peaking in the summer months.\n\n\n\n\n\n\nThis time, use group_by() and summarize() to produce a table by district showing the earliest and latest report dates.\nYou can adjust your table with a filter() function to create this table for one district at a time.\n\n\n\n\n\n\nQuestions\n\n\n\n\nWhen was the first dengue case reported in Feveria in 2024?\n\n 18th January 2024 17th January 2024 12th February 2024\n\nWhen was the last dengue case reported in Feveria Central in 2024?\n\n 22nd August 2024 18th November 2024 25th December 2024\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nGroup the data by disease and then summarize the first and last date to look at the overall timeline of each disease in Feveria.\n\ndata_linked_confirmed |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            last_reported = max(date_report)) |&gt;\n  ungroup()\n\n# A tibble: 5 × 3\n  disease_notified first_reported last_reported\n  &lt;chr&gt;            &lt;date&gt;         &lt;date&gt;       \n1 cholera          2024-06-03     2024-09-23   \n2 dengue           2024-01-17     2024-11-18   \n3 malaria          2024-01-08     2024-12-25   \n4 typhoid          2024-05-02     2024-11-07   \n5 yellow fever     2024-03-08     2024-08-23   \n\n\nAdd a filter() to the code to look at first and most recent report dates for the district you’re interested in.\n\ndata_linked_confirmed |&gt; \n  filter(residential_district == \"Feveria Central\") |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            recent_reported = max(date_report)) |&gt;\n  ungroup()\n\n# A tibble: 4 × 3\n  disease_notified first_reported recent_reported\n  &lt;chr&gt;            &lt;date&gt;         &lt;date&gt;         \n1 cholera          2024-06-03     2024-09-23     \n2 dengue           2024-01-29     2024-08-22     \n3 malaria          2024-01-29     2024-12-17     \n4 typhoid          2024-05-02     2024-11-07"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#conclusion",
    "href": "pages/multidisease_surveillance.html#conclusion",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Wow! In line with the objectives for this case study, you have done the following:\n\nYou used key R functions to clean, reshape, and link data frames, plus created new columns using logical conditions.\nTo inform the data processing, you conducted data inspections and checks along the way\nYou conducted a thorough descriptive analysis to understand the testing and notification data, before and after linkage. In response to your supervisor’s original four questions, you can say:\n\nHow many suspected cases of the different notifiable diseases were reported in 2024, and which was most common? Malaria was the most common notifiable disease in Feveria in 2024, reported through the notifiable disease surveillance system: There were 533 suspected cases of malaria reported, 273 suspected cases of dengue, 100 yellow fever, 46 cholera, and 35 typhoid.\nWhat percentage of them ended up being confirmed? Almost 80% of notifiable cases reported in 2024 had a laboratory test result by the time the linked dataset was created, with some variation by disease. In total, 56% of notified cases were eventually confirmed, but this ranged from only 23% for typhoid fever (7 confirmed of 31 suspected cases with test results), to 95% for cholera (38 confirmed of 40 suspected cases with rest results). Additionally, the positivity rate was higher for suspected dengue than for suspected malaria (87% vs 41%).\nHow many confirmed cases of different notifiable diseases were reported in 2024, and which was most common? Confirmed cases followed a slightly different trend to suspected cases: the most commonly reported infection was dengue with 186 cases, followed by malaria (174), then cholera (38), yellow fever (33), and typhoid fever (7).\nHow are confirmed cases geographically and temporally distributed in Feveria? Feveria experienced dengue and malaria transmission throughout the year, peaking in the summer, and concentrated in the Lake Minara district. Feveria also experienced small and infrequent outbreaks of diarrhoeal disease, e.g. cholera and typhoid fever, particularly in the urban Feveria Central where there can be issues with water and sanitation.\n\nFinally, you have reflected on how the processes involved in notifiable disease surveillance systems and lab testing, for instance the transfer of data between clinics to labs, can affect data quality and completeness, and therefore your results.\n\nThere is so much more potential ahead. You can explore disease patterns by age or sex, calculate disease rates with population data, and even analyze reporting delays by examining the different dates in your datasets.\nYou have built a strong foundation and are well equipped to take your analysis to the next level. Keep going — exciting discoveries await!\nTo learn more, check out the other case studies or dive into the Epi R Handbook."
  },
  {
    "objectID": "pages/multidisease_surveillance.html#data-cleaning-and-analysis-code",
    "href": "pages/multidisease_surveillance.html#data-cleaning-and-analysis-code",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "See below a script of all data cleaning steps and descriptive analyses. Note how the analyses are combined at the end rather than interspersed in between cleaning steps. This is a tidier way to organize your script.\nFor brevity, the code below does not include all inspections and checks made along the way, but you may decide to create a sections with such checks.\nThe top of your script should also contain information to help the reader understand what the script is for, as well as comments throughout. You will thank yourself later for adding these comments!\n\n\n\n\n\n\nCode to clean and analyse notification data and lab data from Feveria, 2024\n\n\n\n\n\n\n# Code to clean and analyse notification data and lab data from Feveria, 2024\n# Date:\n# Author:\n\n# Install packages -------------------------------------------------\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  flextable,  # Presentation ready tables\n  naniar,     # Evaluating missingness of data\n  remotes,    # Used to install package to download data\n  tidyverse   # data management and visualization\n)\n\n# Import data --------------------------------------------\n\n# Notification data\ndata_notif_raw &lt;- import(\"data/multidisease_notifications.xlsx\")\n\n# Lab data\ndata_lab_raw &lt;- import(\"data/multidisease_tests.csv\")\n\n# Clean notification data --------------------------------\ndata_notif &lt;- data_notif_raw |&gt; \n  clean_names() |&gt; \n  rename(date_report = date_reported_by_health_facility_community) |&gt; \n  select(notification_id, residential_district, disease_notified, date_report) |&gt; \n  mutate(residential_district = case_match(str_to_title(residential_district),\n                                           c(\"F Central\", \"Feveria C\", \"Feveria Central\") ~ \"Feveria Central\",\n                                           c(\"Kasara\", \"Ksr\") ~ \"Kasara\",\n                                           c(\"L Minara\", \"Lake Minara\", \"Lakeside\") ~ \"Lake Minara\")) |&gt; \n  mutate(date_report = ymd(date_report)) \n\n\n# Clean and consolidate lab data  ---------------------------------------\n# Clean values\ndata_lab &lt;- data_lab_raw |&gt; \n  mutate(value = case_match(value, \n                            c(\"P\", \"PO1\", \"PO139\") ~ \"Positive\",\n                            \"N\" ~ \"Negative\",\n                            \"I\" ~ \"Indeterminate\"))\n\n# Create test-level lab data\ndata_lab_tests &lt;- data_lab |&gt; \n  filter(target != \"Dengue IgG\") |&gt; \n  group_by(sample_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Create case-level lab data\ndata_lab_cases &lt;- data_lab_tests |&gt; \n  group_by(notification_id) |&gt; \n  arrange(desc(value)) |&gt; \n  slice(1) |&gt; \n  ungroup()\n\n# Link notification and lab data  ---------------------------------------\ndata_linked &lt;- left_join(data_notif, data_lab_cases, by = \"notification_id\")\n\n# Clean data--------------------------------------------------------------\ndata_linked &lt;- data_linked |&gt; \n  mutate(case_category = case_when(value==\"Positive\" ~ \"Confirmed\",\n                                   value==\"Negative\" ~ \"Discarded\",\n                                   value==\"Indeterminate\" | is.na(value) ~ \"Suspected\"))\n\ndata_linked_confirmed &lt;- data_linked |&gt; \n  filter(case_category==\"Confirmed\")\n\n# ANALYSIS ---------------------------------------------------------\n# Number of suspected cases in Feveria\ntabyl(data_notif, disease_notified)\n\n# Distribution of suspected cases by district\ntabyl(data_notif, disease_notified, residential_district) |&gt;\n  adorn_percentages() |&gt;\n  adorn_pct_formatting() |&gt;\n  adorn_ns()\n\n# Distribution of results per disease-specific test\ntabyl(data_lab_tests, test, value) |&gt; \n    adorn_totals(where = \"col\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of case category, in linked data: all cases\ntabyl(data_linked, case_category) \n\n# Distribution of case category by diseases, in linked data: all cases\ntabyl(data_linked, disease_notified, case_category) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of case category by disease, in linked data: only cases with a valid result\ndata_linked |&gt; \n    filter(case_category != \"Suspected\") |&gt; \n    tabyl(disease_notified, case_category) |&gt; \n    adorn_totals(where = \"both\") |&gt; \n    adorn_percentages() |&gt; \n    adorn_pct_formatting() |&gt; \n    adorn_ns()\n\n# Distribution of confirmed cases by district\ndata_linked_confirmed |&gt; \n  tabyl(disease_notified, residential_district) |&gt; \n  adorn_totals(where = \"both\") |&gt; \n  adorn_percentages() |&gt; \n  adorn_pct_formatting() |&gt; \n  adorn_ns() \n\n\n# Visualize confirmed cases over time\ndata_linked_confirmed |&gt; \n  ggplot()+\n  geom_histogram((aes(x = date_report, fill = residential_district)), binwidth=7) +\n  facet_wrap(.~disease_notified, ncol=2) +\n  theme_minimal() + \n  labs(fill = \"District of residence\",\n       x = \"Date reported by clinic\",\n       y = \"Count\",\n       subtitle = \"Number of confirmed cholera, dengue, malaria, typhoid fever, and yellow fever cases by week in Feveria, 2024\") +\n  scale_fill_manual(values = c(\"navy\", \"lightblue\", \"seagreen\")) +\n  scale_x_date(date_breaks = \"1 month\", \n               date_labels = \"%d %b\") +\n  theme(legend.position=\"bottom\",\n        axis.text.x = element_text(angle=90)) \n\n\n# First and last report date per disease\ndata_linked_confirmed |&gt; \n  group_by(disease_notified) |&gt; \n  summarize(first_reported = min(date_report), \n            last_reported = max(date_report)) |&gt;\n  ungroup()"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#case-study-information",
    "href": "pages/multidisease_surveillance.html#case-study-information",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Original authors: Paula Blomquist and Alanah Jansen, with technical support provided by the CDC Global Surveillance, Laboratory, and Data Systems Branch in collaboration with TEPHINET.\nData source: Fictional data provided by Applied Epi.\nEstimated duration: 4 hours\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nChanges made\nVersion\nAuthor\n\n\n\n\nJuly 2025\nFirst draft\n1\nPaula Blomquist and Alanah Jansen, Applied Epi, with technical support by the CDC Global Surveillance, Laboratory, and Data Systems Branch in collaboration with TEPHINET"
  },
  {
    "objectID": "pages/multidisease_surveillance.html#terms-of-use",
    "href": "pages/multidisease_surveillance.html#terms-of-use",
    "title": "Linking and analysing notification data and laboratory data in R",
    "section": "",
    "text": "Disclaimer: The information presented in this exercise and the associated data files have been developed to help learners achieve the intended learning objectives. The contents are those of the author(s) and do not necessarily represent the official views of CDC, the US Department of Health and Human Services, or TEPHINET.\nLicense: This case study is under a CC BY-NC-SA 4.0 license. For more information about sharing and adapting this case study, see the associated deed.\nFunding: This case study was 100% supported by Cooperative Agreement number NU2HGH000044 funded by the US Centers for Disease Control and Prevention (CDC)."
  },
  {
    "objectID": "pages/instructions.html",
    "href": "pages/instructions.html",
    "title": "How-to Guide",
    "section": "",
    "text": "Choose a case study that fits your training needs based on topic, complexity, and language—details are available on the homepage and at the top of each case study page.\nYou can complete the case study individually or in a group. If facilitating, guide the group through the sections. There’s no facilitator’s guide; all learning materials are on the case study page, including the scenario, data download, tasks, and interactive hints and solutions.\n\n\n\nAside from opening up the case study, you need to:\n\nHave the relevant program on your computer, like R or Microsoft Excel.\nOrganize yourself and put any related files in a project folder.\n\nFor projects using R, see more detail in the ‘New to RStudio Projects’? section below.\n\n\n\nThere are several ways to get help:\n\nLook for the hints and solutions. They look like this:\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nHere you will see a helpful hint!\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere you will see the solution! It will typically be the actual code or technical answer required for the task.\n\n# Example of a solution\n\nebola_linelist %&gt;% \n  filter(\n    age &gt; 25,\n    district == \"Bolo\"\n  )\n\n\n\n\n\nTake a look at the EpiRHandbook\nPost a question in Applied Epi Community with reference to this case study\n\n\n\n\nWe encourage open-source material and sharing for learning purposes. However, case studies will be covered by different licenses. Check the terms of use at the bottom of each case study to see if it is suitable for modification. If you have any questions, send us an email at contact@appliedepi.org.\n\n\n\nAll case studies are based on real or plausible scenarios. Some will use simulated data, while others will feature open-access or provided de-identified data. The type of data used will be clearly indicated at the start of each case study.\n\n\n\nWe recommend that you create an RStudio Project when working R. Check out the details below.\n\n\nIf this is your first time using R and RStudio, welcome! The Epidemiologist R Handbook or EpiRhandbook has a wealth of information to support you along the way. It has everything thing you need to get started with R basics, including installing and updating R and RStudio.\nIf you are new to RStudio, it might be a good idea to spend some time reviewing that page and others before trying out any case studies. Don’t forget that we also have free self-paced R tutorials if you’d like even more guidance and practice.\n\n\n\nOnce you are ready to start your case study project itself, choose a location on your computer to create a dedicated folder. Once you’ve decided on the best spot, set up a folder with the case study’s name to keep everything organized from the start.\nIn your case study folder, you should have a:\n\nsubfolder “scripts” to save any scripts related to the analysis\nsubfolder “data” which will contain the raw data you will use\nsubfolder “outputs” can be used to store any outputs (tables, graphs, documents) that are the result of the analysis\n\nMake sure your folders and subfolders are well-organised as this will save you a headache later!\n\n\n\nCreate an Rstudio project in the case study folder. If you are unsure on how to do that, read the EpiRhandbook on RStudio projects.\n\n\n\nOnce you have created an RStudio project, start a new R script with an appropriate name (example case_study_name) and save it in the subfolder “scripts”.\nIf you are familiar with R markdown, you may decide to use this type of file instead of a standard R script. See below for more instructions on using R markdown.\nNo matter what type of file you choose to use, make sure the purpose, date last updated, and author are written as comments at the top.\n\n#Purpose: To practice new skills using this case study\n#Author: Your Name\n#Date: Mmm dd, yyyy or whatever format you like best\n\n\n\n\nSome of our case studies use R markdown and the code goes within “chunks”, which is different from a standard R script. If you want to create a reproducible workflow, you need a place to save your code so you can run it again if you need to. You want all your files easily organised so you don’t get lost later on. You need to begin by setting the default chunk options.\nTypically, you want to change the default chunk options of your R markdown script to:\n\nhide all code chunks in the report\nnot show messages or warnings in the output\nshow errors if they appear, but to not stop the rendering\nset up the default figure width to 7 and the figure height to 6\nshow the figure titles on top of the plots by default\n\n\n# hide all code chunks in the output, but show errors \nknitr::opts_chunk$set(echo = FALSE,  # hide all code chunks in output\n                      error = TRUE,  # show errors if they appear, but don't stop (produce the word doc)\n                      warning = FALSE, # do not show warnings in the output word doc \n                      message = FALSE, # do not show  messages in the output word doc\n                      fig.width = 7,         # Figure width\n                      fig.height = 6,        # Figure height\n                      fig.topcaption = TRUE  # show figure titles on top of plot\n                     )\n\nBe sure to review Reports with R Markdown in the EpiRhandbook before jumping in!\n\n\n\nDepending on where you are and how you carried out R installation, your language “locale” might be different from the language of the report that you want to produce.\nFor example, a French-speaking person might have a French ‘locale’. If that is the case, when creating a graph by day of the week, “Monday” will be displayed as “lundi”. If that person wants to create an English report, as for this case study, the language ‘locale’ should be changed.\nTo ensure your ‘locale’ is set to English, use the following code:\n\n# To see your language locale\nSys.getlocale()\n\n# To change it into English\nSys.setlocale(\"LC_ALL\", \"English\")\n\n\n\n\nAt the start of every R project, you will need to install the necessary packages. We do this with the {pacman} package. Its p_load() command will install packages if necessary and load them for use in the current session. If a listed package has already been installed, it will just load it. Each case study specifies at the beginning what packages you need to have installed.\nYou can find more about installing/loading packages in the suggested packages section of the EpiRhandbook.\nExample code to install packages:\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  tidyverse  # data management and visualization\n)\n\nIf this step is not working, you may have limited administrative rights for your computer. Making sure your IT-department gives you the correct access can save a lot of headache. See these EpiRhandbook pages on the basics of installing packages and running R from network drives (company computers) for more detail."
  },
  {
    "objectID": "pages/instructions.html#how-should-i-use-these-case-studies",
    "href": "pages/instructions.html#how-should-i-use-these-case-studies",
    "title": "How-to Guide",
    "section": "",
    "text": "Choose a case study that fits your training needs based on topic, complexity, and language—details are available on the homepage and at the top of each case study page.\nYou can complete the case study individually or in a group. If facilitating, guide the group through the sections. There’s no facilitator’s guide; all learning materials are on the case study page, including the scenario, data download, tasks, and interactive hints and solutions."
  },
  {
    "objectID": "pages/instructions.html#what-do-i-need-to-complete-a-case-study",
    "href": "pages/instructions.html#what-do-i-need-to-complete-a-case-study",
    "title": "How-to Guide",
    "section": "",
    "text": "Aside from opening up the case study, you need to:\n\nHave the relevant program on your computer, like R or Microsoft Excel.\nOrganize yourself and put any related files in a project folder.\n\nFor projects using R, see more detail in the ‘New to RStudio Projects’? section below."
  },
  {
    "objectID": "pages/instructions.html#how-can-i-get-help",
    "href": "pages/instructions.html#how-can-i-get-help",
    "title": "How-to Guide",
    "section": "",
    "text": "There are several ways to get help:\n\nLook for the hints and solutions. They look like this:\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nHere you will see a helpful hint!\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere you will see the solution! It will typically be the actual code or technical answer required for the task.\n\n# Example of a solution\n\nebola_linelist %&gt;% \n  filter(\n    age &gt; 25,\n    district == \"Bolo\"\n  )\n\n\n\n\n\nTake a look at the EpiRHandbook\nPost a question in Applied Epi Community with reference to this case study"
  },
  {
    "objectID": "pages/instructions.html#can-i-edit-this-case-study",
    "href": "pages/instructions.html#can-i-edit-this-case-study",
    "title": "How-to Guide",
    "section": "",
    "text": "We encourage open-source material and sharing for learning purposes. However, case studies will be covered by different licenses. Check the terms of use at the bottom of each case study to see if it is suitable for modification. If you have any questions, send us an email at contact@appliedepi.org."
  },
  {
    "objectID": "pages/instructions.html#where-do-the-case-studies-come-from",
    "href": "pages/instructions.html#where-do-the-case-studies-come-from",
    "title": "How-to Guide",
    "section": "",
    "text": "All case studies are based on real or plausible scenarios. Some will use simulated data, while others will feature open-access or provided de-identified data. The type of data used will be clearly indicated at the start of each case study."
  },
  {
    "objectID": "pages/instructions.html#new-to-rstudio-and-rstudio-projects",
    "href": "pages/instructions.html#new-to-rstudio-and-rstudio-projects",
    "title": "How-to Guide",
    "section": "",
    "text": "We recommend that you create an RStudio Project when working R. Check out the details below.\n\n\nIf this is your first time using R and RStudio, welcome! The Epidemiologist R Handbook or EpiRhandbook has a wealth of information to support you along the way. It has everything thing you need to get started with R basics, including installing and updating R and RStudio.\nIf you are new to RStudio, it might be a good idea to spend some time reviewing that page and others before trying out any case studies. Don’t forget that we also have free self-paced R tutorials if you’d like even more guidance and practice.\n\n\n\nOnce you are ready to start your case study project itself, choose a location on your computer to create a dedicated folder. Once you’ve decided on the best spot, set up a folder with the case study’s name to keep everything organized from the start.\nIn your case study folder, you should have a:\n\nsubfolder “scripts” to save any scripts related to the analysis\nsubfolder “data” which will contain the raw data you will use\nsubfolder “outputs” can be used to store any outputs (tables, graphs, documents) that are the result of the analysis\n\nMake sure your folders and subfolders are well-organised as this will save you a headache later!\n\n\n\nCreate an Rstudio project in the case study folder. If you are unsure on how to do that, read the EpiRhandbook on RStudio projects.\n\n\n\nOnce you have created an RStudio project, start a new R script with an appropriate name (example case_study_name) and save it in the subfolder “scripts”.\nIf you are familiar with R markdown, you may decide to use this type of file instead of a standard R script. See below for more instructions on using R markdown.\nNo matter what type of file you choose to use, make sure the purpose, date last updated, and author are written as comments at the top.\n\n#Purpose: To practice new skills using this case study\n#Author: Your Name\n#Date: Mmm dd, yyyy or whatever format you like best\n\n\n\n\nSome of our case studies use R markdown and the code goes within “chunks”, which is different from a standard R script. If you want to create a reproducible workflow, you need a place to save your code so you can run it again if you need to. You want all your files easily organised so you don’t get lost later on. You need to begin by setting the default chunk options.\nTypically, you want to change the default chunk options of your R markdown script to:\n\nhide all code chunks in the report\nnot show messages or warnings in the output\nshow errors if they appear, but to not stop the rendering\nset up the default figure width to 7 and the figure height to 6\nshow the figure titles on top of the plots by default\n\n\n# hide all code chunks in the output, but show errors \nknitr::opts_chunk$set(echo = FALSE,  # hide all code chunks in output\n                      error = TRUE,  # show errors if they appear, but don't stop (produce the word doc)\n                      warning = FALSE, # do not show warnings in the output word doc \n                      message = FALSE, # do not show  messages in the output word doc\n                      fig.width = 7,         # Figure width\n                      fig.height = 6,        # Figure height\n                      fig.topcaption = TRUE  # show figure titles on top of plot\n                     )\n\nBe sure to review Reports with R Markdown in the EpiRhandbook before jumping in!\n\n\n\nDepending on where you are and how you carried out R installation, your language “locale” might be different from the language of the report that you want to produce.\nFor example, a French-speaking person might have a French ‘locale’. If that is the case, when creating a graph by day of the week, “Monday” will be displayed as “lundi”. If that person wants to create an English report, as for this case study, the language ‘locale’ should be changed.\nTo ensure your ‘locale’ is set to English, use the following code:\n\n# To see your language locale\nSys.getlocale()\n\n# To change it into English\nSys.setlocale(\"LC_ALL\", \"English\")\n\n\n\n\nAt the start of every R project, you will need to install the necessary packages. We do this with the {pacman} package. Its p_load() command will install packages if necessary and load them for use in the current session. If a listed package has already been installed, it will just load it. Each case study specifies at the beginning what packages you need to have installed.\nYou can find more about installing/loading packages in the suggested packages section of the EpiRhandbook.\nExample code to install packages:\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  tidyverse  # data management and visualization\n)\n\nIf this step is not working, you may have limited administrative rights for your computer. Making sure your IT-department gives you the correct access can save a lot of headache. See these EpiRhandbook pages on the basics of installing packages and running R from network drives (company computers) for more detail."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Applied Epi Open Case Study Repository",
    "section": "",
    "text": "A case study is a fun, interactive way to learn—guiding you through real-life scenarios with tasks and questions. You’ll find a variety of topics, skill levels, and diseases below, most of which take just a few hours to complete. You can filter and order the rows to pick the one that fits you best. Click the link corresponding to your preferred language to open it up. The data used in the case studies is either generated or anonymized.\nFor more information on how to use the case studies, click the How-to Guide."
  },
  {
    "objectID": "index.html#welcome-to-our-open-case-study-repository",
    "href": "index.html#welcome-to-our-open-case-study-repository",
    "title": "Applied Epi Open Case Study Repository",
    "section": "",
    "text": "A case study is a fun, interactive way to learn—guiding you through real-life scenarios with tasks and questions. You’ll find a variety of topics, skill levels, and diseases below, most of which take just a few hours to complete. You can filter and order the rows to pick the one that fits you best. Click the link corresponding to your preferred language to open it up. The data used in the case studies is either generated or anonymized.\nFor more information on how to use the case studies, click the How-to Guide."
  },
  {
    "objectID": "index.html#about-us",
    "href": "index.html#about-us",
    "title": "Applied Epi Open Case Study Repository",
    "section": "About us",
    "text": "About us\nApplied Epi is a nonprofit organisation and grassroots movement of frontline epidemiologists from around the world. Your encouragement and feedback is most welcome:\n\nVisit our website and join our contact list\ncontact@appliedepi.org, tweet @appliedepi, or LinkedIn\nSubmit issues to our Github repository"
  },
  {
    "objectID": "index.es.html",
    "href": "index.es.html",
    "title": "Estudios de caso Repositorio abierto",
    "section": "",
    "text": "Objetivo En este repositorio puede ayudarle a desarrollar su epidemiología a través de estudios de casos que cubren situaciones y métodos epidemiológicos comunes.\nEscrito por epidemiólogos, para epidemiólogos\nEpidemiología aplicada es una organización sin ánimo de lucro y un movimiento de base de epis de primera línea de todo el mundo. Escribimos en nuestro tiempo libre para ofrecer este recurso a la comunidad. Su aliento y sus comentarios son muy bienvenidos:\n\nVisite nuestra página web y únase a nuestra lista de contactos\ncontact@appliedepi.org tuitear @appliedepi o LinkedIn\nEnvíe temas a nuestro repositorio Github"
  },
  {
    "objectID": "index.es.html#autores",
    "href": "index.es.html#autores",
    "title": "Estudios de caso Repositorio abierto",
    "section": "Autores",
    "text": "Autores"
  },
  {
    "objectID": "pages/r_practical.html",
    "href": "pages/r_practical.html",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Tool: R Technical complexity: Basic Methodological complexity: Basic\nPrior knowledge required: R basics (Using Rstudio; R packages, functions and arguments, using pipes)\nSource: European Centre for Disease Prevention and Control Epidemic Intelligence Group (simulated data)\nEstimated duration: 2 hours\n\n\n\nFor instructions on how to use our case studies, see our How-to Guide. We welcome feedback and suggestions via contact@appliedepi.org. You can also discuss the case study or related concepts on the Applied Epi Community.\n\n\n\nIt is May 2022 and Mpox has just been reported for the first time across 5 countries in Europe: Countries “A”, “B”, “C”, “D”, and “E”. You have been requested to provide a basic descriptive analysis to the European Centre for Disease Prevention and Control (ECDC).\nYou are given access to:\n\nA dataset with aggregate case counts, submitted to ECDC by the five countries as part of routine European reporting\nA linelist with cases, submitted by the five countries to ECDC for this particular analysis\n\nLet’s go!\n\n\n\nIn this case study you will:\n\nExplore different types of files and how they can be imported in R.\nPerform basic data cleaning, e.g., changing the variable type, recoding variables, aggregating and filtering.\nPerform a basic descriptive analysis using tables and graphs\n\n\n\n\n\n\nStart by setting up a reproducible and well-organized workflow. This will make it easy to rerun your analysis whenever needed.\nTasks:\n\nSet up an RStudio project\nSet up clear sub-folders where your code, data, and outputs will go\nCreate an R script, or an R Markdown file if you prefer. Make sure the script purpose, date, and author are written as comments at the top.\nExtra: Ensure your working language in RStudio is appropriate (e.g. English for this exercise)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\n\nCreate a folder where all the work in this case study will go. For example, create ‘mpox_analysis’ on your computer desktop. Create your RStudio project to be based in this folder.\nWe suggest creating the following sub-folders: scripts (for your code), data (for your data), and outputs (for your analytical outputs).\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a folder (e.g. ‘mpox_analysis’ on your Desktop) for your work. To create an Rstudio project in your new folder, click New Project… in the top left of your R Studio, then Existing Directory, then Browse to select your new folder. For more information, look at the R projects section of the Epi R Handbook.\nStart a new R script by clicking New File… in the top left of your R Studio, then R Script. Save it immediately in the appropriate place, e.g. in a ‘scripts’ subfolder of your R Project.\nAt the top of your new R script, write some essential information like your name, the purpose of the file, and the date.\nYour R locale determines the language and regional settings used for things like date formats and translations. If your locale is different from the language you want for your report (e.g., a French locale vs. an English report), you can change it to English by running Sys.setlocale(\"LC_ALL\", \"English\"). Include this in your script if needed, or skip it if your locale is usually appropriate. This is explained in more detail in the How-to Guide.\n\n\n\n\n\n\nNext in your R script, you need to install and load the necessary R packages. This ensures that the functions you need are available for your analysis.\nYou will need the following packages: rio (for importing data), janitor (for cleaning data), lubridate (for cleaning dates), skimr (for reviewing data), epikit (for epi-related tasks), gtsummary (for presentation-ready tables), apyramid (for age-sex pyramids), and tidyverse (for general data manipulation/science tasks).\nAs you start, your trusted colleague nudges you and whispers “I’ve heard that a great way to manage your packages is with the pacman package”.\nOver to you!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the function p_load() from pacman for this task. You provide the function with a list of packages that you want to use. It will take two steps per package: 1) Check if the package is installed on your computer, and install it if necessary, then 2) Load the package so it can be used during this R session.\nIf you don’t already have pacman installed, you will need to install it the “traditional way” first, with install.packages().\nNote that the order of packages in your p_load function can be important. If two packages have the same function names (e.g. select() in the package MASS and select() in tidyverse, which do different things), then R will use the function from the most recently loaded package. To prioritize functions from tidyverse, which are commonly used for data manipulation and visualization, load tidyverse last.\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  tidyverse  # data management and visualization\n)\n\n\n\n\n\n\n\n\n\n\nECDC provides you with two files for your analysis, both updated as of 31st August 2022:\n\nA case-level linelist (“mpox_linelist.xlsx”) with case information from five countries (countries A - E)\nAn aggregate table (“mpox_aggregate_table.csv”) for those countries with cumulative case counts per day.\n\nThey provide it to you via AppliedEpi’s very useful data repository, which you can access using the {appliedepidata} package. So first you need to download these two files to your own computer, as follows:\n\nInstall the {appliedepidata} package from GitHub using the install_github() function in the {remotes} package. Install {remotes} if you need to first.\n\n\n# Install remotes if you need to (so you can install a package from GitHub)\npacman::p_load(\"remotes\")\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSave the two datasets into a specific folder using the save_data() function from {appliedepidata}, by running the code below. The example below saves the data into a data subfolder within the RStudio project. Note that if you do not specify a location within the path argument of the function, a window will pop up asking you to manually select a folder.\n\n\n# Save down the two mpox files using the save_data() function from appliedepidata\nappliedepidata::save_data(\"mpox_linelist\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"mpox_aggregate_table\",\n                          path = \"data\")\n\n\n\n\nGreat! Thanks ECDC and Applied Epi! Now it’s time to import the data from that folder into RStudio, so you can analyse it.\nTask: Import the downloaded case-based and aggregated data into your R environment. Ideally you want to use one function for both datasets, despite one being a csv and the other an xlsx file.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nUse the import function from the {rio} package, which can recognize and import different file types. It replaces importing functions that are specific to the file type, such as read.csv() from {base} for .csv files and read_excel() from {readxl} to import .xlsx files.\nIf you feel you need to know more about importing functions, read the Import and export chapter of the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nBelow we use the import function to bring in both files. Note how we are assigning the imported data to two objects, one called mpox_linelist_raw, and one called mpox_agg_raw. We add the ‘raw’ suffix to distinguish this data from the cleaned versions we will make later.\n\n# Import data  --------------\n\n# Case-based data\nmpox_linelist_raw &lt;- import(\"data/mpox_linelist.xlsx\")\n\n# Aggregated data\nmpox_agg_raw &lt;- import(\"data/mpox_aggregate_table.csv\")\n\n\n\n\n\n\n\n\nThe data’s in, and now it’s time to see what story it tells. Take an initial look at your data to check its quality and how you can best use it.\nTasks: Take a look at the different data frames and determine:\n\nThe number of columns and observations (e.g. their dimensions)\nThe class of their columns and whether it matches its nature (e.g., are “dates” considered “dates” by R?)\nIf the contents of columns are clean and standardized in the mpox linelist (e.g. gender, clinical symptoms, outcome, hiv status and sexual orientation). Do you need to recode any of them?\nHow unknown or missing data is categorized in these columns. Do these values need to be standardized?\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nAn efficient function for initial data exploring is skim() from the {skimr} package, as it gives you a lot of information on data structure and content, including the classes of columns.\nYou can use the function tabyl() from {janitor}, to get counts and percentages of every category in the data column, one by one. These get printed to your RStudio console.\nAlso - we recommend just looking at the data itself! A good function for this is view(), a baseR function.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing the skim commands you can see the rows and columns of each dataset, and you can see how most of the columns in mpox_linelist_raw (including those containing dates) are character classes. (Results not shown on this exercise page)\n\n# Explore the dimensions of the two data objects \nskim(mpox_linelist_raw)\nskim(mpox_agg_raw)\n\nTake a look at the overall data using view(). It will pop up in the Data Viewer tab and you will get a good sense of how clean the data is and what the missingness is like. This preview shows just 5 rows from the linelist data.\n\nview(mpox_linelist_raw)\n\n\n\n\n\n\n\nBelow is an example of using the tabyl() function from {janitor}, to look at the distribution of clinical symptoms. You can see 12 cases have missing clinical information and that many cases have a mix of symptoms.\n\ntabyl(mpox_linelist_raw, ClinicalSymptoms)  \n\n                 ClinicalSymptoms   n percent valid_percent\n                          Lesions  14  0.0070   0.007042254\n                             Rash 257  0.1285   0.129275654\n                    Rash, Lesions 323  0.1615   0.162474849\n          Rash, Systemic symptoms 676  0.3380   0.340040241\n Rash, Systemic symptoms, Lesions 654  0.3270   0.328973843\n                Systemic symptoms  28  0.0140   0.014084507\n       Systemic symptoms, Lesions  36  0.0180   0.018108652\n                             &lt;NA&gt;  12  0.0060            NA\n\n\nYou can explore further columns one by one (results not shown):\n\n# Explore the values of different categorical columns in the mpox linelist: with tabyl\ntabyl(mpox_linelist_raw, Gender)\n\ntabyl(mpox_linelist_raw, HIVStatus)\n\ntabyl(mpox_linelist_raw, Outcome)\n\ntabyl(mpox_linelist_raw, SexualOrientation)\n\nYou could add extra arguments to tabyl() to customize the tables, such as adding totals and changing the proportions to percentages so they are easier to read. See the table on clinical symptoms below. But remember - this is just an initial look so don’t go too crazy.\n\ntabyl(mpox_linelist_raw, ClinicalSymptoms) %&gt;%    # Tabulate symptoms \n  adorn_totals() %&gt;%                              # Add totals to bottom of table\n  adorn_pct_formatting(digits = 2)                # Format percentages\n\n                 ClinicalSymptoms    n percent valid_percent\n                          Lesions   14   0.70%         0.70%\n                             Rash  257  12.85%        12.93%\n                    Rash, Lesions  323  16.15%        16.25%\n          Rash, Systemic symptoms  676  33.80%        34.00%\n Rash, Systemic symptoms, Lesions  654  32.70%        32.90%\n                Systemic symptoms   28   1.40%         1.41%\n       Systemic symptoms, Lesions   36   1.80%         1.81%\n                             &lt;NA&gt;   12   0.60%             -\n                            Total 2000 100.00%       100.00%\n\n\nFinally, as an alternative approach to tabyl(), you could use tbl_summary() from the {gtsummary} package. We will describe this later.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nHow many columns does the aggregated data have?\n\n 2000 13 3 101\n\n\n\nWhat is the class of the column DateOfNotification in the mpox linelist?\n\n Date Character Numeric Factor\n\n\n\nFor how many cases is the HIV status unknown or missing?\n\n 1168 722 900 446\n\n\n\n\n\n\n\n\n\n\nSo! The good news: you have information on geography, dates, demographic characteristics, and clinical details. A promising descriptive analysis lies ahead.\nBUT! You may noticed that there are a few things to fix before the real detective work begins.\nFor example:\n\nColumn names have capital letters. This isn’t outright a problem, but can lead to mistakes since R treats ColumnName and Columnname as different.\nDate columns are recognized as character classes, not dates, which would cause issues like incorrect ordering (alphabetical) in epicurves.\nSome columns have values that are unclear or unsuitable for presentation. For example gender is categorized with “F”, “M”, “O” and “UNK”. The column Outcome is “A” and “UNK”.\nMissing data is inconsistently handled, for instance with both “UNK” and NA in the HIV status column. R thinks “UNK” is a valid value, which it treats differently to true missing data (indicated by NA)\n\nTasks:\n\nCreate a clean version of your case-based data making all cleaning changes in a single piping command\nChange all column names to lower case.\nConvert all date columns to class “Date”.\nConvert all missing/unknown values to NA (to be recognized by R as missing)\nRecode non-missing “Gender” categories into: “Female”, “Male”, and “Other”\nRecode non-misising HIV status into: “Positive”, “Negative” and “Unknown”\nRecode non-missing sexual orientation into: “Bisexual”, “Heterosexual”, and “MSM/homo or bisexual male”.\nRecode non-missing “outcome” categories into: “Alive” and “Dead”.\nCheck that all changes have been made correctly\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo convert all column names to lower case at once rather than renaming each column, use the function clean_names() from the {janitor} package.\nUse {lubridate} functions to transform date columns into “Date” class. You can do this one by one, or you could do all at the same time using the across() function from {dplyr}. If you feel you need to know more about transforming dates read the chapter Working with Dates from the Epi R Handbook. If you are not sure how to use the across() function, you can also read the section on Transform multiple columns.\nThere are different functions that we can use to recode values. We propose three: The function recode() from {dplyr}, the function ifelse() from {base} and the function case_when() from {dplyr}. If you want to know more about these functions, look that the section on Re-code values from the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere we clean the data using a ‘chain’ of commands connected by pipes (%&gt;%), which is the grammar of the functions in the {Tidyverse}. The output is assigned to a new object called mpox_linelist to differentiate it from the raw data. It can be helpful to have both the cleaned and raw data available in the environment to compare to the original data if needed.\nSee the series of functions and the explanation in the comments.\n\n# Create a new object called mpox_linelist which is the clean version of the raw data\nmpox_linelist &lt;- mpox_linelist_raw %&gt;% \n  \n  # standardises names and puts all into lower case \n  clean_names() %&gt;% \n  \n  #transform ONE column into date (note the column names are lower case now)\n  mutate(date_of_notification = ymd(date_of_notification)) %&gt;%  \n\n  #transforms ALL columns starting with \"date\" into dates\n  mutate(across(starts_with(\"date\"), \n                .fns = ~ ymd(.x))) %&gt;%  \n  \n  #transforms UNK to NA across all character columns \n  mutate(across(where(is.character), \n                .fns = ~ ifelse(.x %in% c(\"UNK\", \"Unknown\"), NA_character_, .x)))  %&gt;% \n\n  # Recode the gender values to be more obvious  \n  mutate(gender = recode(gender,\n                         \"F\" = \"Female\",\n                         \"M\" = \"Male\",\n                         \"O\" = \"Other\")) %&gt;%\n  \n  #recode with ifelse to change only one or two categories based on a rule. \n  mutate(outcome = ifelse(outcome == \"A\", \"Alive\", outcome)) %&gt;%   \n  \n  #recode with case_when for more complex recoding \n  mutate(hiv_status = case_when(hiv_status == \"NEG\" ~ \"Negative\",    \n                                hiv_status == \"POS\" ~ \"Positive\")) %&gt;% \n  \n  mutate(sexual_orientation = case_when(sexual_orientation == \"BISEXUAL\" ~ \"Bisexual\",\n                                        sexual_orientation == \"HETERO\" ~ \"Heterosexual\",\n                                        sexual_orientation == \"MSM\" ~ \"MSM/homo or bisexual male\")) \n\nYou can then review your data by tabulating across all the different columns you have cleaned. See the preview of the hiv_status table below - it looks tidier now with more understandable categories, and all missing data is classified as ‘unknown’.\n\n# Check that all changes have been made correctly\n\nskim(mpox_linelist)\n\ntabyl(mpox_linelist, gender)\n\ntabyl(mpox_linelist, clinical_symptoms)\n\ntabyl(mpox_linelist, outcome)\n\ntabyl(mpox_linelist, hiv_status)\n\ntabyl(mpox_linelist, sexual_orientation)\n\n\n\n hiv_status    n percent valid_percent\n   Negative  525  0.2625     0.6310096\n   Positive  307  0.1535     0.3689904\n       &lt;NA&gt; 1168  0.5840            NA\n\n\nIMPORTANT: If ‘unknown’ and NA had meaningful differences, combining them wouldn’t be appropriate (e.g., if ‘unknown’ meant the case was asked but didn’t want to respond, while NA meant they weren’t asked). Here, we assume no meaningful difference and want R to recognize them as missing.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nIs it always appropriate to combine different types of unknown data? (e.g. missing, unknown, did not respond, NA)\n\n Yes Depends on the meaning of those values No - never do this\n\n\n\nHow many male cases do we have in the data frame?\n\n 36 1960 65 1523\n\n\n\nHow many cases have ‘alive’ as an outcome?\n\n 1405 0 595\n\n\n\n\n\n\n\n\nIn a similar way, clean the aggregated data by:\n\nStandardising names to lower case\nEnsuring that date of reporting is of class “Date”\nCreating a column called “week_date” with the week of reporting starting on Monday\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nWe can first check the class of the DateRep column, which shows us that it was already recognized as a date column on import.\n\n# Check class of date of reporting column\nclass(mpox_agg_raw$DateRep)\n\nThen create a new object for the clean aggregate data, and write your cleaning coded connected with pipes.\n\n# Create a new object called mpox_agg which is the clean version of the raw data, applying the cleaning functions\n\nmpox_agg &lt;- mpox_agg_raw %&gt;% \n  \n  # standardises names and puts all into lower case\n  clean_names() %&gt;%  \n  \n  # create week column with Monday start\n  mutate(week_date = floor_date(date_rep, \n                              unit = \"week\",\n                              week_start = \"Monday\")) \n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nTake a look at the aggreate data. Which country reported the largest cumulative number of cases during the week 2022-04-11?\n\n Country A Country B Country C Country D Country E\n\n\n\n\n\n\n\n\n\nNow we’re getting to the heart of the investigation. Who is affected? Which locations are most affected, and how quickly is it spreading? Your ability to tell the classic “person, place, and time” story will be crucial to guiding the response. Pinpoint those hotspots and trends!\n\n\nTask: Using the mpox case linelist, create a table showing the total number of cases by country. This time, make the table more publication-friendly.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nYou could use tabyl() like before, but an easy way to produce publication-ready tables is with the function tbl_summary() from {gtsummary} package. This formats the table for you. It will print to your Viewer rather than the console.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a new object with the table output - as this is a key output that you can then integrate into a document later rather than just viewing for now.\n\n# Create an object with the table\ncb_country_table &lt;- mpox_linelist %&gt;%\n\n  #select the column that we want to use in the table\n  select(country) %&gt;% \n  \n  # create the table. No need to specify columns; it will tabulate all available columns (selected above)\n  tbl_summary() \n\n# Print the table\ncb_country_table\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\ncountry\n\n\n\n\n    CountryA\n816 (41%)\n\n\n    CountryB\n391 (20%)\n\n\n    CountryC\n474 (24%)\n\n\n    CountryD\n217 (11%)\n\n\n    CountryE\n102 (5.1%)\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nWhat country has the largest percentage of cases?\n\n Country C Country D Country B Country E Country A\n\n\n\n\n\n\n\n\nOkay so Country A has the most cases in total based on most recent data. But how does that change look over time?\nTasks:\n\nUsing the mpox case linelist, create an epicurve by week of notification\nUsing the mpox case linelist, create an epicurve by week of notification to enable a comparison of trends by country.\nUsing the mpox case linelist, create a heat plot with the number of cases by country and week of notification.\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nPrepare your data for the epicurve first. You can create a “week_date” column using the function floor_date() from {lubridate}. Take a look at the documentation to understand how it works and how to pick the starting day of the week.\nTo create the epicurve, you can use ggplot() and geom_bar(), which visualizes the number of rows within a group - e.g. number of cases per week. To compare trends in different countries, consider using the facet_wrap() function. If you are unsure on how ggplot() works, read the Epi R Handbook chapter on Epidemic curves.\nTo create a heatmap, you will need to create a table of counts by country and week of notification. You can do this using the functions group_by() and summarise() from {dplyr}. If you are unsure on how to do this, review the Grouping data chapter of the Epi R Handbook. Then, use the geom geom_tile() to create a heat plot. If you’re unsure on how to do this, read the EpiRhanbook section on Heat Plots\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nPrepare your data by creating the new column using mutate() and floor_date():\n\nmpox_linelist &lt;- mpox_linelist %&gt;% \n  # create week column with Monday start \n  mutate(week_date = floor_date(date_of_notification, unit = \"week\", week_start = \"Monday\")) \n\nThe code below creates an epicurve using ggplot() and the geom_bar() function, then applies further formatting. With geom_bar(), you only need to specify the x axis, and the function will visualize the number of rows per unique x axis value.\n\n# Open up the plot production with ggplot() function, specifying object and columns\nepicurve_mpox &lt;- ggplot(data = mpox_linelist,          \n                        aes(x = week_date)) +    \n  \n  geom_bar(fill=\"darkgreen\",                     #colour inside the bins\n                 color=\"white\",                  #outline colour of the bins\n                 alpha=0.8) +                    #transparency of the bins\n  \n  scale_x_date(breaks = \"2 weeks\") +             #set the x axis labels to two week intervals\n\n  labs(title=\"Mpox cases reported in 2022 in Countries A, B, C, D, and E\",\n       subtitle = \"Date as of August 31st 2022\") +  #add a title\n  \n  theme_minimal() +                             #assign a predefined theme\n  \n  theme(axis.text = element_text(size=9),       #define the font size of the axis text\n        axis.title = element_blank(),           #remove the titles of the x and y axis \n        axis.text.x = element_text(angle=90))   #rotate the x axis text\n           \n# Print the epicurve\nepicurve_mpox\n\n\n\n\n\n\n\n\nTo examine how the outbreak spread by country, add facet_wrap() to your ggplot code. This splits the graph into multiple smaller ones. As shown below, you can even simply add the function to the national epicurve object.\nAn alternative approach would be to create a stacked epicurve, i.e. retain the single epicurve but split each bar into colors per country. You would do this by adding fill = country to the aes() in the epicurve code. However, we don’t recommend this for comparing trends, as stacked bars make it harder to see individual patterns.\n\nepicurve_epox_country &lt;- epicurve_mpox + \n \n   # Facet wrap to make mini-plots, specifying that you want two columns of plots. \n  facet_wrap(.~country,\n             ncol = 1) \n\n# Print the epicurve\nepicurve_epox_country\n\n\n\n\n\n\n\n\nFinally, if you want to demonstrate this as a weekly heatmap, you can use geom_tile(). First, aggregate the data by week. Then pipe into a ggplot(), as shown below.\n\n# Assign the output of your ggplot code to a new object\nhp_mpox &lt;- mpox_linelist %&gt;% \n  \n  #first count the number of cases by country and notification week\n  count(country, week_date) %&gt;% \n\n  #you can pipe directly into the ggplot\n    ggplot(aes(x = week_date, # notification week along the x axis\n           y = country,       # country along the y axis\n           fill = n)) +       # colour in the heatmap tiles by number\n  \n  # specify that you want this to be a heatmap with geom_tile()\n  geom_tile(colour = \"black\") +   # black is the outline of each tile\n  \n  #define the gradient of the colours\n  scale_fill_gradient(            \n    low = \"lightgreen\",\n    high = \"red\") +\n  \n  #set the x axis labels to two week intervals\n  scale_x_date(breaks = \"2 weeks\") +             \n  \n  # Add titles\n  labs(\n    title= \"Mpox cases by country and week of notification\",\n    fill = \"Number of cases\"                               \n  ) +\n  \n  # Apply an overall theme to your plot\n  theme_bw() +\n  \n  # Customize other appearance details\n  theme(legend.position = \"bottom\",       #legend position to bottom\n        axis.text = element_text(size=9),     #define axis font \n        axis.title = element_blank(),         #remove the axis titles\n        axis.text.x = element_text(angle=90)) #rotate the x axis text\n    \n\n# Print the heatmap\nhp_mpox \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext, describe the age, gender, and sexual orientation of cases. What is interesting?\nTask:\n\nCreate a single table showing overall distribution of age, gender, and sexual orientation\nCreate an age-gender pyramid showing age as 10-year age bands\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo quickly create a presentation-ready table showing the breakdowns for three different columns, consider using the function tbl_summary() from {gtsummary}.\nTo create an age-gender pyramid, first create a new column with the function age_categories() from the {epikit} package. Then explore the function age_pyramid() from the {apyramid} package.You can find more about this function in the Epi R Handbook chapter Demographic pyramids and Likert-scales\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nSee below the code to quickly generate one table with the breakdown of different variables. The function tbl_summary() by default summarizes columns differently depending on their class:\n\nAge is a numeric column, so is summarized with a median and interquartile range.\nGender and sexual orientation are character values, so are described in terms of counts and percentages.\n\nYou can customize this further; explore the documentation by typing ?tbl_summary() in your console.\nNote that tbl_summary() by default does not include NAs in the counts and percentages, allowing you to see the distribution of non-missing values.\n\n# Create table of all three variables\ntab_demographics &lt;- mpox_linelist %&gt;% \n  \n  # select the columns of interest for\n  select(age, gender, sexual_orientation) %&gt;% \n  \n  # use tbl_summary() to create the table\n  tbl_summary() \n\ntab_demographics\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\nage\n37 (31, 45)\n\n\n    Unknown\n3\n\n\ngender\n\n\n\n\n    Female\n36 (1.8%)\n\n\n    Male\n1,960 (98%)\n\n\n    Other\n1 (&lt;0.1%)\n\n\n    Unknown\n3\n\n\nsexual_orientation\n\n\n\n\n    Bisexual\n7 (0.8%)\n\n\n    Heterosexual\n46 (5.2%)\n\n\n    MSM/homo or bisexual male\n833 (94%)\n\n\n    Unknown\n1,114\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n\nCreate the new age group column as follows. You can add this to the cleaning section of your script (which we covered 4.1).\n\nmpox_linelist &lt;- mpox_linelist %&gt;% \n  # Use the age_categories function to create age categories\n  mutate(age_group = age_categories(age, lower = 0, #set up the lower age\n                                    upper = 70, #set up the upper age\n                                    by = 10)) #set up the age breaks\n\nThen make the age-gender pyramid using the age_pyramid() function. It is a function that builds on ggplot, so you can then continue to add on customization, such as the theme_bw() below.\n\n# Create table of all three variables\nfigure_agesex &lt;- mpox_linelist %&gt;% \n  \n  # Filter to male and female only\n  filter(gender %in% c(\"Male\", \"Female\")) %&gt;% \n  \n  # select the columns of interest for\n  age_pyramid(age_group = \"age_group\",\n              split_by = \"gender\") +\n  \n  # change theme\n  theme_bw()\n\nfigure_agesex\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nWhich demographic group is more affected by Mpox?\n\n Females 60-69 Males 40-49 Females 10-19 Males 30-39\n\n\n\nWhat proportion of mpox cases were homosexual or bisexual men?\n\n 41% 42% 5% 94%\n\n\n\n\n\n\n\n\nThe media is starting to call your office and are asking what symptoms the public should look out for. Just in luck - you can check that out in the data too!\nTasks:\n\nCreate a table with the distribution of different symptoms and outcomes.\n\nNo hints! You should know this one by now!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\n\n# Table with number and percentage of cases by outcome\n\ntab_outcome &lt;- mpox_linelist %&gt;% \n  \n  # Select the columns for tabulation\n  select(outcome, clinical_symptoms) %&gt;% \n  \n  # Use tbl_summary() - note that this time we are adding on labels to change how the column name is displayed\n  tbl_summary(label = list(\n    clinical_symptoms = \"Symptoms\",\n    outcome = \"Reported outcome\")) \n\ntab_outcome\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\nReported outcome\n\n\n\n\n    Alive\n1,405 (100%)\n\n\n    Unknown\n595\n\n\nSymptoms\n\n\n\n\n    Lesions\n14 (0.7%)\n\n\n    Rash\n257 (13%)\n\n\n    Rash, Lesions\n323 (16%)\n\n\n    Rash, Systemic symptoms\n676 (34%)\n\n\n    Rash, Systemic symptoms, Lesions\n654 (33%)\n\n\n    Systemic symptoms\n28 (1.4%)\n\n\n    Systemic symptoms, Lesions\n36 (1.8%)\n\n\n    Unknown\n12\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou’ve described a lot now, but you want to make sure you understand how timely and complete your mpox linelist is, especially if it will be the basis of making decisions.\nFor example - is it possible that there are very different reporting delays between countries, meaning current case counts are not directly comparable? Oh dear, must check.\n\n\nTasks\n\nCalculate median time from symptom onset to diagnosis and from diagnosis to notification, both overall and by country\nAssess visually the number of cases by calendar period and type of date (onset, diagnosis and notification)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo plot together the different dates you may need to transform your data from “wide” to “long” form. What we call “pivoting” in R. The objective is to have a column with the different date categories (onset, diagnosis and notification) and another column with their date value. If you are unsure on how to do this, have a look at the Pivoting data chapter of the Epi R Handbook. Then, try to plot with the daily values, but if that’s not easy to interpret you may want to aggregate cases by week.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nIs there a difference in the delay from diagnosis to notification by country?\n\n Yes No\n\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst create the required columns for this analysis.\n\n# Create two columns in linelist to assess delays\ndelay_db &lt;- mpox_linelist %&gt;% \n  \n  # Time between onset and diagnosis (converted to a number)\n  mutate(delay_diag = as.numeric(date_of_diagnosis - date_of_onset)) %&gt;%   \n\n  # Time between diagnosis and notification (converted to a number)\n  mutate(delay_not = as.numeric(date_of_notification - date_of_diagnosis)) \n\nUse the summary function from base R to quickly view the median, mean, interquartile range, and rang.\n\n# Summarize the delays to diagnosis\nsummary(delay_db$delay_diag) \n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n -2.000   4.000   7.000   7.758  10.000  66.000     897 \n\n# Summarize the delays from diagnosis to notification\nsummary(delay_db$delay_not)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.     NA's \n-46.0000  -2.0000   0.0000  -0.6078   1.0000  23.0000      715 \n\n\nUse group_by() and summarize() to create a table with median delays per country.\n\ndelay_country &lt;- delay_db %&gt;% \n  \n  # Group by country\n  group_by(country) %&gt;% \n  \n  # Create columns for each delay\n  summarise(median_delay_diag = median(delay_diag, na.rm = T),\n            median_delay_not = median(delay_not, na.rm = T))\n\ndelay_country\n\n# A tibble: 5 × 3\n  country  median_delay_diag median_delay_not\n  &lt;chr&gt;                &lt;dbl&gt;            &lt;dbl&gt;\n1 CountryA                 7                0\n2 CountryB                 7                0\n3 CountryC                 6                0\n4 CountryD                 7                0\n5 CountryE                 6                0\n\n\nTo explore how the trends in cases over time differ when using different dates, you can reshape the linelist to create a dataset with one row per date type per case.\n\n# Prepare the data\ndates_longer &lt;- mpox_linelist %&gt;% \n  \n  select(age, gender, sexual_orientation, starts_with(\"date_\")) %&gt;% \n\n  pivot_longer(\n    \n      # all columns starting with \"date_\" will be pivoted from wide to long \n      cols=starts_with(\"date_\"),         \n    \n      # put names of the columns into a single column called \"indicator\"\n      names_to = \"indicator\",   \n      \n      # the date values will be placed in a column called \"date\"\n      values_to = \"date\")                \n\nThe data will then look like this, with three rows per case:\n\n\n\n\n\n\nThen tabulate cases by week per indicator\n\n# Create new object\ndates_longer_week &lt;- dates_longer  %&gt;% \n\n  # Create a new week column\n  mutate(week_date = floor_date(date, unit = \"week\", week_start = \"Monday\")) %&gt;%  \n  \n  # Within each combination of indicator and week, calculate the number of cases\n  group_by(indicator, week_date) %&gt;% \n  summarise(n=n()) %&gt;%   \n  \n  # drop the cases with no data on dates  \n  drop_na(week_date)                     \n\nThe data will then look like this, with three rows per case:\n\n\n\n\n\n\nFinally, create a plot with ggplot() and geom_line().\n\nplot_date_delay &lt;-   ggplot(data = dates_longer_week,\n                            aes(x = week_date, \n                                y = n, \n                                color=indicator)) +\n  \n  geom_line(linewidth = 1.5) +\n  \n  scale_x_date(breaks = \"2 weeks\")+\n  \n  theme_bw() +\n  \n  theme(legend.position = \"bottom\", \n        axis.text = element_text(size=9),\n        axis.title = element_blank(),\n        axis.text.x = element_text(angle=90),\n        legend.title = element_blank()) +\n  labs(title=\"Mpox cases reported in 2022, by date of onset, diagnosis and notification.\")\n\nplot_date_delay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, you remember that all along you’ve had these aggregate counts from routine surveillance. You find out that these numbers are actually already being published.\nBefore you share your own numbers, you’d better check how different they are from already published statistics!\nTask: Create a plot comparing the number of cases reported to through the case-based flow and through the aggregated flow in each country.\nNOTE: Take into consideration that the column on cases in the aggregated data frame reports the cumulative number of cases.\n\n\n\n\n\n\nTest yourself!\n\nWhich country is not reporting aggregated data?\n\n A B C D E\n\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, create a data frame of country totals from the aggregate data.\n\nmpox_agg_country &lt;- mpox_agg %&gt;% \n \n  # as we have cumulative data, we keep only the last week per country \n  group_by(country) %&gt;% \n  filter(date_rep == max(date_rep)) %&gt;% \n  \n  # remove unnecessary columns\n  select(-date_rep, -week_date) %&gt;%     \n\n  # create this column to distinguish the numbers from the linelist data\n  mutate(source = \"aggregated\")         \n\nThen create a data frame of country totals from the case linelist, and append it to the totals from the aggregate data.\n\nmpox_linelist_country &lt;- mpox_linelist %&gt;%\n  \n  # count cases by country, use the same column name as in the aggregate data\n  group_by(country) %&gt;% \n  summarise(cases = n()) %&gt;% \n  \n  # create this column to distinguish the numbers from the linelist data\n  mutate(source = \"case_based\")       \n  \n\n# Append both data frames. Remember this is different from merging\ntotal_data &lt;- bind_rows(mpox_linelist_country, mpox_agg_country)\n\nYou can now use this data to compare the cases reported in both sources, using ggplot().\n\ngraph_comp &lt;- ggplot(data = total_data,\n                     aes(x = source, \n                         y = cases, \n                         fill = source)) +\n  \n  #position dodge puts bars one next to each other, instead of \"stacked\"\n  geom_col(position = \"dodge\") +            \n  \n  # this command gives us one graph per country. The argument scales allows each y axis scales to adjust to the data\n  facet_wrap(~ country, scales = \"free_y\") +  \n\n  # changes the colours, but with the argument \"labels\" we can change the text of each fill.\n  scale_fill_viridis_d(\n    labels = c(\"Aggregated\", \"Case-based\")) +\n  \n  labs(\n    title = \"Number of cases of Mpox reported in 2022 according to source of data\",\n    fill = \"Source\",\n    x = \"\",\n    y = \"Total number of cases\"\n  ) + \n  \n  theme_bw() +\n  \n  # we remove the text of the x axis because it is already present in the legend\n  theme(axis.text.x = element_blank(),   \n        \n   # we also remove the ticks for aesthetic purposes\n        axis.ticks.x = element_blank())    \n\ngraph_comp\n\n\n\n\n\n\n\n\n\nInteresting! There are some differences - and this probably will be worth flagging with stakeholders and/or explaining in a footnote somewhere.\n\n\n\n\n\n\n\nWell done! Through your analysis you now understand the magnitude of the outbreak so far, where and when it spread, which demographic groups are most affected, and how the disease actually manifests in terms of symptoms and severity. ECDC is very happy with your work.\nBy coding this up in R, this analysis should be reproducible, meaning you can quickly update it with new data and keep monitoring the outbreak.\nOf course, the above data is not real. If you want to see a paper on the actual outbreak that occured in Europe in 2022, you can take a look at this Eurosurveillance paper. This ECDC page on Mpox also publishes updates on the status of mpox in Europe.\nTo further practise reproducible reports, see the Reports with R Markdown chapter in the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nOriginal authors: Xanthi Andrianou, Gianfranco Spiteri (ECDC EI Group)\nData source: Fictional data provided by European Centre for Disease Prevention and Control Epidemic Intelligence (ECDC EI) Group for training purposes\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nChanges made\nVersion\nAuthor\n\n\n\n\nOctober 2021\nFirst draft\n1\nXanthi Andrianou\n\n\nJune 2024\nAdapted to case study template\n1.1\nAlberto Mateo Urdiales\n\n\nSeptember 2024\nRevise for case study repository\n1.2\nPaula Blomquist and Alanah Jansen\n\n\n\n\n\n\nDisclaimer: The information presented in this exercise and the associated data files have been developed to help learners achieve the intended learning objectives.\nLicense: This case study is under a derivation of the CC BY-SA 3.0 license"
  },
  {
    "objectID": "pages/r_practical.html#scenario",
    "href": "pages/r_practical.html#scenario",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "It is May 2022 and Mpox has just been reported for the first time across 5 countries in Europe: Countries “A”, “B”, “C”, “D”, and “E”. You have been requested to provide a basic descriptive analysis to the European Centre for Disease Prevention and Control (ECDC).\nYou are given access to:\n\nA dataset with aggregate case counts, submitted to ECDC by the five countries as part of routine European reporting\nA linelist with cases, submitted by the five countries to ECDC for this particular analysis\n\nLet’s go!"
  },
  {
    "objectID": "pages/r_practical.html#objectives",
    "href": "pages/r_practical.html#objectives",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "In this case study you will:\n\nExplore different types of files and how they can be imported in R.\nPerform basic data cleaning, e.g., changing the variable type, recoding variables, aggregating and filtering.\nPerform a basic descriptive analysis using tables and graphs"
  },
  {
    "objectID": "pages/r_practical.html#step-1.-set-up",
    "href": "pages/r_practical.html#step-1.-set-up",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Start by setting up a reproducible and well-organized workflow. This will make it easy to rerun your analysis whenever needed.\nTasks:\n\nSet up an RStudio project\nSet up clear sub-folders where your code, data, and outputs will go\nCreate an R script, or an R Markdown file if you prefer. Make sure the script purpose, date, and author are written as comments at the top.\nExtra: Ensure your working language in RStudio is appropriate (e.g. English for this exercise)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\n\nCreate a folder where all the work in this case study will go. For example, create ‘mpox_analysis’ on your computer desktop. Create your RStudio project to be based in this folder.\nWe suggest creating the following sub-folders: scripts (for your code), data (for your data), and outputs (for your analytical outputs).\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a folder (e.g. ‘mpox_analysis’ on your Desktop) for your work. To create an Rstudio project in your new folder, click New Project… in the top left of your R Studio, then Existing Directory, then Browse to select your new folder. For more information, look at the R projects section of the Epi R Handbook.\nStart a new R script by clicking New File… in the top left of your R Studio, then R Script. Save it immediately in the appropriate place, e.g. in a ‘scripts’ subfolder of your R Project.\nAt the top of your new R script, write some essential information like your name, the purpose of the file, and the date.\nYour R locale determines the language and regional settings used for things like date formats and translations. If your locale is different from the language you want for your report (e.g., a French locale vs. an English report), you can change it to English by running Sys.setlocale(\"LC_ALL\", \"English\"). Include this in your script if needed, or skip it if your locale is usually appropriate. This is explained in more detail in the How-to Guide.\n\n\n\n\n\n\nNext in your R script, you need to install and load the necessary R packages. This ensures that the functions you need are available for your analysis.\nYou will need the following packages: rio (for importing data), janitor (for cleaning data), lubridate (for cleaning dates), skimr (for reviewing data), epikit (for epi-related tasks), gtsummary (for presentation-ready tables), apyramid (for age-sex pyramids), and tidyverse (for general data manipulation/science tasks).\nAs you start, your trusted colleague nudges you and whispers “I’ve heard that a great way to manage your packages is with the pacman package”.\nOver to you!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUse the function p_load() from pacman for this task. You provide the function with a list of packages that you want to use. It will take two steps per package: 1) Check if the package is installed on your computer, and install it if necessary, then 2) Load the package so it can be used during this R session.\nIf you don’t already have pacman installed, you will need to install it the “traditional way” first, with install.packages().\nNote that the order of packages in your p_load function can be important. If two packages have the same function names (e.g. select() in the package MASS and select() in tidyverse, which do different things), then R will use the function from the most recently loaded package. To prioritize functions from tidyverse, which are commonly used for data manipulation and visualization, load tidyverse last.\n\n# Ensures the package \"pacman\" is installed\nif (!require(\"pacman\")) {\n     install.packages(\"pacman\") }\n\n# install (if necessary) from CRAN and load packages to be used\npacman::p_load(\n  rio,        # importing data  \n  skimr,      # get overview of data\n  janitor,    # data cleaning and tables\n  lubridate,  # working with dates\n  epikit,     # to create age categories\n  gtsummary,  # summary statistics, tests and regressions \n  apyramid,   # plotting age pyramids \n  tidyverse  # data management and visualization\n)"
  },
  {
    "objectID": "pages/r_practical.html#step-2-download-and-import-the-data",
    "href": "pages/r_practical.html#step-2-download-and-import-the-data",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "ECDC provides you with two files for your analysis, both updated as of 31st August 2022:\n\nA case-level linelist (“mpox_linelist.xlsx”) with case information from five countries (countries A - E)\nAn aggregate table (“mpox_aggregate_table.csv”) for those countries with cumulative case counts per day.\n\nThey provide it to you via AppliedEpi’s very useful data repository, which you can access using the {appliedepidata} package. So first you need to download these two files to your own computer, as follows:\n\nInstall the {appliedepidata} package from GitHub using the install_github() function in the {remotes} package. Install {remotes} if you need to first.\n\n\n# Install remotes if you need to (so you can install a package from GitHub)\npacman::p_load(\"remotes\")\n\n# Use the install_github function from remotes to install appliedepidata\nremotes::install_github(\"appliedepi/appliedepidata\")\n\n\nSave the two datasets into a specific folder using the save_data() function from {appliedepidata}, by running the code below. The example below saves the data into a data subfolder within the RStudio project. Note that if you do not specify a location within the path argument of the function, a window will pop up asking you to manually select a folder.\n\n\n# Save down the two mpox files using the save_data() function from appliedepidata\nappliedepidata::save_data(\"mpox_linelist\",\n                        path = \"data\")\n\nappliedepidata::save_data(\"mpox_aggregate_table\",\n                          path = \"data\")\n\n\n\n\nGreat! Thanks ECDC and Applied Epi! Now it’s time to import the data from that folder into RStudio, so you can analyse it.\nTask: Import the downloaded case-based and aggregated data into your R environment. Ideally you want to use one function for both datasets, despite one being a csv and the other an xlsx file.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nUse the import function from the {rio} package, which can recognize and import different file types. It replaces importing functions that are specific to the file type, such as read.csv() from {base} for .csv files and read_excel() from {readxl} to import .xlsx files.\nIf you feel you need to know more about importing functions, read the Import and export chapter of the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nBelow we use the import function to bring in both files. Note how we are assigning the imported data to two objects, one called mpox_linelist_raw, and one called mpox_agg_raw. We add the ‘raw’ suffix to distinguish this data from the cleaned versions we will make later.\n\n# Import data  --------------\n\n# Case-based data\nmpox_linelist_raw &lt;- import(\"data/mpox_linelist.xlsx\")\n\n# Aggregated data\nmpox_agg_raw &lt;- import(\"data/mpox_aggregate_table.csv\")"
  },
  {
    "objectID": "pages/r_practical.html#step-3-explore-the-data",
    "href": "pages/r_practical.html#step-3-explore-the-data",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "The data’s in, and now it’s time to see what story it tells. Take an initial look at your data to check its quality and how you can best use it.\nTasks: Take a look at the different data frames and determine:\n\nThe number of columns and observations (e.g. their dimensions)\nThe class of their columns and whether it matches its nature (e.g., are “dates” considered “dates” by R?)\nIf the contents of columns are clean and standardized in the mpox linelist (e.g. gender, clinical symptoms, outcome, hiv status and sexual orientation). Do you need to recode any of them?\nHow unknown or missing data is categorized in these columns. Do these values need to be standardized?\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nAn efficient function for initial data exploring is skim() from the {skimr} package, as it gives you a lot of information on data structure and content, including the classes of columns.\nYou can use the function tabyl() from {janitor}, to get counts and percentages of every category in the data column, one by one. These get printed to your RStudio console.\nAlso - we recommend just looking at the data itself! A good function for this is view(), a baseR function.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nUsing the skim commands you can see the rows and columns of each dataset, and you can see how most of the columns in mpox_linelist_raw (including those containing dates) are character classes. (Results not shown on this exercise page)\n\n# Explore the dimensions of the two data objects \nskim(mpox_linelist_raw)\nskim(mpox_agg_raw)\n\nTake a look at the overall data using view(). It will pop up in the Data Viewer tab and you will get a good sense of how clean the data is and what the missingness is like. This preview shows just 5 rows from the linelist data.\n\nview(mpox_linelist_raw)\n\n\n\n\n\n\n\nBelow is an example of using the tabyl() function from {janitor}, to look at the distribution of clinical symptoms. You can see 12 cases have missing clinical information and that many cases have a mix of symptoms.\n\ntabyl(mpox_linelist_raw, ClinicalSymptoms)  \n\n                 ClinicalSymptoms   n percent valid_percent\n                          Lesions  14  0.0070   0.007042254\n                             Rash 257  0.1285   0.129275654\n                    Rash, Lesions 323  0.1615   0.162474849\n          Rash, Systemic symptoms 676  0.3380   0.340040241\n Rash, Systemic symptoms, Lesions 654  0.3270   0.328973843\n                Systemic symptoms  28  0.0140   0.014084507\n       Systemic symptoms, Lesions  36  0.0180   0.018108652\n                             &lt;NA&gt;  12  0.0060            NA\n\n\nYou can explore further columns one by one (results not shown):\n\n# Explore the values of different categorical columns in the mpox linelist: with tabyl\ntabyl(mpox_linelist_raw, Gender)\n\ntabyl(mpox_linelist_raw, HIVStatus)\n\ntabyl(mpox_linelist_raw, Outcome)\n\ntabyl(mpox_linelist_raw, SexualOrientation)\n\nYou could add extra arguments to tabyl() to customize the tables, such as adding totals and changing the proportions to percentages so they are easier to read. See the table on clinical symptoms below. But remember - this is just an initial look so don’t go too crazy.\n\ntabyl(mpox_linelist_raw, ClinicalSymptoms) %&gt;%    # Tabulate symptoms \n  adorn_totals() %&gt;%                              # Add totals to bottom of table\n  adorn_pct_formatting(digits = 2)                # Format percentages\n\n                 ClinicalSymptoms    n percent valid_percent\n                          Lesions   14   0.70%         0.70%\n                             Rash  257  12.85%        12.93%\n                    Rash, Lesions  323  16.15%        16.25%\n          Rash, Systemic symptoms  676  33.80%        34.00%\n Rash, Systemic symptoms, Lesions  654  32.70%        32.90%\n                Systemic symptoms   28   1.40%         1.41%\n       Systemic symptoms, Lesions   36   1.80%         1.81%\n                             &lt;NA&gt;   12   0.60%             -\n                            Total 2000 100.00%       100.00%\n\n\nFinally, as an alternative approach to tabyl(), you could use tbl_summary() from the {gtsummary} package. We will describe this later.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nHow many columns does the aggregated data have?\n\n 2000 13 3 101\n\n\n\nWhat is the class of the column DateOfNotification in the mpox linelist?\n\n Date Character Numeric Factor\n\n\n\nFor how many cases is the HIV status unknown or missing?\n\n 1168 722 900 446"
  },
  {
    "objectID": "pages/r_practical.html#step-4-clean-the-data",
    "href": "pages/r_practical.html#step-4-clean-the-data",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "So! The good news: you have information on geography, dates, demographic characteristics, and clinical details. A promising descriptive analysis lies ahead.\nBUT! You may noticed that there are a few things to fix before the real detective work begins.\nFor example:\n\nColumn names have capital letters. This isn’t outright a problem, but can lead to mistakes since R treats ColumnName and Columnname as different.\nDate columns are recognized as character classes, not dates, which would cause issues like incorrect ordering (alphabetical) in epicurves.\nSome columns have values that are unclear or unsuitable for presentation. For example gender is categorized with “F”, “M”, “O” and “UNK”. The column Outcome is “A” and “UNK”.\nMissing data is inconsistently handled, for instance with both “UNK” and NA in the HIV status column. R thinks “UNK” is a valid value, which it treats differently to true missing data (indicated by NA)\n\nTasks:\n\nCreate a clean version of your case-based data making all cleaning changes in a single piping command\nChange all column names to lower case.\nConvert all date columns to class “Date”.\nConvert all missing/unknown values to NA (to be recognized by R as missing)\nRecode non-missing “Gender” categories into: “Female”, “Male”, and “Other”\nRecode non-misising HIV status into: “Positive”, “Negative” and “Unknown”\nRecode non-missing sexual orientation into: “Bisexual”, “Heterosexual”, and “MSM/homo or bisexual male”.\nRecode non-missing “outcome” categories into: “Alive” and “Dead”.\nCheck that all changes have been made correctly\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo convert all column names to lower case at once rather than renaming each column, use the function clean_names() from the {janitor} package.\nUse {lubridate} functions to transform date columns into “Date” class. You can do this one by one, or you could do all at the same time using the across() function from {dplyr}. If you feel you need to know more about transforming dates read the chapter Working with Dates from the Epi R Handbook. If you are not sure how to use the across() function, you can also read the section on Transform multiple columns.\nThere are different functions that we can use to recode values. We propose three: The function recode() from {dplyr}, the function ifelse() from {base} and the function case_when() from {dplyr}. If you want to know more about these functions, look that the section on Re-code values from the Epi R Handbook.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nHere we clean the data using a ‘chain’ of commands connected by pipes (%&gt;%), which is the grammar of the functions in the {Tidyverse}. The output is assigned to a new object called mpox_linelist to differentiate it from the raw data. It can be helpful to have both the cleaned and raw data available in the environment to compare to the original data if needed.\nSee the series of functions and the explanation in the comments.\n\n# Create a new object called mpox_linelist which is the clean version of the raw data\nmpox_linelist &lt;- mpox_linelist_raw %&gt;% \n  \n  # standardises names and puts all into lower case \n  clean_names() %&gt;% \n  \n  #transform ONE column into date (note the column names are lower case now)\n  mutate(date_of_notification = ymd(date_of_notification)) %&gt;%  \n\n  #transforms ALL columns starting with \"date\" into dates\n  mutate(across(starts_with(\"date\"), \n                .fns = ~ ymd(.x))) %&gt;%  \n  \n  #transforms UNK to NA across all character columns \n  mutate(across(where(is.character), \n                .fns = ~ ifelse(.x %in% c(\"UNK\", \"Unknown\"), NA_character_, .x)))  %&gt;% \n\n  # Recode the gender values to be more obvious  \n  mutate(gender = recode(gender,\n                         \"F\" = \"Female\",\n                         \"M\" = \"Male\",\n                         \"O\" = \"Other\")) %&gt;%\n  \n  #recode with ifelse to change only one or two categories based on a rule. \n  mutate(outcome = ifelse(outcome == \"A\", \"Alive\", outcome)) %&gt;%   \n  \n  #recode with case_when for more complex recoding \n  mutate(hiv_status = case_when(hiv_status == \"NEG\" ~ \"Negative\",    \n                                hiv_status == \"POS\" ~ \"Positive\")) %&gt;% \n  \n  mutate(sexual_orientation = case_when(sexual_orientation == \"BISEXUAL\" ~ \"Bisexual\",\n                                        sexual_orientation == \"HETERO\" ~ \"Heterosexual\",\n                                        sexual_orientation == \"MSM\" ~ \"MSM/homo or bisexual male\")) \n\nYou can then review your data by tabulating across all the different columns you have cleaned. See the preview of the hiv_status table below - it looks tidier now with more understandable categories, and all missing data is classified as ‘unknown’.\n\n# Check that all changes have been made correctly\n\nskim(mpox_linelist)\n\ntabyl(mpox_linelist, gender)\n\ntabyl(mpox_linelist, clinical_symptoms)\n\ntabyl(mpox_linelist, outcome)\n\ntabyl(mpox_linelist, hiv_status)\n\ntabyl(mpox_linelist, sexual_orientation)\n\n\n\n hiv_status    n percent valid_percent\n   Negative  525  0.2625     0.6310096\n   Positive  307  0.1535     0.3689904\n       &lt;NA&gt; 1168  0.5840            NA\n\n\nIMPORTANT: If ‘unknown’ and NA had meaningful differences, combining them wouldn’t be appropriate (e.g., if ‘unknown’ meant the case was asked but didn’t want to respond, while NA meant they weren’t asked). Here, we assume no meaningful difference and want R to recognize them as missing.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nIs it always appropriate to combine different types of unknown data? (e.g. missing, unknown, did not respond, NA)\n\n Yes Depends on the meaning of those values No - never do this\n\n\n\nHow many male cases do we have in the data frame?\n\n 36 1960 65 1523\n\n\n\nHow many cases have ‘alive’ as an outcome?\n\n 1405 0 595\n\n\n\n\n\n\n\n\nIn a similar way, clean the aggregated data by:\n\nStandardising names to lower case\nEnsuring that date of reporting is of class “Date”\nCreating a column called “week_date” with the week of reporting starting on Monday\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nWe can first check the class of the DateRep column, which shows us that it was already recognized as a date column on import.\n\n# Check class of date of reporting column\nclass(mpox_agg_raw$DateRep)\n\nThen create a new object for the clean aggregate data, and write your cleaning coded connected with pipes.\n\n# Create a new object called mpox_agg which is the clean version of the raw data, applying the cleaning functions\n\nmpox_agg &lt;- mpox_agg_raw %&gt;% \n  \n  # standardises names and puts all into lower case\n  clean_names() %&gt;%  \n  \n  # create week column with Monday start\n  mutate(week_date = floor_date(date_rep, \n                              unit = \"week\",\n                              week_start = \"Monday\")) \n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nTake a look at the aggreate data. Which country reported the largest cumulative number of cases during the week 2022-04-11?\n\n Country A Country B Country C Country D Country E"
  },
  {
    "objectID": "pages/r_practical.html#step-5-describe-outbreak-by-person-place-and-time",
    "href": "pages/r_practical.html#step-5-describe-outbreak-by-person-place-and-time",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Now we’re getting to the heart of the investigation. Who is affected? Which locations are most affected, and how quickly is it spreading? Your ability to tell the classic “person, place, and time” story will be crucial to guiding the response. Pinpoint those hotspots and trends!\n\n\nTask: Using the mpox case linelist, create a table showing the total number of cases by country. This time, make the table more publication-friendly.\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nYou could use tabyl() like before, but an easy way to produce publication-ready tables is with the function tbl_summary() from {gtsummary} package. This formats the table for you. It will print to your Viewer rather than the console.\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nCreate a new object with the table output - as this is a key output that you can then integrate into a document later rather than just viewing for now.\n\n# Create an object with the table\ncb_country_table &lt;- mpox_linelist %&gt;%\n\n  #select the column that we want to use in the table\n  select(country) %&gt;% \n  \n  # create the table. No need to specify columns; it will tabulate all available columns (selected above)\n  tbl_summary() \n\n# Print the table\ncb_country_table\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\ncountry\n\n\n\n\n    CountryA\n816 (41%)\n\n\n    CountryB\n391 (20%)\n\n\n    CountryC\n474 (24%)\n\n\n    CountryD\n217 (11%)\n\n\n    CountryE\n102 (5.1%)\n\n\n\n1 n (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nWhat country has the largest percentage of cases?\n\n Country C Country D Country B Country E Country A\n\n\n\n\n\n\n\n\nOkay so Country A has the most cases in total based on most recent data. But how does that change look over time?\nTasks:\n\nUsing the mpox case linelist, create an epicurve by week of notification\nUsing the mpox case linelist, create an epicurve by week of notification to enable a comparison of trends by country.\nUsing the mpox case linelist, create a heat plot with the number of cases by country and week of notification.\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nPrepare your data for the epicurve first. You can create a “week_date” column using the function floor_date() from {lubridate}. Take a look at the documentation to understand how it works and how to pick the starting day of the week.\nTo create the epicurve, you can use ggplot() and geom_bar(), which visualizes the number of rows within a group - e.g. number of cases per week. To compare trends in different countries, consider using the facet_wrap() function. If you are unsure on how ggplot() works, read the Epi R Handbook chapter on Epidemic curves.\nTo create a heatmap, you will need to create a table of counts by country and week of notification. You can do this using the functions group_by() and summarise() from {dplyr}. If you are unsure on how to do this, review the Grouping data chapter of the Epi R Handbook. Then, use the geom geom_tile() to create a heat plot. If you’re unsure on how to do this, read the EpiRhanbook section on Heat Plots\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nPrepare your data by creating the new column using mutate() and floor_date():\n\nmpox_linelist &lt;- mpox_linelist %&gt;% \n  # create week column with Monday start \n  mutate(week_date = floor_date(date_of_notification, unit = \"week\", week_start = \"Monday\")) \n\nThe code below creates an epicurve using ggplot() and the geom_bar() function, then applies further formatting. With geom_bar(), you only need to specify the x axis, and the function will visualize the number of rows per unique x axis value.\n\n# Open up the plot production with ggplot() function, specifying object and columns\nepicurve_mpox &lt;- ggplot(data = mpox_linelist,          \n                        aes(x = week_date)) +    \n  \n  geom_bar(fill=\"darkgreen\",                     #colour inside the bins\n                 color=\"white\",                  #outline colour of the bins\n                 alpha=0.8) +                    #transparency of the bins\n  \n  scale_x_date(breaks = \"2 weeks\") +             #set the x axis labels to two week intervals\n\n  labs(title=\"Mpox cases reported in 2022 in Countries A, B, C, D, and E\",\n       subtitle = \"Date as of August 31st 2022\") +  #add a title\n  \n  theme_minimal() +                             #assign a predefined theme\n  \n  theme(axis.text = element_text(size=9),       #define the font size of the axis text\n        axis.title = element_blank(),           #remove the titles of the x and y axis \n        axis.text.x = element_text(angle=90))   #rotate the x axis text\n           \n# Print the epicurve\nepicurve_mpox\n\n\n\n\n\n\n\n\nTo examine how the outbreak spread by country, add facet_wrap() to your ggplot code. This splits the graph into multiple smaller ones. As shown below, you can even simply add the function to the national epicurve object.\nAn alternative approach would be to create a stacked epicurve, i.e. retain the single epicurve but split each bar into colors per country. You would do this by adding fill = country to the aes() in the epicurve code. However, we don’t recommend this for comparing trends, as stacked bars make it harder to see individual patterns.\n\nepicurve_epox_country &lt;- epicurve_mpox + \n \n   # Facet wrap to make mini-plots, specifying that you want two columns of plots. \n  facet_wrap(.~country,\n             ncol = 1) \n\n# Print the epicurve\nepicurve_epox_country\n\n\n\n\n\n\n\n\nFinally, if you want to demonstrate this as a weekly heatmap, you can use geom_tile(). First, aggregate the data by week. Then pipe into a ggplot(), as shown below.\n\n# Assign the output of your ggplot code to a new object\nhp_mpox &lt;- mpox_linelist %&gt;% \n  \n  #first count the number of cases by country and notification week\n  count(country, week_date) %&gt;% \n\n  #you can pipe directly into the ggplot\n    ggplot(aes(x = week_date, # notification week along the x axis\n           y = country,       # country along the y axis\n           fill = n)) +       # colour in the heatmap tiles by number\n  \n  # specify that you want this to be a heatmap with geom_tile()\n  geom_tile(colour = \"black\") +   # black is the outline of each tile\n  \n  #define the gradient of the colours\n  scale_fill_gradient(            \n    low = \"lightgreen\",\n    high = \"red\") +\n  \n  #set the x axis labels to two week intervals\n  scale_x_date(breaks = \"2 weeks\") +             \n  \n  # Add titles\n  labs(\n    title= \"Mpox cases by country and week of notification\",\n    fill = \"Number of cases\"                               \n  ) +\n  \n  # Apply an overall theme to your plot\n  theme_bw() +\n  \n  # Customize other appearance details\n  theme(legend.position = \"bottom\",       #legend position to bottom\n        axis.text = element_text(size=9),     #define axis font \n        axis.title = element_blank(),         #remove the axis titles\n        axis.text.x = element_text(angle=90)) #rotate the x axis text\n    \n\n# Print the heatmap\nhp_mpox \n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext, describe the age, gender, and sexual orientation of cases. What is interesting?\nTask:\n\nCreate a single table showing overall distribution of age, gender, and sexual orientation\nCreate an age-gender pyramid showing age as 10-year age bands\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo quickly create a presentation-ready table showing the breakdowns for three different columns, consider using the function tbl_summary() from {gtsummary}.\nTo create an age-gender pyramid, first create a new column with the function age_categories() from the {epikit} package. Then explore the function age_pyramid() from the {apyramid} package.You can find more about this function in the Epi R Handbook chapter Demographic pyramids and Likert-scales\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nSee below the code to quickly generate one table with the breakdown of different variables. The function tbl_summary() by default summarizes columns differently depending on their class:\n\nAge is a numeric column, so is summarized with a median and interquartile range.\nGender and sexual orientation are character values, so are described in terms of counts and percentages.\n\nYou can customize this further; explore the documentation by typing ?tbl_summary() in your console.\nNote that tbl_summary() by default does not include NAs in the counts and percentages, allowing you to see the distribution of non-missing values.\n\n# Create table of all three variables\ntab_demographics &lt;- mpox_linelist %&gt;% \n  \n  # select the columns of interest for\n  select(age, gender, sexual_orientation) %&gt;% \n  \n  # use tbl_summary() to create the table\n  tbl_summary() \n\ntab_demographics\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\nage\n37 (31, 45)\n\n\n    Unknown\n3\n\n\ngender\n\n\n\n\n    Female\n36 (1.8%)\n\n\n    Male\n1,960 (98%)\n\n\n    Other\n1 (&lt;0.1%)\n\n\n    Unknown\n3\n\n\nsexual_orientation\n\n\n\n\n    Bisexual\n7 (0.8%)\n\n\n    Heterosexual\n46 (5.2%)\n\n\n    MSM/homo or bisexual male\n833 (94%)\n\n\n    Unknown\n1,114\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n\nCreate the new age group column as follows. You can add this to the cleaning section of your script (which we covered 4.1).\n\nmpox_linelist &lt;- mpox_linelist %&gt;% \n  # Use the age_categories function to create age categories\n  mutate(age_group = age_categories(age, lower = 0, #set up the lower age\n                                    upper = 70, #set up the upper age\n                                    by = 10)) #set up the age breaks\n\nThen make the age-gender pyramid using the age_pyramid() function. It is a function that builds on ggplot, so you can then continue to add on customization, such as the theme_bw() below.\n\n# Create table of all three variables\nfigure_agesex &lt;- mpox_linelist %&gt;% \n  \n  # Filter to male and female only\n  filter(gender %in% c(\"Male\", \"Female\")) %&gt;% \n  \n  # select the columns of interest for\n  age_pyramid(age_group = \"age_group\",\n              split_by = \"gender\") +\n  \n  # change theme\n  theme_bw()\n\nfigure_agesex\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nWhich demographic group is more affected by Mpox?\n\n Females 60-69 Males 40-49 Females 10-19 Males 30-39\n\n\n\nWhat proportion of mpox cases were homosexual or bisexual men?\n\n 41% 42% 5% 94%\n\n\n\n\n\n\n\n\nThe media is starting to call your office and are asking what symptoms the public should look out for. Just in luck - you can check that out in the data too!\nTasks:\n\nCreate a table with the distribution of different symptoms and outcomes.\n\nNo hints! You should know this one by now!\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\n\n# Table with number and percentage of cases by outcome\n\ntab_outcome &lt;- mpox_linelist %&gt;% \n  \n  # Select the columns for tabulation\n  select(outcome, clinical_symptoms) %&gt;% \n  \n  # Use tbl_summary() - note that this time we are adding on labels to change how the column name is displayed\n  tbl_summary(label = list(\n    clinical_symptoms = \"Symptoms\",\n    outcome = \"Reported outcome\")) \n\ntab_outcome\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nN = 2,0001\n\n\n\n\nReported outcome\n\n\n\n\n    Alive\n1,405 (100%)\n\n\n    Unknown\n595\n\n\nSymptoms\n\n\n\n\n    Lesions\n14 (0.7%)\n\n\n    Rash\n257 (13%)\n\n\n    Rash, Lesions\n323 (16%)\n\n\n    Rash, Systemic symptoms\n676 (34%)\n\n\n    Rash, Systemic symptoms, Lesions\n654 (33%)\n\n\n    Systemic symptoms\n28 (1.4%)\n\n\n    Systemic symptoms, Lesions\n36 (1.8%)\n\n\n    Unknown\n12\n\n\n\n1 n (%)"
  },
  {
    "objectID": "pages/r_practical.html#step-6-reviewing-data-quality",
    "href": "pages/r_practical.html#step-6-reviewing-data-quality",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "You’ve described a lot now, but you want to make sure you understand how timely and complete your mpox linelist is, especially if it will be the basis of making decisions.\nFor example - is it possible that there are very different reporting delays between countries, meaning current case counts are not directly comparable? Oh dear, must check.\n\n\nTasks\n\nCalculate median time from symptom onset to diagnosis and from diagnosis to notification, both overall and by country\nAssess visually the number of cases by calendar period and type of date (onset, diagnosis and notification)\n\n\n\n\n\n\n\nClick to read a hint\n\n\n\n\n\nTo plot together the different dates you may need to transform your data from “wide” to “long” form. What we call “pivoting” in R. The objective is to have a column with the different date categories (onset, diagnosis and notification) and another column with their date value. If you are unsure on how to do this, have a look at the Pivoting data chapter of the Epi R Handbook. Then, try to plot with the daily values, but if that’s not easy to interpret you may want to aggregate cases by week.\n\n\n\n\n\n\n\n\n\nTest yourself!\n\nIs there a difference in the delay from diagnosis to notification by country?\n\n Yes No\n\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst create the required columns for this analysis.\n\n# Create two columns in linelist to assess delays\ndelay_db &lt;- mpox_linelist %&gt;% \n  \n  # Time between onset and diagnosis (converted to a number)\n  mutate(delay_diag = as.numeric(date_of_diagnosis - date_of_onset)) %&gt;%   \n\n  # Time between diagnosis and notification (converted to a number)\n  mutate(delay_not = as.numeric(date_of_notification - date_of_diagnosis)) \n\nUse the summary function from base R to quickly view the median, mean, interquartile range, and rang.\n\n# Summarize the delays to diagnosis\nsummary(delay_db$delay_diag) \n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n -2.000   4.000   7.000   7.758  10.000  66.000     897 \n\n# Summarize the delays from diagnosis to notification\nsummary(delay_db$delay_not)\n\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max.     NA's \n-46.0000  -2.0000   0.0000  -0.6078   1.0000  23.0000      715 \n\n\nUse group_by() and summarize() to create a table with median delays per country.\n\ndelay_country &lt;- delay_db %&gt;% \n  \n  # Group by country\n  group_by(country) %&gt;% \n  \n  # Create columns for each delay\n  summarise(median_delay_diag = median(delay_diag, na.rm = T),\n            median_delay_not = median(delay_not, na.rm = T))\n\ndelay_country\n\n# A tibble: 5 × 3\n  country  median_delay_diag median_delay_not\n  &lt;chr&gt;                &lt;dbl&gt;            &lt;dbl&gt;\n1 CountryA                 7                0\n2 CountryB                 7                0\n3 CountryC                 6                0\n4 CountryD                 7                0\n5 CountryE                 6                0\n\n\nTo explore how the trends in cases over time differ when using different dates, you can reshape the linelist to create a dataset with one row per date type per case.\n\n# Prepare the data\ndates_longer &lt;- mpox_linelist %&gt;% \n  \n  select(age, gender, sexual_orientation, starts_with(\"date_\")) %&gt;% \n\n  pivot_longer(\n    \n      # all columns starting with \"date_\" will be pivoted from wide to long \n      cols=starts_with(\"date_\"),         \n    \n      # put names of the columns into a single column called \"indicator\"\n      names_to = \"indicator\",   \n      \n      # the date values will be placed in a column called \"date\"\n      values_to = \"date\")                \n\nThe data will then look like this, with three rows per case:\n\n\n\n\n\n\nThen tabulate cases by week per indicator\n\n# Create new object\ndates_longer_week &lt;- dates_longer  %&gt;% \n\n  # Create a new week column\n  mutate(week_date = floor_date(date, unit = \"week\", week_start = \"Monday\")) %&gt;%  \n  \n  # Within each combination of indicator and week, calculate the number of cases\n  group_by(indicator, week_date) %&gt;% \n  summarise(n=n()) %&gt;%   \n  \n  # drop the cases with no data on dates  \n  drop_na(week_date)                     \n\nThe data will then look like this, with three rows per case:\n\n\n\n\n\n\nFinally, create a plot with ggplot() and geom_line().\n\nplot_date_delay &lt;-   ggplot(data = dates_longer_week,\n                            aes(x = week_date, \n                                y = n, \n                                color=indicator)) +\n  \n  geom_line(linewidth = 1.5) +\n  \n  scale_x_date(breaks = \"2 weeks\")+\n  \n  theme_bw() +\n  \n  theme(legend.position = \"bottom\", \n        axis.text = element_text(size=9),\n        axis.title = element_blank(),\n        axis.text.x = element_text(angle=90),\n        legend.title = element_blank()) +\n  labs(title=\"Mpox cases reported in 2022, by date of onset, diagnosis and notification.\")\n\nplot_date_delay\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, you remember that all along you’ve had these aggregate counts from routine surveillance. You find out that these numbers are actually already being published.\nBefore you share your own numbers, you’d better check how different they are from already published statistics!\nTask: Create a plot comparing the number of cases reported to through the case-based flow and through the aggregated flow in each country.\nNOTE: Take into consideration that the column on cases in the aggregated data frame reports the cumulative number of cases.\n\n\n\n\n\n\nTest yourself!\n\nWhich country is not reporting aggregated data?\n\n A B C D E\n\n\n\n\n\n\n\n\n\n\n\nClick to see the solution (try it yourself first!)\n\n\n\n\n\nFirst, create a data frame of country totals from the aggregate data.\n\nmpox_agg_country &lt;- mpox_agg %&gt;% \n \n  # as we have cumulative data, we keep only the last week per country \n  group_by(country) %&gt;% \n  filter(date_rep == max(date_rep)) %&gt;% \n  \n  # remove unnecessary columns\n  select(-date_rep, -week_date) %&gt;%     \n\n  # create this column to distinguish the numbers from the linelist data\n  mutate(source = \"aggregated\")         \n\nThen create a data frame of country totals from the case linelist, and append it to the totals from the aggregate data.\n\nmpox_linelist_country &lt;- mpox_linelist %&gt;%\n  \n  # count cases by country, use the same column name as in the aggregate data\n  group_by(country) %&gt;% \n  summarise(cases = n()) %&gt;% \n  \n  # create this column to distinguish the numbers from the linelist data\n  mutate(source = \"case_based\")       \n  \n\n# Append both data frames. Remember this is different from merging\ntotal_data &lt;- bind_rows(mpox_linelist_country, mpox_agg_country)\n\nYou can now use this data to compare the cases reported in both sources, using ggplot().\n\ngraph_comp &lt;- ggplot(data = total_data,\n                     aes(x = source, \n                         y = cases, \n                         fill = source)) +\n  \n  #position dodge puts bars one next to each other, instead of \"stacked\"\n  geom_col(position = \"dodge\") +            \n  \n  # this command gives us one graph per country. The argument scales allows each y axis scales to adjust to the data\n  facet_wrap(~ country, scales = \"free_y\") +  \n\n  # changes the colours, but with the argument \"labels\" we can change the text of each fill.\n  scale_fill_viridis_d(\n    labels = c(\"Aggregated\", \"Case-based\")) +\n  \n  labs(\n    title = \"Number of cases of Mpox reported in 2022 according to source of data\",\n    fill = \"Source\",\n    x = \"\",\n    y = \"Total number of cases\"\n  ) + \n  \n  theme_bw() +\n  \n  # we remove the text of the x axis because it is already present in the legend\n  theme(axis.text.x = element_blank(),   \n        \n   # we also remove the ticks for aesthetic purposes\n        axis.ticks.x = element_blank())    \n\ngraph_comp\n\n\n\n\n\n\n\n\n\nInteresting! There are some differences - and this probably will be worth flagging with stakeholders and/or explaining in a footnote somewhere."
  },
  {
    "objectID": "pages/r_practical.html#conclusion",
    "href": "pages/r_practical.html#conclusion",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Well done! Through your analysis you now understand the magnitude of the outbreak so far, where and when it spread, which demographic groups are most affected, and how the disease actually manifests in terms of symptoms and severity. ECDC is very happy with your work.\nBy coding this up in R, this analysis should be reproducible, meaning you can quickly update it with new data and keep monitoring the outbreak.\nOf course, the above data is not real. If you want to see a paper on the actual outbreak that occured in Europe in 2022, you can take a look at this Eurosurveillance paper. This ECDC page on Mpox also publishes updates on the status of mpox in Europe.\nTo further practise reproducible reports, see the Reports with R Markdown chapter in the Epi R Handbook."
  },
  {
    "objectID": "pages/r_practical.html#case-study-information",
    "href": "pages/r_practical.html#case-study-information",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Original authors: Xanthi Andrianou, Gianfranco Spiteri (ECDC EI Group)\nData source: Fictional data provided by European Centre for Disease Prevention and Control Epidemic Intelligence (ECDC EI) Group for training purposes\n\n\n\n\n\n\n\n\n\n\n\n\nDate\nChanges made\nVersion\nAuthor\n\n\n\n\nOctober 2021\nFirst draft\n1\nXanthi Andrianou\n\n\nJune 2024\nAdapted to case study template\n1.1\nAlberto Mateo Urdiales\n\n\nSeptember 2024\nRevise for case study repository\n1.2\nPaula Blomquist and Alanah Jansen"
  },
  {
    "objectID": "pages/r_practical.html#terms-of-use",
    "href": "pages/r_practical.html#terms-of-use",
    "title": "Descriptive analysis of the 2022 Mpox outbreak in Europe",
    "section": "",
    "text": "Disclaimer: The information presented in this exercise and the associated data files have been developed to help learners achieve the intended learning objectives.\nLicense: This case study is under a derivation of the CC BY-SA 3.0 license"
  },
  {
    "objectID": "pages/under_construction.html",
    "href": "pages/under_construction.html",
    "title": "Under-construction case study page",
    "section": "",
    "text": "Under-construction case study page\n\n\n\n\n\n\nWEBSITE UNDER CONSTRUCTION\n\n\n\nThis case study is being developed. The content and URL will change.\n\n\nFor instructions on how to use our case studies, see our How-to Guide. We welcome feedback and suggestions via contact@appliedepi.org. You can also discuss the case study or related concepts on the Applied Epi Community."
  },
  {
    "objectID": "pages/under_construction.es.html",
    "href": "pages/under_construction.es.html",
    "title": "Sitio web en construcción",
    "section": "",
    "text": "Sitio web en construcción\n\n\n\n\n\n\nEN CONSTRUCCIÓN\n\n\n\nEsta página está en desarrollo. El contenido y la URL cambiarán.\n\n\nPara obtener instrucciones sobre cómo utilizar nuestros estudios de casos, consulte nuestra How-to Guide. Agradecemos sus comentarios y sugerencias en contact@appliedepi.org. También puede debatir sobre el estudio de caso o conceptos relacionados en la Applied Epi Community."
  },
  {
    "objectID": "pages/under_construction.fr.html",
    "href": "pages/under_construction.fr.html",
    "title": "Page en construction",
    "section": "",
    "text": "Page en construction\n\n\n\n\n\n\nEN CONSTRUCTION\n\n\n\nCette page est en cours de développement. Le contenu et l’URL vont changer.\n\n\nPour des instructions sur la façon d’utiliser nos études de cas, consultez notre How-to Guide. Nous accueillons vos retours et suggestions à l’adresse contact@appliedepi.org. Vous pouvez également discuter de l’étude de cas ou des concepts connexes sur la Applied Epi Community."
  }
]